## 简述

##### 1. 三种低级排序

- 冒泡排序：每一趟两两交换，将最小的元素浮到最前面(或者将最大元素沉到最后面)。
- 选择排序：每一趟选出一个最小值，放到前面
- 插入排序：不断从后面选一个数，然后插入到前面已经有序的序列里（**打扑克牌**）
- （希尔排序）：分组的插入排序

> 选择和冒泡排序**第i趟会放置好第i大或第i小的元素**

##### 2. 三种高级排序

- 快速排序：每一次都排定一个元素（这个元素呆在了它最终应该呆的位置），然后递归地去排它左边的部分和右边的部分
- 归并排序：借助额外空间分而治之再合并，合并两个有序数组，得到更长的有序数组。例[lc88.合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)。
- 堆排序

##### 3、topk问题

- 堆排序 
- 快速排序 

##### 4、其余

- 计数排序
- 基数排序
- 桶排序

## 详解

### 快速排序

#### 基本思想

![image-20240212183048975](C:\Users\Oscar\AppData\Roaming\Typora\typora-user-images\image-20240212183048975.png)

> 「快速排序」与「归并排序」比较
>
> - 都使用了「分而治之，的思想
> - 「归并排序」无差别将数组一分为二，然后不停地「合并两个有序数组」
> - 「快速排序」在「分」这件事情上做足了文章，没有「合并」的过程
> - 注意：实现归并排序的时候，要特别注意，不要把这个算法实现成非稳定排序，区别就在 <= 和 < ，已在代码中注明。
>     「归并排序」比「快速排序」好的一点是，它借助了额外空间，可以实现「稳定排序」

#### (1) 原始快排

伪码

```c++
//快排主函数, 对数组nums递归调用quickSort函数, 实现数组的有序排列
void quickSort(vector<int>& nums, int left, int right) 
    递归结束条件: left >= right
    单次递归执行逻辑: 
    (1)调用partition()划分区间, 将区间分成两部分:[left,pivotIndex)和(pivotIndex,right], partition()返回值是该次划分选择的基准元素的下标pivotIndex;
      划分完成后小于等于pivot的都在pivotIndex左边, 大于pivot的都在pivotIndex右边
    (2)接着对这两个区间[left,pivotIndex)和(pivotIndex,right]分别调用递归函数
            
int partition(vector<int>& nums, int left, int right)  
    (1)在区间中取一个元素作为基准元素nums[pivotIndex].(原始快排是取区间第一个元素)
    (2)根据值是 小于等于or大于 基准元素来划分区间：
    用 j 指向左区间的最后一个位置, 用 i 遍历整个区间, 分别初始化为j=left,i=j+1;
    for (int i = j + 1; i <= right; ++i) 
        if nums[i] <= pivot, 说明nums[i]应该放在左区间. 则应
          【1】 j++将左区间的右边界右移一位, 扩大左区间
          【2】 将nums[i]与nums[j]交换位置, 让nums[i]到左区间最后一个位置
    (3)交换基准元素nums[left]和左区间最后一个位置nums[j], 让基准元素位于两区间的分割位置
    (4)返回基准元素所在位置
```

```c++
class Solution {
public:
    int partition(vector<int>& nums, int left, int right) { 
        int pivot = nums[left];
        int j = left;
        for (int i = j + 1; i <= right; ++i) {
            if (nums[i] <= pivot) swap(nums[i], nums[++j]);
        }
        swap(nums[left], nums[j]);
        return j;
    }
    
    void quickSort(vector<int>& nums, int left, int right) {
        if (left >= right) return;
        int pivotIndex = partition(nums, left, right);
        quickSort(nums, left, pivotIndex - 1);
        quickSort(nums, pivotIndex + 1, right);
    }
    
    vector<int> sortArray(vector<int>& nums) {
        quickSort(nums, 0, nums.size() - 1);
        return nums;
    }
};
```

##### 存在问题

原始快排是无法AC  [912. 排序数组](https://leetcode.cn/problems/sort-an-array/)  的，过不了`nums ={1,2,3,4,5,1,1,1,1,1,····,1,1,1},k = 50000`这种特殊测试案例。
问题：取区间第一个元素作为pivot会导致**partition在顺序数组或逆序数组上表现很差**。
如下左图所示，每一次参与比较的元素不能够有效地减少，拆分的子问题的规模只比原来减少了1个元素。导致递归树非常不平衡（递归树倾斜），时间复杂度为O(N^2^)，等同于冒泡排序或者「选择排序」

##### 解决办法

随机选择 pivot，打破顺序性

![image-20240213095627215](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202402130956264.png)

#### (2) 随机选择pivot

主要添加两个地方

```c++
// 1. 添加随机数种子
srand((unsigned)time(nullptr));
// 2. 用rand()生成随机数
int partition(vector<int>& nums, int left, int right) {  
    // 要生成的随机下标的范围在left~right之间
    int randomIndex = rand() % (right - left + 1) + left;
    // rand() % (right - left + 1)        :生成 0        ~ (right - left)       的随机数
    // rand() % (right - left + 1) + left :生成 0 + left ~ (right - left) + left的随机数
    swap(nums[left], nums[randomIndex]);
	··········
}
```

完整代码

```c++
class Solution {
public:
    int partition(vector<int>& nums, int left, int right) {  
        // 要生成的随机下标的范围在left~right之间
        int randomIndex = rand() % (right - left + 1) + left;
        // rand() % (right - left + 1)        :生成 0        ~ (right - left)       的随机数
        // rand() % (right - left + 1) + left :生成 0 + left ~ (right - left) + left的随机数
        swap(nums[left], nums[randomIndex]);
        int pivot = nums[left];
        
        int j = left;
        for (int i = j + 1; i <= right; ++i) {
            if (nums[i] <= pivot) swap(nums[i], nums[++j]);
        }
        swap(nums[left], nums[j]);
        return j;
    }
    
    void quickSort(vector<int>& nums, int left, int right) {
        if (left >= right) return;
        int pivotIndex = partition(nums, left, right);
        quickSort(nums, left, pivotIndex - 1);
        quickSort(nums, pivotIndex + 1, right);
    }
    
    vector<int> sortArray(vector<int>& nums) {
        srand((unsigned)time(nullptr));//添加随机数种子
        quickSort(nums, 0, nums.size() - 1);
        return nums;
    }
};
```

##### 存在问题

随机选择pivot对数组中有大量重复元素的用例失效！！把等于pivot的所有元素分到了数组的同一侧（上面是把它们都分到了左区间），可能会造成递归树倾斜

##### 解决办法

二路快排或三路快排。

- 二路快排：把等于pivot的所有元素**等概率**地分到数组的两侧，避免了递归树倾斜，递归树相对平衡；
- 三路快排：把等于pivot的所有元素挤到了数组的中间，在有很多元素和切分元素相等的情况下，递归区间大大减少。

#### (3) 二路快排

**:small_red_triangle_down:  steps: ** `partition()` 将区间划分成 <= pivot 和 >= pivot的两部分

1.  随机选取pivot，并把选取的值与nums[left]交换
1.  让两个指针分别从区间两端往中间遍历
1.  当左指针遇到>=pivot的值时，停下
1.  接着右指针开始遍历，当遇到<=pivot的值时，停下
1.  若此时左右指针重合 或者 右指针在左指针前面，break
1.  交换左右指针指向的值

```c++
class Solution {
public:
    int partition(vector<int>& nums, int left, int right) {  
        // 要生成的随机下标的范围在left~right之间
        int randomIndex = left + rand() % (right - left + 1);
        //        rand() % (right - left + 1):生成        0 ~        (right - left)的随机数
        // left + rand() % (right - left + 1):生成 left + 0 ~ left + (right - left)的随机数
        swap(nums[left], nums[randomIndex]);
        int pivot = nums[left]; 

        int le = left + 1; // le: less equals 小于等于
        int ge = right; // ge: greater equals 大于等于
        while (true) { // 写成 while (le <= ge) 也可以
            while (le <= ge && nums[le] < pivot) le++;
            while (le <= ge && nums[ge] > pivot) ge--;
            // 此时le和ge分别指向>=pivot和<=pivot的值
            if (ge <= le) break;
            // 没有这句if行不行呢？不行！因为若此时 ge（指向<pivot的值） < le （指向>pivot的值）
            // 继续往下走swap, 则会变成 ge（指向>pivot的值） < le （指向<pivot的值）, 显然不行
            swap(nums[le++], nums[ge--]);
        }
        swap(nums[left], nums[ge]);
        return ge;
    }
    
    void quickSort(vector<int>& nums, int left, int right) {
        if (left >= right) return;
        int pivotIndex = partition(nums, left, right);
        quickSort(nums, left, pivotIndex - 1);
        quickSort(nums, pivotIndex + 1, right);
    }
    
    vector<int> sortArray(vector<int>& nums) {
        srand((unsigned)time(nullptr));//添加随机数种子
        quickSort(nums, 0, nums.size() - 1);
        return nums;
    }
}; 
```

#### (4) 三路快排

**:small_red_triangle_down:  steps: ** `partition()` 将区间划分成 <pivot，= pivot 和 >pivot的三部分（分别称第一、二、三区间）

1.  随机选取pivot，并把选取的值与nums[left]交换
2.  让指针 i 从left+1开始，从左往右遍历，当左指针遇到
    - <pivot的值时，就将其与第二区间的首位元素交换，然后i++
    - =pivot的值时，直接就i++
    - \>pivot的值时，就将其与第三区间的首位元素的前一个元素交换，然后ge--
3.  交换左右指针指向的值

> `lt` 也可以表示第一区间末位元素，只不过代码逻辑需要稍微变动一下，可以参考:fire:[75. 颜色分类](https://leetcode.cn/problems/sort-colors/)的两种三路快排partition写法

```c++
class Solution {
public: 
    pair<int, int> partition(vector<int>& nums, int left, int right) {  
        // 要生成的随机下标的范围在left~right之间
        int randomIndex = left + rand() % (right - left + 1);
        //        rand() % (right - left + 1):生成        0 ~        (right - left)的随机数
        // left + rand() % (right - left + 1):生成 left + 0 ~ left + (right - left)的随机数
        swap(nums[left], nums[randomIndex]);
        int pivot = nums[left];

        int lt = left + 1; // lt: less than 指向第一区间末位元素的下一个位置（也即第二区间的首位元素所在位置）
        int gt = right; // ge: greater than 指向第三区间首位元素的前一个位置
        // [left+1, lt)  < pivot
        //   [lt, i)    == pivot
        //   (gt, right] > pivot

        int i = left + 1;//用于遍历
        while (i <= gt) { 
            // 指针 i 从左往右遍历，当左指针遇到
            // < pivot的值时，就将其与第二区间的首位元素交换，然后lt++, i++
            if (nums[i] < pivot) swap(nums[lt++], nums[i++]);
            // > pivot的值时，就将其与第三区间的首位元素的前一个元素交换，然后gt--
            else if (nums[i] > pivot) swap(nums[i], nums[gt--]);
            // = pivot的值时，直接就i++
            else i++;
        }
        swap(nums[left], nums[lt - 1]);
        // 交换nums[left]和第一区间末位元素, 交换后第二区间左边界左移了一位, 第一区间右边界左移了一位
        // 也就是说交换后 lt-1 位置的值=pivot, 第一区间末位元素是lt-2
        // 一[left,lt-2] 二[lt-1,gt] 三[gt+1,right]
        return make_pair(lt - 2, gt + 1); 
    }
    
    void quickSort(vector<int>& nums, int left, int right) {
        if (left >= right) return;

        // pair<int, int> p = partition(nums, left, right);
        // int lt = p.first;
        // int gt = p.second;
        // 以上三句可以写成一句:
        auto [lt, gt] = partition(nums, left, right);
        // partition()划分区间为，之后只需再递归处理第一和第三区间，而中间第二区间的元素都已经落在了它们应该在的位置
        quickSort(nums, left, lt); 
        quickSort(nums, gt, right);
    }
    
    vector<int> sortArray(vector<int>& nums) {
        srand((unsigned)time(nullptr));//添加随机数种子
        quickSort(nums, 0, nums.size() - 1);
        return nums;
    }
}; 
```



### 归并排序

==看幕布上写的==

### 堆排序

#### 堆（看幕布）

  大根堆: 根节点是最大元素

  小根堆: 根节点是最小元素

![image-20240219222600215](C:\Users\Oscar\AppData\Roaming\Typora\typora-user-images\image-20240219222600215.png)

堆是从堆顶pop, 因此如果优先级队列用

- 大根堆，那么当堆每push一个元素就会pop堆顶最大元素，因此最终留下的是升序排序后前k个元素
- 小根堆，那么当堆每push一个元素就会pop堆顶最小元素，因此最终留下的是降序排序后前k个元素

而堆排序使用大根堆。

所以，==topK问题要用小根堆。==

两个基本操作：上滤、下滤。

两种建堆法：

- 自顶向下（上滤），堆是自顶向下**建**成的，时间复杂度为O(nlogn)。对于每个元素的操作分为两步：
    1. 将元素插到堆尾部
    2. 然后让其往上走进行上滤。

- 自下而上（下滤），堆是自下而上**调整**成的，时间复杂度为O(n)。
    1. 将n个元素插到堆中，
    2. 从倒数第二层开始调整堆，怎么调整？对该树的父节点进行下滤操作，将该树调整为堆。

#### 优先队列

优先级队列就是实现了【从队头弹出元素，从队尾插入元素】的对外接口的堆，对外接口同队列。

时间复杂度

- 从堆顶部弹出操作：O(logn)。因为弹出堆顶元素的同时要重新调整堆
    - 调整堆：先将最后一个元素放到根节点，然后下滤
- 从堆尾部插入操作：O(logn)。因为插入到尾部之后，要进行上滤操作。

> 模板声明：`priority_queue<Type, Container, Functional>`
>
> - Type要存放的数据类型
> - Container保存数据的容器，默认是vector<int>
> - Functional元素比较方式，当数据类型是**基本数据类型时，默认是大顶堆less<>**，若不是基本数据类型时则需要自定义比较方式。
>
> > 注意这里的Functional不能用lambada！！！因为`Lambda expressions are not allowed in unevaluated contexts (such as decltype) before C++20`，但是可以用仿函数或者重载"<"运算符，仿函数如：
> > ```cpp
> > class mycomparison {
> > public:
> >     bool operator()(const pair<int, int>& a, const pair<int, int>& b) {
> >         return a.second > b.second; //小根堆
> >     }
> > };
> > ```

#### 堆排序

==看幕布上写的==

- 升序：一般建大顶堆
- 降序：一般建小顶堆

## 相关概念

内部排序：排序期间元素全存在内存中的排序；

外部排序：排序期间元素无法全存在内存中，必须在排序过程中根据要求不断地进行内外存之间移动地排序；（只有多路归并排序是）

稳定性：排序后，值相同的元素保持原来顺序中的相对位置不变.

## 以前数据结构课写的代码

### 直接插入排序

```C
//基础算法
void insertSort(RecType R[],int n)
{   int i,j,RecType tmp;
    for(i=1;i<n;i++)    //i=1是因为初始时有序区已经有R[0]元素了，插入是从R[1]开始
    {   tmp=R[i];
        j=i-1;
        while(j>=0&&tmp.key<R[j].key)    //找R[i]的插入位置
        {   R[j+1]=R[j];    //将关键字大于R[i].key的记录后移
            j--;
        }
        R[j+1]=tmp;     //在j+1处插入R[i]
    }
}
//改进算法————增加哨兵(R[0]充当哨兵)
void insertSort(SqList &L,int n)
{   int i,j;
    for(i=2;i<=n;i++)   //i=2是因为0号位置是监视哨，1号先插入元素，从2号元素插入时开始比较
    {   if(L[i-1].key>L[i].key) //若前一位置比后一位置小则不用移动，反之要移动
        {   L[0]=L[i];     //复制为哨兵
            for(j=i-1;L[0].key<L[j].key;j--) L[j+1]=L[j];   //记录后移
            L[j+1]=L[0];    //插入到正确位置
        }
}
```

### 折半插入排序

```C
void BinInsertSort(RecType R[],int n)
{   int i,j,low,high,mid;
    RecType tmp;
    for(i=1;i<=n;i++)
    {   if(R[i].key<R[i-1].key)     //若无序区第一个元素>有序区最后一个元素
        {   tmp=R[i];
            low=0;high=i-1;     //low和high分别在有序区的第一个位置和最后一个位置
            while(low<=high)    //在R[low..high]中查找插入位置
            {   mid=(low+high)/2;
                if(tmp.key<R[mid].key) high=mid-1;  //在左区间查找
                else low=mid+1;     //在右区间查找
            }
            //循环结束，high+1为插入位置，接下来该移动元素+插入了
            for(j=i-1;j>=high+1;j--) R[j+1]=R[j];   //元素一个个后移
            R[high+1]=tmp;  //插入
        }
    }
}
```

### 希尔排序

```C
void ShellSort(RecType R[],int n)
{   int i,j,d;
    RecType tmp;
    d=n/2;  //增量置初值（比如若表长为10，则初始增量为5）
    while(d>0)
    {   for(i=d;i<n;i++)    //对所有组采用直接插入排序
        {   tmp=R[i];
            j=i-d;
            while(j>=0&&tmp.key<R[j].key)
            {   R[j+d]=R[j];
                j=j-d;
            }
            R[j+d]=tmp;
        }
        d=d/2;  //减小增量
    }
}
//d=5
//i=5,tmp=R[5],j=0,因为R[5]<R[0],R[5]=R[0],j=0- R[j+5]=R[5]


```

### 冒泡排序

```C
//基础算法
void BubbleSort(RecType R[],int n)
{   int i,j;
    for(i=0;i<n-1;i++)  //每次选出最小的浮到最前面，总共需要n-1趟
    {   for(j=n-1;j>i;j--)      //每一趟比较n-1-(i+1)=n-i次
            if(R[j].key<R[j-1].key) swap(R[j],R[j-1]);
    }
}
//改进算法
/* 有些情况下，在第i趟(i<n-1)时已排好序了，就不需要再执行后面几趟的比较。
   当某一趟比较时不出现任何元素交换，说明剩下的元素都已经是有序了的*/
void BubbleSort(RecType R[],int n)
{   int i,j,flag;       //通过flag的值判断是否出现元素交换
    for(i=0;i<n-1;i++)  //每次选出最小的浮到最前面，总共需要n-1趟
    {   flag=0;     //一趟前还没开始交换flag=0
        for(j=n-1;j>i;j--)      //每一趟比较n-1-(i+1)=n-i次
            if(R[j].key<R[j-1].key)
            {   swap(R[j],R[j-1]);
                flag=1;     //若出现交换则flag=1
            }
        if(flag==0) return;     //flag=0说明没有交换过，则排序已完成
    }
}
```

### 选择排序

```C
void QuickSort(RecType R[],int s,int t)     //对R[s..t]的元素进行快速排序
{   int i;
    if(s<t)     //重复直至每部分只有一个元素为止
    {   i=partition(R,s,t);
        QuickSort(R,s,i-1);     //对左区间递归
        QuickSort(R,i+1,t);     //对右区间递归
    }
}
int partition(RecType R[],int s,int n)  //一趟划分
{   int i=s,j=t;    //i和j的初值分别在表的头和尾
    RecType tmp=R[i];   //以R[i]为基准
    while(i<j)      //从两端扫描
    {   while(j>i&&R[j].key>=tmp.key) j--;  //从右向左扫描，找一个小于tmp.key的R[j]
        R[i]=R[j];  //找到这样的R[j]就放入R[i]中
        while(i<j&&R[i].key<=tmp.key) i++;  //从左向右扫描，找一个大于tmp.key的R[i]
        R[j]=R[i];  //找到这样的R[i]就放入R[j]中
    }
    R[i]=tmp;
    return i;
}
```

### 简单选择排序

```C
void SelectSort(RecType R[],int n)
{   int i,j,k;
    for(i=0;i<n-1;i++)  //排序共有n-1趟
    {   k=i;
        for(j=i+1;j<n;j++)      //在当前无序区R[i..n-1]中选key最小的R[k]，每一趟比较需进行n-i+-1次
            if(R[j].key<R[k].key) k=j;  //k记下当前找到的最小关键字所在的位置
        if(k!=i) swap(R[i],R[k]);   //如果k没有发生变化，则说明第i个位置上的值就是最小值，后面没有比它还小的了
    }
}
```

### 堆排序

----

看下面的题

## 练手题

### [:fire: 215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

#### **题意**

给定整数数组 `nums` 和整数 `k`，请返回数组中第 `k` 个最大的元素。

请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。

你必须设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

**示例 1:**

```
输入: [3,2,1,5,6,4], k = 2
输出: 5
```

**示例 2:**

```
输入: [3,2,3,1,2,4,5,5,6], k = 4
输出: 4
```

**提示：**

- `1 <= k <= nums.length <= 105`
- `-104 <= nums[i] <= 104`

#### 参考

1. [《算法不好玩》专题六：快速排序 ](https://space.bilibili.com/236935093/channel/collectiondetail?sid=378477)
2. [wei神](https://leetcode.cn/problems/kth-largest-element-in-an-array/solutions/19607/partitionfen-er-zhi-zhi-you-xian-dui-lie-java-dai-)
3. [面试官最喜爱的TopK问题算法详解](https://zhuanlan.zhihu.com/p/76734219)
4. [落落落洛克](https://leetcode.cn/problems/kth-largest-element-in-an-array/solutions/836425/xie-gei-qian-duan-tong-xue-de-ti-jie-yi-kt5p2) 堆排序

#### topK问题优化过程

- 全局排序：对整个数组进行排序得到第K大的元素，时间复杂度是sort()的时间复杂度O(nlogn)

- 局部排序：只要能排序前K个就行，用插入排序或选择排序，时间复杂度O(n*k)

- 堆排序：构建一个大小为n的大根堆，循环k次，每次将堆顶最大元素下沉然后重新调整堆。时间复杂度O(n+klogn) -->渐进=O(nlogn)，会更改原数组。

- 优先级队列：只需维护一个大小为 k 的小根堆，每次将堆顶最小元素pop出去，最后堆中就是出现频次前k高的元素，堆顶就是出现频次第k高的元素。时间复杂度O(nlogk)，k很小的时候就相当于O(n)，另外有个优点是不会更改原数组

- 二路快排或三路快排：

    - 最好情况下为O(N)：尽管一次partiton()的时间复杂度就是O(n)，但每轮范围砍半，所以总时间是个等比数列：n + n/2 + n/4 +... 根据等比数列求和公式，为 2n。
    - 最坏情况下，每次取的pivot都位于数组的两端，时间复杂度退化为 O(n^2^ )。但由于我们在每次递归都会随机选取pivot，故出现最坏情况的概率很低。
    - 平均情况下，时间复杂度为 O(N)。


#### 法一

==:star: **核心思路： 二路快排  **:star:==

![image-20240218132259321](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202402181322391.png)

```c++
class Solution {
public:
    int partition(vector<int>& nums, int left, int right) {
        // 返回 基准元素所在下标 

        // 将区间划分为<=pivot和>=pivot的两部分
        // 要生成的随机下标的范围在left~right之间.  rand() % n: 生成0~n-1范围内的随机数
        int randomIndex = left + rand() % (right - left + 1);
        //        rand() % (right - left + 1):生成        0 ~        (right - left)的随机数
        // left + rand() % (right - left + 1):生成 left + 0 ~ left + (right - left)的随机数
        swap(nums[left], nums[randomIndex]);
        int pivot = nums[left];

        int le = left + 1; // le: 小于等于
        int ge = right;    // ge: 大于等于

        while (true) {
            // 因为循环里面有break条件, 因此可以直接用while (true)
            while (le <= ge && nums[le] < pivot) {
                le++;
            } 
            while (le <= ge && nums[ge] > pivot) {
                ge--;
            } 
            // 此时le和ge分别指向>=pivot和<=pivot的值
            if (ge <= le) break;
            // 没有这句if行不行呢？不行！因为若此时 ge（指向<pivot的值） < le （指向>pivot的值）
            // 继续往下走swap, 则会变成 ge（指向>pivot的值） < le （指向<pivot的值）, 显然不行
            swap(nums[le++], nums[ge--]);
        }
        // 交换, 让基准元素位于两区间的分割位置
        swap(nums[left], nums[ge]);
        return ge;
    }
    int findKthLargest(vector<int>& nums, int k) {
        srand((unsigned)time(nullptr));
        int targetIndex = nums.size() - k;
        // 第1大在n-1, 第k大就在n-k
        int left = 0;
        int right = nums.size() - 1;
        while (true) { //因为一定能找到第k大的元素
            int pivotIndex = partition(nums, left, right);
            // 逐步缩小搜索区间继续划分(类二分)
            if (pivotIndex < targetIndex) {
                left = pivotIndex + 1;
            } else if (pivotIndex > targetIndex) {
                right = pivotIndex - 1;
            } else {
                return nums[pivotIndex];
            }
        }
        return 0;
    }
};
```

###### **复杂度分析**

- 时间复杂度：平均情况下为O(N)。 

- 空间复杂度：O(1) 

#### 法二

==:star: **核心思路：优先级队列（小根堆）   **:star:==  但是一般面试的时候会要求手写堆排序而不能用优先级队列

```c++
int findKthLargest(vector<int>& nums, int k) {
    priority_queue<int, vector<int>, greater<int>> pri_que;//小根堆
    //用堆扫描数组，扫描完之后堆顶元素就是第k大的元素
    for (auto& val : nums) {
        pri_que.push(val);
        if (pri_que.size() > k) pri_que.pop();
    }
    return pri_que.top();
}
```

##### **复杂度分析**

- 时间复杂度：O(nlog⁡k)，边扫描O(n)边建堆和删除O(logk)，总的就是O(nlogk)
- 空间复杂度：O(k)

#### 法三

==:star: **核心思路：堆排序（手写大根堆）   **:star:==    [动图演示](https://vdn6.vzuu.com/SD/3bb38dfe-236a-11eb-8039-a6caf32b14c9.mp4?pkey=AAUbsQMVw-VtgAYGH8WImV7ftlackJRoxU6nRszJLIIDzuUtOIUtK1EijGgLlrjmGk69Mnq9VbhUguUzJi-nMtD3&c=avc.0.0&f=mp4&pu=078babd7&bu=078babd7&expiration=1711339727&v=ks6)

**:small_red_triangle_down:  steps: **

1.  【建堆】从最后一个非叶子节点（i = heapSize / 2 - 1）开始，自底向上 通过下滤操作 将给定无序序列构造成大根堆（自底向上构建只需O(n)）
2.  【堆排序】循环，每循环一次就将第 i 大的元素沉到数组尾部（堆尾部）
    1.  swap(堆顶元素, 堆尾元素)
    2.  堆大小-1，重新调整堆为大根堆(下滤, 父节点下沉)

##### 代码

###### 有注释版


```c++
class Solution {
public:
    // 建大根堆
    void buildMaxHeap(vector<int>& nums, int heapSize) {
        // 从最后一个非叶子节点(索引为heapSize / 2 - 1)开始调整
        for (int i = heapSize / 2 - 1; i >= 0; --i) {
            // 调整无序序列中[i, heapSize)表示的堆为大根堆
            adjustMaxHeap(nums, i, heapSize);
        }
    }
    // 通过下滤操作调整[start, end)为大根堆
    void adjustMaxHeap(vector<int>& nums, int start, int end) {
        // start始终表示根的下标，parent表示三者中最大的结点的位置
        // 调整前根的值是nums[start]，
        int parent = start;
        int Lnode = 2 * start + 1;
        int Rnode = 2 * start + 2;
        // 将parent赋值为start、Lnode、Rnode三者中结点值最大的那个
        // 为什么需要L/Rnode < end才可以？？？要防止越界，有可能start不存在左右子
        if (Lnode < end && nums[parent] < nums[Lnode]) {
            parent = Lnode;
        }
        if (Rnode < end && nums[parent] < nums[Rnode]) { 
            parent = Rnode;
        }
        // 找到之前的根的值（nums[start]）被换到左子还是右子
        // 它被换到哪，哪棵子树就需要重新调整
        // parent更新了, 说明三者中最大的结点在左右子，要重新调整堆
        if (parent != start) {
            // 用parent位置的值代替原来的根start的值, 然后调整start所在的子树
            swap(nums[start], nums[parent]);
            // 值交换后start仍表示根的位置，
            // parent则表示三者中最大的那个左/右子的位置，也表示原来根的值现在所处的位置
            adjustMaxHeap(nums, parent, end);
        }
    }
    // 堆排序
    int findKthLargest(vector<int>& nums, int k) {
        // 1. 建大根堆, 【时间复杂度: 自底向上 下滤 建堆, O(n)】
        buildMaxHeap(nums, nums.size());
        int heapSize = nums.size();
        // 2. 堆排序, 【时间复杂度: 循环k次, 调整堆的时间复杂度为O(logn), 总共是O(klogn)】
        // 每次将堆顶最大元素下沉, 然后重新调整堆, 下沉k次之后        
        // 第1次循环, i = nums.size() - 1, 第1大的元素nums[0]下沉到nums.size() - 1
        // 第k次循环, i = nums.size() - k, 第k大的元素nums[0]下沉到nums.size() - k
        for (int i = nums.size() - 1; i >= nums.size() - k; --i) {  
            // 堆中只剩一个元素时就不需要再下沉了, --heapSize后堆中不剩元素了也就不需要继续调整堆了
            if (heapSize - 1 <= 0) break;
            // 不加if就会报错 
            swap(nums[i], nums[0]);  
            // --heapSize因为下沉后的元素不参与到大顶堆的调整
            adjustMaxHeap(nums, 0, --heapSize);
        }
        return nums[nums.size() - k]; 

        // // 也可以不用走最后一次循环，那么循环结束时，第k大的元素nums[0]还没有下沉，直接返回
        // for (int i = nums.size() - 1; i > nums.size() - k; --i) {
        //     swap(nums[i], nums[0]);  
        //     adjustMaxHeap(nums, 0, --heapSize);
        // }
        // return nums[0];
    }
};
```

###### 精简注释版

```c++
class Solution {
public:
    // 建大根堆
    void buildMaxHeap(vector<int>& nums, int heapSize) {
        for (int i = heapSize / 2 - 1; i >= 0; --i) {
            adjustMaxHeap(nums, i, heapSize);
        }
    }
    // 通过下滤操作调整[start, end)为大根堆
    void adjustMaxHeap(vector<int>& nums, int start, int end) {
        int parent = start;
        int Lnode = 2 * start + 1;
        int Rnode = 2 * start + 2;
        if (Lnode < end && nums[parent] < nums[Lnode]) {
            parent = Lnode;
        }
        if (Rnode < end && nums[parent] < nums[Rnode]) { 
            parent = Rnode;
        }
        if (parent != start) {
            swap(nums[start], nums[parent]);
            adjustMaxHeap(nums, parent, end);
        }
    }
    // 堆排序
    int findKthLargest(vector<int>& nums, int k) {
        // 1. 建大根堆
        buildMaxHeap(nums, nums.size());
        int heapSize = nums.size();
        // 2. 堆排序
        for (int i = nums.size() - 1; i >= nums.size() - k; --i) {
            if (heapSize - 1 <= 0) break;
            swap(nums[i], nums[0]);  
            adjustMaxHeap(nums, 0, --heapSize);
        }
        return nums[nums.size() - k];
        // 或者写成下面的更好，无需条件判断
        // for (int i = nums.size() - 1; i > nums.size() - k; --i) {
        //     swap(nums[i], nums[0]);  
        //     adjustMaxHeap(nums, 0, --heapSize);
        // }
        // return nums[0];
    }
}
```

##### **复杂度分析**

- 时间复杂度：O(nlog⁡n)，建堆的时间代价是 O(n)，k次调整堆的时间复杂度为O(klogn)，因为 k<n，故渐进时间复杂为 O(n+klog⁡n)=O(nlog⁡n)。

- 空间复杂度：O(n)

### :fire:[75. 颜色分类](https://leetcode.cn/problems/sort-colors/)

#### 题意

给定一个包含红色、白色和蓝色、共 `n` 个元素的数组 `nums` ，**[原地](https://baike.baidu.com/item/原地算法)**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

我们使用整数 `0`、 `1` 和 `2` 分别表示红色、白色和蓝色。

必须在不使用库内置的 sort 函数的情况下解决这个问题。

**示例 1：**

```
输入：nums = [2,0,2,1,1,0]
输出：[0,0,1,1,2,2]
```

**示例 2：**

```
输入：nums = [2,0,1]
输出：[0,1,2]
```

**提示：**

- `n == nums.length`
- `1 <= n <= 300`
- `nums[i]` 为 `0`、`1` 或 `2`

**进阶：**

- 你能想出一个仅使用常数空间的一趟扫描算法吗？

#### 思路

==:star: **核心思路： 三路快排 partition  **:star:==

**:key:  key**

- 和前面的三路快排 partition不同的是，本题中数组只有三种元素，以1为pivot的话，0就<pivot，2>pivot。因此只需一趟三路快排 partition就能排好序。

#### 代码

##### 第一种写法

```c++
void sortColors(vector<int>& nums) {
    // 左,中,右区间分别用: [0,left], (left, i), (right,n-1]表示
    int left = -1; 				 // 指向左区间末位
    int right = nums.size() - 1; // 指向右区间首位元素的前一个位置
    int i = 0;					 // 指向中间区间末位的下一个位置（当前遍历位置）
    while (i <= right) {
        // i==right时，由于right不属于右区间，因此不知道right是多少，还需要一次循环
        if (nums[i] == 0) {
            swap(nums[i++], nums[++left]);
        } else if (nums[i] == 1) {
            i++;
        } else {
            swap(nums[i], nums[right--]);
        }
    }
}
```

##### 第二种写法

```c++
void sortColors(vector<int>& nums) {
    // 左,中,右区间分别用: [0,left], (left, i), [right,n-1]表示
    int left = -1; 			 // 指向左区间末位
    int right = nums.size(); // 指向右区间首位元素
    int i = 0;		    	 // 指向中间区间末位的下一个位置（当前遍历位置）
    while (i < right) {
        // i==right时，由于right属于右区间，因此此时right是2，无需再确定i的划分区间
        if (nums[i] == 0) {
            swap(nums[i++], nums[++left]);
        } else if (nums[i] == 1) {
            i++;
        } else {
            swap(nums[i], nums[--right]);
        }
    }
}
```

> 其实写出两种写法只是为了说明，left 初始化为 -1 还是0 , right 初始化为 n-1 还是 n，都没关系都可以，只要你对应的处理逻辑写对就好。（你甚至可以自由组合写出四种写法，只要你愿意🤪）

#### 复杂度分析

- 时间复杂度：O(n)  

- 空间复杂度：O(1)

### :fire:[347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)

#### **题意**

给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 **任意顺序** 返回答案。

**示例 1:**

```
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
```

**示例 2:**

```
输入: nums = [1], k = 1
输出: [1]
```

**提示：**

- `1 <= nums.length <= 105`
- `k` 的取值范围是 `[1, 数组中不相同的元素的个数]`
- 题目数据保证答案唯一，换句话说，数组中前 `k` 个高频元素的集合是唯一的

**进阶：**你所设计算法的时间复杂度 **必须** 优于 O(nlogn) ，其中 n 是数组大小。

#### 法一

==:star: **核心思路：优先级队列（小根堆）  **:star:==

**:key:  key：**

- 用小根堆还是大根堆？
    - 小根堆. (时间复杂度:遍历O(n), 堆操作是O(logk), 总的是O(nlogk))
    - 如果用大根堆，那么每push一个元素就会pop一个堆顶最大元素
    - 因此我们需要小根堆留下频次最大的前k个元素

- 模板声明：`priority_queue<Type, Container, Functional>`

    - Type要存放的数据类型
    - Container保存数据的容器，默认是vector<int>
    - Functional元素比较方式(谓词)，当数据类型是基本数据类型时，默认是大顶堆less<>，若不是基本数据类型时则需要自定义比较方式。
- 几个接口
    - push() 或emplace() is better
    - top()，取堆顶元素 

**:small_red_triangle_down:  steps: **

1.  统计元素出现频率
2.  定义一个用优先队列实现的小根堆
3.  用固定大小的小根堆扫描所有元素
    - 元素入队
    - 如果堆大小超过k则弹出最小元素
4.  不断pop得到前K个频次最高的元素

##### 代码

```c++
class compare {
public:
    bool operator() (const pair<int, int>& a, const pair<int, int>& b) {
        return a.second > b.second; // priority_queue的比较器比较特殊
    }
};
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int, int> freq; 
        for (int& val : nums) {
            freq[val]++;
        } 
        priority_queue<pair<int, int>, vector<pair<int, int>>, compare> pri_que; 
        for (auto& p : freq) {
            pri_que.emplace(p);
            if (pri_que.size() > k) {
                pri_que.pop();
            }
        }
        vector<int> res(k);
        while (k > 0) {
            res[--k] = pri_que.top().first;
            pri_que.pop();
        }
        return res;
    }
};
```

##### 复杂度分析

- 时间复杂度：O(nlogk)。遍历元素O(n)的同时进行堆操作O(log⁡k)

- 空间复杂度：O(n)。哈希map的空间为O(n)，堆所占空间为O(k)。

#### 法二

==:star: **核心思路：堆排序（手写大根堆）  **:star:==

  

#### 法三

==:star: **核心思路：二路快排   **:star:==



```c++
#include <iostream>
#include <vector>
#include <unordered_map>
#include <algorithm>

using namespace std;

// 定义哈希表中的键值对，其中first表示数字，second表示该数字的出现次数
typedef pair<int, int> Pair;

// 辅助函数，用于交换两个Pair对象
void swapPair(Pair& a, Pair& b) {
    Pair temp = a;
    a = b;
    b = temp;
}

// 定义二路快排的划分函数，根据元素出现次数进行划分
int partition(vector<Pair>& counts, int low, int high) {
    // 选取中间元素作为pivot
    Pair pivot = counts[high];
    // i指向小于pivot的元素的最后一个位置
    int i = low - 1;

    // 从low到high-1遍历元素
    for (int j = low; j <= high - 1; j++) {
        // 如果当前元素的出现次数大于等于pivot的出现次数，交换元素位置
        if (counts[j].second >= pivot.second) {
            i++;
            swapPair(counts[i], counts[j]);
        }
    }

    // 将pivot插入到适当的位置
    swapPair(counts[i + 1], counts[high]);
    return i + 1;
}

// 定义二路快排函数，根据元素出现次数进行降序排序
void quickSort(vector<Pair>& counts, int low, int high) {
    if (low < high) {
        // 划分数组，并获取划分点的位置
        int pi = partition(counts, low, high); 
        // 递归对划分的两部分进行排序
        quickSort(counts, low, pi - 1);
        quickSort(counts, pi + 1, high);
    }
}

// 主函数，返回频率前k高的元素
vector<int> topKFrequent(vector<int>& nums, int k) {
    // 使用哈希表记录每个数字出现的次数
    unordered_map<int, int> freq;
    for (int num : nums) {
        freq[num]++;
    }

    // 将哈希表中的键值对存入vector中
    vector<pair<int, int>> counts;
    for (auto& p : freq) {
        counts.emplace_back(p);
    }

    // 对vector中的键值对按照出现次数降序排序
    quickSort(counts, 0, counts.size() - 1);

    // 提取出现次数前k高的数字
    vector<int> result;
    for (int i = 0; i < k; i++) {
        result.emplace_back(counts[i].first);
    } 
    return result;
}

int main() {
    // 示例输入
    vector<int> nums = {1, 1, 1, 2, 2, 3};
    int k = 2;

    // 调用函数获取频率前k高的元素
    vector<int> result = topKFrequent(nums, k);

    // 输出结果
    cout << "Frequency top " << k << " elements: ";
    for (int num : result) {
        cout << num << " ";
    }
    cout << endl;

    return 0;
}
```

