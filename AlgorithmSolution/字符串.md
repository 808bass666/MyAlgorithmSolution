## 💛总结题型

数组填充：剑指Offer 05.替换空格、

反转字符串：lc541、lc557、lc151、剑指58-II

KMP：lc28，lc459

> 之后再补上。

## :fire:[394. 字符串解码](https://leetcode.cn/problems/decode-string/)

### 题意

给定一个经过编码的字符串，返回它解码后的字符串。

编码规则为: `k[encoded_string]`，表示其中方括号内部的 `encoded_string` 正好重复 `k` 次。注意 `k` 保证为正整数。

你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。

此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 `k` ，例如不会出现像 `3a` 或 `2[4]` 的输入。 

**示例 1：**

```
输入：s = "3[a]2[bc]"
输出："aaabcbc"
```

**示例 2：**

```
输入：s = "3[a2[c]]"
输出："accaccacc"
```

**示例 3：**

```
输入：s = "2[abc]3[cd]ef"
输出："abcabccdcdcdef"
```

**示例 4：**

```
输入：s = "abc3[cd]xyz"
输出："abccdcdcdxyz"
```

**提示：**

- `1 <= s.length <= 30`
- `s` 由小写英文字母、数字和方括号 `'[]'` 组成
- `s` 保证是一个 **有效** 的输入。
- `s` 中所有整数的取值范围为 `[1, 300]` 

### 参考题解

1. [YouLookDeliciousC](https://leetcode.cn/problems/decode-string/solutions/6274/ti-jie-czhan-by-youlookdeliciousc)

### 思路

==:star: **核心思路： 双栈  **:star:==

**:key:  key：**

- 用两个栈. 将数字栈栈顶弹出, 这样就知道是将多少个encoded_string +=到res
- 遍历
    1. 遇到数字, 计算num, 之后在遇到[时将其存入numSt
    2. 遇到字符, 将其尾加到res (当前正在处理的encoded_string)
    3. 遇到[ , 说明要开始一个新的encoded_string了. 将前面的数字num存入numSt, 并把num置0; 把把前面的一部分字符串res存到stringSt, 将res置空
    4. 遇到] , 说明要解一个encoded_string了. pop numSt, 将res尾加到stringSt.top(),times次, 然后弹出stringSt栈顶将其赋给res


**:x: careless | ignore :**

- 又把`'a' <= ch && ch <= 'z'`写成`'a' <= ch <= 'z'`了（扶额..）

### 代码

```c++
class Solution {
public:
    string decodeString(string s) {
        // 用两个栈. 将数字栈栈顶弹出, 这样就知道是将多少个encoded_string +=到res
        // 每遇到一个'[' , 就说明要开始一个新的encoded_string了
        // 每遇到一个']', 就说明要解一个encoded_string了 
        stack<string> stringSt;
        stack<int> numSt;

        string res = ""; // 始终表示当前正在处理的encoded_string
        int num = 0;
          
        for (auto& ch : s) {
            // 1.遇到数字, 计算num, 之后在遇到[时将其存入numSt
            // 2.遇到字符, 将其尾加到res (当前正在处理的encoded_string)
            // 3.遇到[ , 说明要开始一个新的encoded_string了. 将前面的数字num存入numSt, 并把num置0; 把前面的一部分字符串res存到stringSt, 将res置空
            // 4.遇到] ,  说明要解一个encoded_string了. pop numSt, 将res尾加到stringSt.top(),times次, 然后弹出stringSt栈顶将其赋给res
            if (isdigit(ch)) {
                num = num * 10 + ch - '0'; 
            } else if ('a' <= ch && ch <= 'z') {
                // 又写成'a' <= ch <= 'z'了!!
                res += ch;
            } else if (ch == '[') {
                numSt.push(num);    num = 0;
                stringSt.push(res); res = "";
            } else {
                int times = numSt.top(); numSt.pop();
                while (times--) {
                    stringSt.top() += res;
                }
                res = stringSt.top(); stringSt.pop();
                //之后若还是字母，就会直接加到res之后，因为它们是同一级的运算
                //若是左括号，res会被压入strs栈，作为上一层的运算
            }
        }
        return res;
    }
};
```

### 复杂度分析

记解码后得出的字符串长度为 S

- 时间复杂度：O(S)  。除了遍历一次原字符串 s ，我们还需要将解码后的字符串中的每个字符都入栈，并最终拼接进答案中，故渐进时间复杂度为 O(S+∣s∣)，即 O(S) 。 
- 空间复杂度：记解码后得出的字符串长度为 S，这里用栈维护 TOKEN，栈的总大小最终与 S 相同，故渐进空间复杂度为 O(S)。

## [lc541. 反转字符串 II](https://leetcode.cn/problems/reverse-string-ii/)

### 题意

给定一个字符串 `s` 和一个整数 `k`，从字符串开头算起，每计数至 `2k` 个字符，就反转这 `2k` 字符中的前 `k` 个字符。

- 如果剩余字符少于 `k` 个，则将剩余字符全部反转。
- 如果剩余字符小于 `2k` 但大于或等于 `k` 个，则反转前 `k` 个字符，其余字符保持原样。

**示例 1：**

```cpp
输入：s = "abcdefg", k = 2
输出："bacdfeg"
```

### 思路

**:x: careless | ignore :**

- end()是指向最后一个元素的下一个位置
- 一般自带的库函数区间都是左闭右开

### 代码

##### (1) 自己实现reverse

```c++
void reverse(string& s, int l, int r) {
    for (; l < r; ++l, --r) swap(s[l], s[r]);
}
string reverseStr(string s, int k) {
    int l = 0, r = 0, len = s.size();
    while (l < len) {
        //计算[l,len-1]之间的元素数是否还够k个
        if (len - l <= k) { //不够，剩下的全反转
            reverse(s, l, len - 1);
            //reverse()也可以写成:
            //r = len - 1;
            //while (l < r) swap(s[l++], s[r--]);
            break;
        }
        //够，反转前k个元素
        int tmp = l;
        reverse(s, l, l + k - 1);
        //reverse()也可以写成:
        //r = l + k - 1;
        //while (l < r) swap(s[l++], s[r--]);
        l = tmp + 2 * k; 
    }
    return s;
}
```

##### (2) 直接调用库函数

```c++
string reverseStr(string s, int k) {
    for (int i = 0; i < s.size(); i += 2*k) {
        //如果[i,s.size())之间的元素个数不够k个，全反转了
        if (s.size() - i <= k) reverse(s.begin() + i, s.end());
        //够，只反转前k个
        else reverse(s.begin() + i, s.begin() + k + i);
    }
    // 或写成：
    for (auto iter = s.begin(); iter < s.end(); iter += 2 * k) 
        reverse(iter, min(s.end(), iter + k));
    return s;
}
```

### 复杂度分析

- 时间复杂度：O(n)  

- 空间复杂度：O(1)

## **[lc557. 反转字符串中的单词 III](https://leetcode.cn/problems/reverse-words-in-a-string-iii/)**

### **题意**

给定一个字符串 `s` ，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。

- `s` 不包含任何开头或结尾空格。
- `s` 里 **至少** 有一个词。
- `s` 中的所有单词都用一个空格隔开。

**示例 1：**

```cpp
输入：s = "Let's take LeetCode contest"
输出："s'teL ekat edoCteeL tsetnoc"
```

**示例 2:**

```cpp
输入： s = "Mr Ding"
输出："rM gniD"
```

### 思路

easy但是一定要注意下标越界的问题！还有时间复杂度的分析。

### 代码

```c++
string reverseWords(string s) {
    int l = 0, r = 0;
    while (l < s.size()) {
        //注意下标越界的问题！
        while (r < s.size() && s[r] != ' ') ++r;
        int start = r + 1;
        reverse(s.begin() + l, s.begin() + r);//反转单词
        l = start;
        r = start;
    }
    return s;
}
```

### 复杂度分析

- 时间复杂度：O(n)  

    最外层循环遍历一次整个数组是O(n)，内部reverse的时间复杂度是O(最长单词长度)，因为只是翻转一个固定长度的字符串，不会随着n的增大而增大，因此总时间复杂度就是O(n)

- 空间复杂度：O(1)

## [剑指Offer 05.替换空格](https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/description/)

### **题意**

:  请实现一个函数，把字符串 s 中的每个空格替换成"%20"。

```c++
示例 1： 输入：s = "We are happy."
输出："We%20are%20happy."
```

### 思路

==:star: **核心思路：扩容 + 双指针 + 倒序遍历**:star:==

**:question:   problems:** 

1. 为什么要扩容?
2. 为什么要倒序遍历替换？

:heavy_check_mark:  **answer:** 

1. ==很多【数组填充】的问题，都可以先给数组扩容到填充后的大小，然后再从后向前进行操作。==这么做有两个好处：

    - 不用申请新数组。
    - 从后向前填充元素，避免了从前向后填充元素时，每次添加元素都要将添加元素之后的所有元素向后移动的问题。

2. ​    如果是从前往后遍历，那么每遍历到一个' '就需要将其之后所有的元素全部后移以添加元素，时间复杂度O(n^2^)，而且也不好用双指针；

    ​    但如果从后往前遍历，那么每遍历到一个' '不需要后移其之后所有元素，直接用指向扩容数组末尾的 r 给扩容后的位置赋值。

**:small_red_triangle_down: steps: **

1.  先扩容到填充后的大小
2.  再倒序遍历替换 ( l 从后往前遍历--遍历旧数组，r 根据 l 赋值--遍历扩容后的数组)
    1. l 遇到非' '字符就将其拷贝到right的位置 (拷贝后移)
    2. l 遇到' '则right从后往前给三个位置赋值为'0''2''%'

### 代码

```c++
string replaceSpace(string s) {
	int oldlen = s.size(), cnt = 0;
    // 1. 扩容到填充后的大小
    for (char c : s) {
		if (c == ' ') ++cnt;
    }
    s.resize(oldlen + cnt * 2);
    // 2. 倒序遍历替换
    int l = oldlen - 1, r = s.size() - 1;
    while (l < r) { 
        if (s[l] != ' ') s[r--] = s[l--];//拷贝后移
        else { //替换
            --l;
            s[r--] = '0';
            s[r--] = '2'; 
            s[r--] = '%'; 
        }    
    }
    return s;
}
```

### 复杂度分析

- 时间复杂度：O(n) 

    因为l和r同时左移，它俩的遍历同时进行，而非嵌套进行

- 空间复杂度：O(1)

    由于是原地扩展 s 长度，因此使用 O(1) 额外空间。

## [lc151. 反转字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string/)

### **题意**

: 已知 `s` 中每个 单词 都至少由一个空格分隔且`s` 中 至少存在一个单词，返回单词**顺序颠倒**且单词间用**单个空格**连接后的字符串。

**注意：**输入字符串 `s`中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中不应包含任何额外的空格。

**进阶：**如果字符串在你使用的编程语言中是一种可变数据类型，请尝试使用 `O(1)` 额外空间复杂度的 **原地** 解法。

```c++
输入：s = "  hello world  "
输出："world hello"
```

### 思路

==:star: **核心思路： 快慢指针+ 两次反转    **:star:==

**:key:  key：**

- 此题关键是移除空格的逻辑！注意！==单词间添加空格的逻辑一定不能写在拷贝覆盖的逻辑之后！否则很麻烦！==（卡哥题解中有写这种，很麻烦）

### 版本1

**:small_red_triangle_down: steps: **

1. 移除多余空格:star:

    - fast遇到空格就continue跳过

    - 遇到非空格字符
        - 先要添一个空格，即用空格覆盖 刚拷贝覆盖到前面的 单词末尾的下一位置(即slow指向的位置)，
        - 再开始下一单词的拷贝覆盖

2. 反转整个字符串

3. 反转单词

**:x: careless | ignore :**

1.  去除多余空格后要记得`s.resize()`

#### 代码

```c++
string reverseWords(string s) {
    // 移除多余空格
    int slow = 0, fast = 0;
    for (; fast < s.size(); ++fast) {//fast遇到空格就continue跳过
        if (s[fast] != ' ') {
            //当f遇到非' '字符，先要用空格覆盖 刚拷贝覆盖到前面的 单词末尾的下一位置(即slow指向的位置)，再开始下一单词的拷贝覆盖
            if (slow != 0) s[slow++] = ' ';
            //将单词拷贝覆盖到前面
            while (fast < s.size() && s[fast] != ' ') s[slow++] = s[fast++];
        }
    }
    s.resize(slow);//最后留的一个空格以及后置空格全部咔掉
    // 开始两次反转
    // 先反转整个字符串
    reverse(s.begin(), s.end());
    // 再反转每个单词
    slow = 0, fast = 0;
    while (slow < s.size()) {
        //一定要注意下标越界的问题！
        while (fast < s.size() && s[fast] != ' ') ++fast;
        //退出循环时，要么fast==s.size()了，要么指向空格
        reverse(s.begin() + slow, s.begin() + fast);//反转单词
        slow = (fast != s.size() - 1) ? fast + 1 : fast;//如果r指向空格，s=f+1留一个空格
        fast = slow;//也更新为下一个单词的开头
    }
    return s;
}
```

#### 复杂度分析

- 时间复杂度：O(n)

- 空间复杂度：O(1)

### 版本2

**:small_red_triangle_down: steps: **

1. 反转整个字符串

2. 移除多余空格 同时 反转单词

    - fast遇到空格就continue跳过

    - 遇到非空格字符
        - 先要**添一个空格**，即用空格覆盖 刚拷贝覆盖到前面的 单词末尾的下一位置(即slow指向的位置)

        - 用p遍历单词同时给左边**拷贝覆盖**,fast不动以便之后计算单词长度reverse反转单词

        - 将拷贝过去的**单词反转**

        - 更新往后找单词的指针fast

#### 代码

```c++
string reverseWords(string s) {
    //反转整个字符串
    reverse(s.begin(), s.end());
    int slow= 0;
    for (int fast = 0; fast < s.size(); ++fast) { 
        //遇到空格就continue跳过
        //遇到非空格字符
        if (s[fast] != ' ') {
            if (slow != 0) s[slow++] = ' '; //先要添一个空格
            int p = fast;//用p遍历单词,fast不动以便之后计算单词长度反转单词
            while (p < s.size() && s[p] != ' ') s[slow++] = s[p++]; //拷贝拷贝覆盖
            //p从fast(单词的第一个字母)开始遍历直到该单词的末尾，则单词长度就是p-fast
            //反转单词
            reverse(s.begin() + slow - (p - fast), s.begin() + slow);//该单词首符的位置就是slow-(p-fast)
            fast = p;
        }
    }
    s.erase(s.begin() + slow, s.end());
    //从新数组结尾(slow)到旧数组结尾都不需要了。也可以用substr但是substr还需要计算截取长度
    return s;
}
```

#### 复杂度分析

- 时间复杂度：O(n) . 分析同前面

- 空间复杂度：O(1)



## 剑指Offer58-II.左旋转字符串

### **题意**

: 字符串的左旋转操作是把字符串前面的若干个字符，转移到字符串的尾部。请用函数实现，要求不能申请额外空间，只能在本串上操作。

```c++
示例 1：
    输入: s = "abcdefg", k = 2
    输出:       "cdefgab"
限制：1 <= k < s.length <= 10000
```

### 思路

==:star: **核心思路：（三次reverse ）整体反转 + 局部反转**:star:==

**:small_red_triangle_down: steps: **

1.  先**reverse整个字符串**，将前k个字符（第一坨） 和 后s.size()-k个字符（第二坨） 这两坨交换位置，让这两堆处于正确位置上（至于内部怎么样我们先不管）
2.  再**分别**对这两坨内部**reverse**，变换回原来的排列顺序

**:x: careless | ignore :**

1. 

### 代码

```c++
string reverseLeftWords(string s, int n) {
    //1.先将整个字符串进行反转
    reverse(s.begin(), s.end());
    //2.再分别对这两坨内部reverse，变换回原来的排列顺序
    reverse(s.begin(), s.begin() + s.size() - n);
    reverse(s.begin() + s.size() - n, s.end());
    return s;
}
```

### 复杂度分析

- 时间复杂度：O()

    ​    

- 空间复杂度：O()

## [lc28.找出字符串中第一个匹配项的下标](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/)

### **题意**

:  请在 `haystack` 字符串中找出 `needle` 字符串的第一个匹配项的下标。如果 `needle` 不是 `haystack` 的一部分，则返回 `-1` 。

**提示：**

- `1 <= haystack.length, needle.length <= 10^4`
- `haystack` 和 `needle` 仅由小写英文字符组成

```c++
输入：haystack = "sadbutsad", needle = "sad"
输出：0
解释："sad" 在下标 0 和 6 处匹配。第一个匹配项的下标是 0 
```

### 思路

==:star: **核心思路：KMP **:star:==

参考我的【KMP】专题文章

**:x: careless | ignore :**

1. 总是在粘贴的时候忘记将第一个表达式的第二个初始化的`int`去掉！比如写成` for(int i = 0, int j = 0; ........)`

### 代码

```c++
void getNext(vector<int> &next, const string &s) {
    int n = s.size();
    next[0] = 0;
    for (int prefixEnd = 0, suffixEnd = 1; suffixEnd < n; ++suffixEnd) {
        //如果不匹配则prefixEnd回退
        while (prefixEnd > 0 && s[prefixEnd] != s[suffixEnd]) prefixEnd = next[prefixEnd - 1];
        //退出循环时prefixEnd要么等于最长相等前后缀的长度要么等于0(回退到0了)
        if (s[prefixEnd] == s[suffixEnd]) prefixEnd++;
        //将前缀长度赋给next[suffixEnd]
        next[suffixEnd] = prefixEnd;
    }
}
int strStr(string haystack, string needle) {
    int m = haystack.size(), n = needle.size();
    // 构建next数组
    vector<int> next(n);
    getNext(next, needle);
    // 利用next数组来进行匹配
    for (int i = 0, j = 0; i < m; ++i) { //i指向主串, j指向模式串
        while (j > 0 && haystack[i] != needle[j]) j = next[j - 1];
        if (haystack[i] == needle[j]) ++j;
        if (j == n)return i - n + 1;
    }
    return -1;
}
```

### 复杂度分析

设主串长度为m，模式串长度为n。时间复杂度：O(n+m)；空间复杂度：O(n)

## [lc459. 重复的子字符串](https://leetcode.cn/problems/repeated-substring-pattern/)

### **题意**

:  给定一个非空字符串 `s` ，判断s是否可以通过由它的一个子串重复多次构成。

**示例 1:**

```cpp
输入: s = "aba"
输出: false
```

**示例 2:**

```cpp
输入: s = "abcabcabcabc"
输出: true
解释: 可由子串 "abc" 重复四次构成 (或子串 "abcabc" 重复两次构成)
```

### 法一

#### 思路

==:star: **核心思路：双倍字符串  **:star:==

将两个s连在一起，并去掉首位字符，若里面还出现一个s且这个s不是原来拼接的第二个s的话，就说明是由重复子串组成。（避免在s+s中搜索出原来的s，我们要搜索的是中间拼接出来的、横跨这两个s的s）

#### 代码

```c++
 bool repeatedSubstringPattern(string s) {
        return (s + s).find(s, 1) != s.size();//从下标1开始，在S=s+s的字符串中查找s。find返回查找到的第一个字符位置
         //若find返回s.size()，即拼接后的s+s的第二个s的首元素，则说明在其中找到的s就是s+s中的第二个s，而不是我们想找的跨越了两个s的s，也就是说我们没找到。
 }
/*case
s="aba" 返回3
s="abcabcabcabc" 返回3  */
```

#### 复杂度分析

时间复杂度: O(n); 空间复杂度: O(1)

### 法二

#### 思路

==:star: **核心思路：KMP  **:star:==

**:key:  key：**

- 关键在于第二步求最小重复子串长度！

**:small_red_triangle_down: steps: **

1.  求next数组
2.  求最小重复子串长度(如果s能由求重复子串构成)
3.  若s.size()能被最小重复子串长度整除，则s能由子串重复构成

#### 代码

```c++
class Solution {
public:
    void getNext(vector<int>& next, string& s) {
        // 1.初始化
        next[0] = 0;
        for (int prefixEnd = 0, suffixEnd = 1; suffixEnd < s.size(); ++suffixEnd) {
            // 2.前后缀不匹配的情况--prefixEnd回退
            while (prefixEnd > 0 && s[prefixEnd] != s[suffixEnd]) prefixEnd = next[prefixEnd - 1];
            // 3.前后缀匹配的情况--前缀末位后移，即最长相等前后缀长度+1
            if (s[prefixEnd] == s[suffixEnd]) ++prefixEnd;
            // 4.给next[suffixEnd]赋值
            next[suffixEnd] = prefixEnd;
        }
    }
    bool repeatedSubstringPattern(string s) {
        int n = s.size();
        vector<int> next(n);
        // 1.求next数组
        getNext(next, s);  
        // 2.求最小重复子串长度(如果s能由求重复子串构成)
        // ！！！！！！！！！！！！！
        // 下面的求法是错误的！s="aabaaba"时,next=[0101234],因此0的个数不代表构成s的重复子串的长度！！
        // int i = 0;//i就代表了前面0的个数，也即构成s的重复子串的长度
        // while (i < n && next[i] == 0) ++i;
        // ！！！！！！！！！！！！！
        int sublen = n - next.back();
        // 3.若s.size()能被最小重复子串长度整除，则s能由子串重复构成
        return n % sublen == 0 && next.back() != 0;
    }
};
/*
 "abcabcabcabc"的最后一个元素的next不是n/2!!!而是 9
>000123456789
打印日志：
    for (char c : s) cout << c << " ";
    cout << endl;
    for (int n : next) cout << n << " ";
    cout << endl;
*/
```



#### 复杂度分析

- 时间复杂度：O(n)，其中 n是字符串 s的长度。
- 空间复杂度：O(n)。



## [686. 重复叠加字符串匹配](https://leetcode.cn/problems/repeated-string-match/)

### 题意

给定两个字符串 `a` 和 `b`，寻找重复叠加字符串 `a` 的最小次数，使得字符串 `b` 成为叠加后的字符串 `a` 的子串，如果不存在则返回 `-1`。

**注意：**字符串 `"abc"` 重复叠加 0 次是 `""`，重复叠加 1 次是 `"abc"`，重复叠加 2 次是 `"abcabc"`。

**示例 1：**

```
输入：a = "abcd", b = "cdabcdab"
输出：3
解释：a 重复叠加三遍后为 "abcdabcdabcd", 此时 b 是其子串。
```

**示例 2：**

```
输入：a = "a", b = "aa"
输出：2
```

**示例 3：**

```
输入：a = "a", b = "a"
输出：1
```

**示例 4：**

```
输入：a = "abc", b = "wxyz"
输出：-1
```

**提示：**

- `1 <= a.length <= 104`
- `1 <= b.length <= 104`
- `a` 和 `b` 由小写英文字母组成

### 参考题解

1. [官解。但是最后的return属实给我整无语了，明明没必要写成那样](https://leetcode.cn/problems/repeated-string-match/solutions/1170235/zhong-fu-die-jia-zi-fu-chuan-pi-pei-by-l-vnye)

### 思路

==:star: **核心思路：KMP + 通过取模模拟叠加  **:star:==

**:key:  key：**

- 除了那套老KMP之外，关键就是主串和模式串匹配时，不需要通过手动让主串叠加变长，**只需要取模就能循环遍历主串**，实现叠加的效果。**即通过取模模拟叠加。因此匹配时主串都是用 i % n 代替 i** 

### 代码

```c++
void getNext(vector<int> &next, string &s) {
    next[0] = 0;
    for (int prefixEnd = 0, suffixEnd = 1; suffixEnd < s.size(); ++suffixEnd) {
        while (prefixEnd > 0 && s[prefixEnd] != s[suffixEnd]) prefixEnd = next[prefixEnd - 1];
        if (s[prefixEnd] == s[suffixEnd]) prefixEnd++;
        next[suffixEnd] = prefixEnd;
    }
}
int repeatedStringMatch(string a, string b) {
    int n = a.size(), m = b.size();
    if (m == 0) return 0;
    // 1.构建next数组
    vector<int> next(m);
    getNext(next, b);
    // 2.利用next数组来进行匹配(i指向主串, j指向模式串)
    for (int i = 0, j = 0; i - j < n; ++i) { 
        //如果i和j之间的距离>=主串长度了，说明模式串中没有一个字符能匹配主串的字符,退出循环
        //匹配时不需要通过手动让主串叠加变长，只需要取模就能循环遍历主串，实现叠加的效果.即通过取模模拟叠加
        //因此匹配时主串都是用 i % n 代替 i 
        while (j > 0 && a[i % n] != b[j]) j = next[j - 1];
        if (a[i % n] == b[j]) ++j;
        if (j == m) return i / n + 1;//返回a的个数
    }
    return -1;//模式串无法匹配主串
}
```

### 复杂度分析

n为主串长度，m为模式串长度

- 时间复杂度：O(m+n)  

- 空间复杂度：O(m)

## [214. 最短回文串](https://leetcode.cn/problems/shortest-palindrome/)

### **题意**

给定一个字符串 ***s***，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。

**示例 1：**

```
输入：s = "aacecaaa"
输出："aaacecaaa"
```

**示例 2：**

```
输入：s = "abcd"
输出："dcbabcd"
```

**提示：**

- `0 <= s.length <= 5 * 104`
- `s` 仅由小写英文字母组成

### 参考题解

1. [ZeroAc](https://leetcode.cn/problems/shortest-palindrome/solutions/39655/c-li-yong-kmpsuan-fa-xiang-xi-tui-dao-zhuan-hua-gu)

### 思路

==:star: **核心思路：reverse + 拼接 + 分割 + KMP  **:star:==

![SmartSelect_20240110_103855_Samsung Notes](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202401101046884.jpg)

**:small_red_triangle_down: steps: **

1.  保存逆转前的s为s0
2.  逆转s，并将分隔符和逆转后的s拼接到s0后面
3.  求s0的next数组
4.  得到next.back()，即s0的最长相等前后缀的长度
5.  返回 "s逆" + "s去除相等前缀后剩下的部分"

### 代码

```c++
void getNext(vector<int> &next, const string &s) {
        int n = s.size();
        for (int pe = 0, se = 1; se < n; ++se) {
            // 不匹配则pe回退
            while (pe > 0 && s[pe] != s[se]) pe = next[pe - 1];
            if (s[pe] == s[se]) pe++;
            next[se] = pe;
        }
    }
    string shortestPalindrome(string s) {
        int n = s.size();
        string s0 = string(s);
        reverse(s.begin(), s.end());//反转后s变成了s逆
        s0 += "#" + s;//得到s'=s+分隔符+s逆
        vector<int> next(s0.size());
        getNext(next, s0);
        int maxlen = next.back();//得到最长相等前后缀的长度
        // 返回 "s逆" + "s去除相等前缀后剩下的部分"
        return s + s0.substr(maxlen, n - maxlen);
    }
```

### 复杂度分析

- 时间复杂度：O(n)  

- 空间复杂度：O(n)

## [lc451. 根据字符出现频率排序](https://leetcode.cn/problems/sort-characters-by-frequency/)

### **题意**

给定一个字符串 `s` ，根据字符出现的 **频率** 对其进行 **降序排序** 。一个字符出现的 **频率** 是它出现在字符串中的次数。

返回 *已排序的字符串* 。如果有多个答案，返回其中任何一个。

 **提示:**

- `1 <= s.length <= 5 * 105`
- `s` 由大小写英文字母和数字组成

**示例 1:**

```
输入: s = "tree"
输出: "eert"
解释: 'e'出现两次，'r'和't'都只出现一次。
因此'e'必须出现在'r'和't'之前。此外，"eetr"也是一个有效的答案。
```

**示例 2:**

```
输入: s = "cccaaa"
输出: "cccaaa"
解释: 'c'和'a'都出现三次。此外，"aaaccc"也是有效的答案。
注意"cacaca"是不正确的，因为相同的字母必须放在一起。
```

### 参考题解

1. [官解](https://leetcode.cn/problems/sort-characters-by-frequency/solutions/855833/gen-ju-zi-fu-chu-xian-pin-lu-pai-xu-by-l-zmvy/) 

### 法一

#### 思路

==:star: **核心思路：unordered哈希 +  按照出现频率排序   **:star:==

**:key:  key：**

- 使用无序map存储字符和出现次数映射关系
- 在vector中存储pair对，利用vector自定义排序

**:question:   problems:** 

1. 为什么要用unordered_map记录字符以及字符的出现频次?能不能用哈希数组？
2. 为什么要？

:heavy_check_mark:  **answer:** 

1. 因为还可能存在数字，用数组的话就无法做映射了

**:small_red_triangle_down: steps: **

1.  遍历s，将字符以及字符的出现频次存到unordered_map
2.  unordered_map不好排序（自定义排序比较难写？），因此我们将其中每个pair取出放到vector以便后续排序
3.  给vector中每个pair按字符(first)的出现频次(second)降序排序
4.  遍历排序后的vec，将每个字符按出现频次尾加到res结果字符串（一个相同字符出现过几次就要尾加到res几次）

:smiley: **收获： ** 

- sort()的时间复杂度O(nlogn)
- 用for遍历时，使用引用`&`，会稍微提高一点效率，因为它避免了值的拷贝。

#### 代码

```c++
string frequencySort(string s) {
    unordered_map<char, int> map;
    for (auto &ch : s) map[ch]++;
    // 从map中取出pair存到vector中
    vector<pair<char, int>> vec;
    for (auto &p : map) vec.emplace_back(p);
    // 给vector中每个pair按字符(first)的出现频次(second)降序排序
    // sort()的时间复杂度O(klogk)，k是不同字符的个数
    sort(vec.begin(), vec.end(), [](const pair<char, int> &a, const pair<char, int> &b){return a.second > b.second;});
    string res;//结果字符串
    for (auto &p : vec) { // 所有出现过的相同字符都要尾追到res，否则相同元素就只剩一个了
        // for (int i = 0; i < p.second; i++) res += p.first;
        res += string(p.second, p.first);//就不需要写个for循环了
        //string(int n, char c);//使用n个字符c初始化
    }
    // 也可以写成结构化绑定（structured binding）的写法，将vec中的pair解构为ch和cnt
    // for (auto &[ch, cnt] : vec) {
    //     for (int i = 0; i < cnt; i++) res += ch;
    // }
    return res;
}
```

#### 复杂度分析

- 时间复杂度：O(n+klogk)  。k是字符串包含的不同字符的个数

    统计字符频次：O(n)

    构建vector：O(k)

    排序vector：O(k log k)

    构建结果字符串：O(n)

- 空间复杂度：O(n+k)。

    哈希表`map`的空间取决于输入字符串中不同字符的数量，为O(k)。

    vector<>是O(k)；

    生成的排序后的结果字符串O(n)

### 法二

#### 思路

可以发现，法一中主要的时间复杂度瓶颈是排序，由于每个字符在字符串中出现的频率存在上限，如果对频次进行桶排序（Bucket Sort）可能能够在某些情况下提高性能。（但这通常要求额外的空间，而且在实践中可能并不总是比标准排序更优）

==:star: **核心思路： 对频次进行桶排序 **:star:==

**:small_red_triangle_down: steps: **

1.  遍历字符串，统计每个字符出现的频率，同时记录最高频次maxFreq；
2.  创建桶，存储从1到maxFreq每个出现频次的字符；
3.  按照出现频率从大到小的顺序遍历桶，对于每个出现频率，取得对应的字符，然后将每个字符按照出现频次拼接到排序后的字符串。

#### 代码

```c++
string frequencySort(string s) {
    unordered_map<char, int> mp;
    int maxFreq = 0;
    // 遍历字符串，统计每个字符出现的频率，同时记录最高频次maxFreq；
    for (auto &ch : s) {
        maxFreq = max(maxFreq, ++mp[ch]);
    }
    // 创建桶（每个桶是一个string，存放多个char，每个桶对应的下标就是桶内字符出现频次）
    // 存储从1到maxFreq每个出现频次的字符；
    vector<string> buckets(maxFreq + 1);//buckets.size() - 1 = maxFreq
    for (auto &[ch, cnt] : mp) { //结构化绑定的写法
        buckets[cnt].push_back(ch);//向频次为cnt的桶添加ch字符
    }
    string res;//结果字符串
    // 按照出现频率从大到小的顺序遍历桶，对于每个出现频率，取得对应的字符，然后将每个字符按照出现频次拼接到排序后的字符串。
    for (int i = buckets.size() - 1; i >= 0; --i) {
        //当前遍历的桶buckets[i],其中字符对应的出现频次是i
        string &bucket = buckets[i];
        //取出桶(string)中的每个字符
        for (auto ch : bucket) {
            // for (int k = 0; k < i; ++k) res += ch;
            res += string(i,ch);//就不需要写个for循环了
            //string(int n, char c);//使用n个字符c初始化
        }
    }
    return res;
}
```

#### 复杂度分析

- 时间复杂度：O(n + k)  

    统计字符频次：O(n)

    创建桶并将不同字符加入桶：O(k)

    生成排序后的字符串：O(n)

- 空间复杂度：O(n + k)  

    哈希map和桶都是：O(k)

    生成排序后的字符串：O(n)

## [lc423. 从英文中重建数字](https://leetcode.cn/problems/reconstruct-original-digits-from-english/)

### **题意**

给你一个字符串 `s` ，其中包含字母顺序打乱的用英文单词表示的若干数字（`0-9`）。按 **升序** 返回原始的数字。

**示例 1：**

```
输入：s = "owoztneoer"
输出："012"
```

**示例 2：**

```
输入：s = "fviefuro"
输出："45"
```

**提示：**

- `1 <= s.length <= 105`
- `s[i]` 为 `["e","g","f","i","h","o","n","s","r","u","t","w","v","x","z"]` 这些字符之一
- `s` 保证是一个符合题目要求的字符串

### 参考题解

1. [官解](https://leetcode.cn/problems/reconstruct-original-digits-from-english/solutions/1118750/guan-fang-jie-fa-ba-mapji-shu-huan-cheng-rssq/) 

### 思路

==:star: **核心思路： 哈希 +  排除 **:star:==

**:key:  key：**

- 首先统计每个字母分别会在哪些数字中出现 。

- 统计之后可以发现，z, w, u, x, g 都只在一个数字中，即 0,2,4,6,8 中出现。因此我们可以使用一个哈希表统计s中每个字母出现的次数，那么 z, w, u, x, g出现的次数，即分别为 0,2,4,6,8 出现的次数。

- 随后我们可以注意那些只在两个数字中出现的字符：

    - h 只在 3,8 中出现。由于我们已经知道了 8 出现的次数，因此可以计算出 3 出现的次数。

    - f 只在 4,5 中出现。由于我们已经知道了 4 出现的次数，因此可以计算出 5 出现的次数。
    - s 只在 6,7 中出现。由于我们已经知道了 6 出现的次数，因此可以计算出 7 出现的次数。

- 此时，我们还剩下 1 和 9 的出现次数没有求出：
    - o 只在 0,1,2,4 中出现，由于我们已经知道了 0,2,4 出现的次数，因此可以计算出 1 出现的次数。
    - 最后的 9 就可以通过 n, i, e 中的任一字符计算得到了。这里推荐使用 i 进行计算，因为 n 在 9 中出现了 2次，e 在 3中出现了 2次，容易在计算中遗漏。而i都只在5,6,8,9中出现一次

**:small_red_triangle_down: steps: **

1.  统计s中每个字符出现的次数
2.  依次确定0~9每一个数字在s中的出现次数
3.  升序拼接数字

### 代码

```c++
string originalDigits(string s) {
    // 统计字符出现的次数
    unordered_map<char, int> mp;
    for (auto ch : s) ++mp[ch];
    // 依次确定每一个数字的出现次数
    vector<int> cnt(10);//0~9
    cnt[0] = mp['z'];//数字0出现的次数就是'z'出现的次数
    cnt[2] = mp['w'];//数字2出现的次数就是'w'出现的次数
    cnt[4] = mp['u'];//数字4出现的次数就是'u'出现的次数
    cnt[6] = mp['x'];//数字6出现的次数就是'x'出现的次数
    cnt[8] = mp['g'];//数字8出现的次数就是'g'出现的次数
    //现在已知了0,2,4,6,8的出现次数, 就可以根据
    // h只在 3,8 中出现。由于我们已经知道了 8 出现的次数，因此可以计算出 3 出现的次数。
    // f 只在 4,5 中出现。由于我们已经知道了 4 出现的次数，因此可以计算出 5 出现的次数。
    // s 只在 6,7 中出现。由于我们已经知道了 6 出现的次数，因此可以计算出 7 出现的次数。
    cnt[3] = mp['h'] - cnt[8];//数字3出现的次数就是'h'出现的次数 - 其在8中出现的次数
    cnt[5] = mp['f'] - cnt[4];//数字5出现的次数就是'f'出现的次数 - 其在4中出现的次数
    cnt[7] = mp['s'] - cnt[6];//数字7出现的次数就是's'出现的次数 - 其在6中出现的次数
    // 此时，我们还剩下 1 和 9 的出现次数没有求出
    cnt[1] = mp['o'] - cnt[0] - cnt[1] - cnt[2] - cnt[4];//o只在 0,1,2,4中出现，由于我们已经知道了 0,2,4出现的次数，因此可以计算出1出现的次数。
    // 最后的9就可以通过n, i, e中的任一字符计算得到了。这里推荐使用i进行计算，因为n在9中出现了2次，e在3 中出现了2次，容易在计算中遗漏。而 i 都只在5,6,8,9中出现一次
    cnt[9] = mp['i'] - cnt[5] - cnt[6] - cnt[8] - cnt[9];
    // 当我们统计完每个数字出现的次数后，我们按照升序将它们进行拼接即可。
    string res;
    for (int i = 0; i < 10; ++i) {
        res += string(cnt[i], i + '0');
        //string(int n, char c); 使用n个字符c构造一个string
    }
    return res;
}
```

### 复杂度分析

- 时间复杂度：O(n)  , n是字符串s的长度

- 空间复杂度：O()


## [lc696. 计数二进制子串](https://leetcode.cn/problems/count-binary-substrings/)

### **题意**

给定一个字符串 `s`，统计并返回具有相同数量 `0` 和 `1` 的非空（连续）子字符串的数量，并且这些子字符串中的所有 `0` 和所有 `1` 都是成组连续的。在不同位置 重复出现的子串也要统计它们出现的次数。

**示例 1：**

```
输入：s = "00110011"
输出：6
解释：6 个子串满足具有相同数量的连续 1 和 0 ："0011"、"01"、"1100"、"10"、"0011" 和 "01" 。
注意，一些重复出现的子串（不同位置）要统计它们出现的次数。
另外，"00110011" 不是有效的子串，因为所有的 0（还有 1 ）没有组合在一起。
```

**示例 2：**

```
输入：s = "10101"
输出：4
解释：有 4 个子串："10"、"01"、"10"、"01" ，具有相同数量的连续 1 和 0 。
```

**提示：**

- `1 <= s.length <= 105`
- `s[i]` 为 `'0'` 或 `'1'`

### 参考题解

1. [官解](https://leetcode.cn/problems/count-binary-substrings/solutions/) 

### 思路

==:star: **核心思路： 按字符【分组】   **:star:==

**:key:  key：**

- 将 s 按照 0 和 1 的连续段分组，存在cnts数组中。（例如 s=0011101，可以得到这样的 cnts 数组：cnts={2,3,1,2}。）
- cnts数组中两个相邻元素 cnt[i-1]和cnts[i] 就代表各自分组中'0'的字符数或'1'的字符数。
- 则相邻分组能组成的满足条件的子串数就为min(cnts[i-1],cnt[i])

#### 写法1. 空间复杂度O(n)

##### 代码

```c++
int countBinarySubstrings(string s) {
    int res = 0, n = s.size(), i = 0;
    vector<int> cnts;//记录每个分组的字符数
    while (i < n) {
        char c = s[i];//当前遍历字符，只有'0','1'两种可能
        int cnt = 0;//初始化该分组的字符个数
        while (i < n && s[i] == c) {
            ++i;
            ++cnt;
        }
        cnts.emplace_back(cnt);//将该分组的字符个数push到cnts
    }
    // 相邻分组能组成的满足条件的子串数为min(cnts[j],cnt[j-1])
    for (int j = 1; j < cnts.size(); ++j) {
        res += min(cnts[j], cnts[j - 1]);
    }
    return res;
}
```

##### 复杂度分析

- 时间复杂度：O(n)  

- 空间复杂度：O(n)

> 其实可以不用数组记录每个分组的字符数，可以就用一个 lastCnt 变量来维护前一个分组的字符数

#### 写法1. 空间复杂度O(1)

##### 代码

```c++
int countBinarySubstrings(string s) {
    int res = 0, n = s.size(), i = 0;
    int lastCnt = 0;//记录上一个分组的字符数
    while (i < n) {
        char c = s[i];//当前遍历字符，只有'0','1'两种可能
        int cnt = 0;//记录当前分组的字符个数
        while (i < n && s[i] == c) {
            ++i;
            ++cnt;
        }
        res += min(lastCnt, cnt);
        lastCnt = cnt;
    }
    return res;
}
```

##### 复杂度分析

- 时间复杂度：O(n)  

- 空间复杂度：O(1)

## [lc467. 环绕字符串中唯一的子字符串](https://leetcode.cn/problems/unique-substrings-in-wraparound-string/)

### **题意**

定义字符串 `base` 为一个 `"abcdefghijklmnopqrstuvwxyz"` 无限环绕的字符串，所以 `base` 看起来是这样的：

- `"...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd...."`.

给你一个字符串 `s` ，请你统计并返回 `s` 中有多少 **不同**非空子串 也在 `base` 中出现。

 翻译下题目： 字符串base是把abc...xyz绕成了一圈的环，然后s的子串如果在这圈26个字母的环里面能找到，那么这个s的子串就是有效的。题目要求找出s所有的有效子串。 （并不是把s搞成圈！）

**示例 1：**

```
输入：s = "a"
输出：1
解释：字符串 s 的子字符串 "a" 在 base 中出现。
```

**示例 2：**

```
输入：s = "cac"
输出：2
解释：字符串 s 有两个子字符串 ("a", "c") 在 base 中出现。
```

**示例 3：**

```
输入：s = "zab"
输出：6
解释：字符串 s 有六个子字符串 ("z", "a", "b", "za", "ab", and "zab") 在 base 中出现。
```

**提示：**

- `1 <= s.length <= 105`
- s 由小写英文字母组成

### 法一

参考题解：[官解](https://leetcode.cn/problems/unique-substrings-in-wraparound-string/solutions/1514359/huan-rao-zi-fu-chuan-zhong-wei-yi-de-zi-ndvea/)

==:star: **核心思路： +   +   **:star:==

**:key:  key：**

- 关键在于dp定义！如果想错了的话根本wu'fa

**:small_red_triangle_down: steps: **

1.  确定dp数组以及下标的含义：
    - dp[i]表示s中以`字母i+'a'`为结尾的,存在于base中的子串的最长长度。知道了这个最长长度，也就知道了s中以该字母结尾的不同子串数（而不是以下标i为结尾的不同子串数）
    - 而不是表示s中以`下标i`为结尾的,存在于base中的子串的最长长度！"以下标i为结尾"说明是以s为基础的dp。但是因为s[i]可能相同，计算结果时就会算重。因此我们要基于26个不同小写英文字母为dp
2.  遍历s （len表示以`下标i`为结尾的,存在于base中的子串的最长长度是len）
    - 若s[i]是s[i-1] 的下一个字符，那么说明能接上，所以len++
    - 否则，接不上，所以len=1
    - 如果以`字符s[i]`结尾的子串长度超过了dp中记录的以该字符为结尾的最长子串长度，则更新dp
3.  累加dp数组中的全部值，作为结果

#### 代码

```c++
int findSubstringInWraproundString(string s) {
    // dp[i]表示s中以【字母i+'a'】为结尾的,存在于base中的子串的最长长度。
    //知道了这个最长长度，也就知道了s中以该字母结尾的不同子串数
    vector<int> dp(26);
    int len = 0; //len表示以`下标i`为结尾的,存在于base中的子串的最长长度是len
    for (int i = 0; i < s.size(); ++i) {//遍历s。当前遍历字符为s[i]，对应字符在dp数组中的索引就是s[i]-'a'
        // 若s[i]是s[i-1] 的下一个字符，那么说明能接上，所以len++
        if (i > 0 && (s[i] - s[i-1] == 1 || s[i] == 'a' && s[i-1] == 'z')) len++; //也可以用求余运算 (s[i-1] + 1) % 26 == s[i] % 26
        // 否则，接不上，所以len=1
        else len = 1;
        //如果以`字符s[i]`结尾的子串长度超过了dp中记录的以该字符为结尾的最长子串长度，则更新dp
        dp[s[i] - 'a'] = max(dp[s[i] - 'a'], len);
    }
    return accumulate(dp.begin(), dp.end(), 0);
    // 表示累加[dp.begin(),dp.end())区间内的所有元素，累加初值为0
}
```

### 法二

参考题解：[lucifer](https://leetcode.cn/problems/unique-substrings-in-wraparound-string/solutions/432752/xi-fa-dai-ni-xue-suan-fa-yi-ci-gao-ding-qian-zhui-/)

==:star: **核心思路： 滑动窗口 **:star:==



## [lc535. TinyURL 的加密与解密](https://leetcode.cn/problems/encode-and-decode-tinyurl/)

### **题意**

TinyURL 是一种 URL 简化服务， 比如：当你输入一个 URL `https://leetcode.com/problems/design-tinyurl` 时，它将返回一个简化的URL `http://tinyurl.com/4e9iAk` 。请你设计一个类来加密与解密 TinyURL 。

加密和解密算法如何设计和运作是没有限制的，你只需要保证一个 URL 可以被加密成一个 TinyURL ，并且这个 TinyURL 可以用解密方法恢复成原本的 URL 。

实现 `Solution` 类：

- `Solution()` 初始化 TinyURL 系统对象。
- `String encode(String longUrl)` 返回 `longUrl` 对应的 TinyURL 。
- `String decode(String shortUrl)` 返回 `shortUrl` 原本的 URL 。题目数据保证给定的 `shortUrl` 是由同一个系统对象加密的。

**提示：**

- `1 <= url.length <= 104`
- 题目数据保证 `url` 是一个有效的 URL

**示例：**

```
输入：url = "https://leetcode.com/problems/design-tinyurl"
输出："https://leetcode.com/problems/design-tinyurl"

解释：
Solution obj = new Solution();
string tiny = obj.encode(url); // 返回加密后得到的 TinyURL 。
string ans = obj.decode(tiny); // 返回解密后得到的原本的 URL 。
```

### 参考题解

1. [官解](https://leetcode.cn/problems/encode-and-decode-tinyurl/solutions/1630074/tinyurl-de-jia-mi-yu-jie-mi-by-leetcode-ty5yp/)

### 思路

==:star: **核心思路： 自增key  /  哈希生成key  /  随机生成key   **:star:==

**:small_red_triangle_down: steps: **

**法二、哈希生成key**

1.  如已经有了相同的longUrl，直接返回其在urlToKey中的value，也就是哈希键
2.  计算longUrl的哈希值
3.  如果发生哈希冲突，我们采用线性探测再散列的方法，将key加一，直到没有冲突
4.  将哈希值作为longUrl的key，将键值对(key,longUrl)插入数据库dataBase，然后返回带有 key的字符串作为shorUrl
5.  返回shorUrl

**法三、随机生成key**

1.  使用一个随机生成的整数作为longUrl 的 key
2.  如果 key已经重复，则不断尝试随机生成整数，直到key 唯一
3.  将键值对(key,longUrl)插入dataBase，然后返回带有 key的字符串作为 shorUrl
4.  返回shorUrl

### 代码

```c++
const long long k1 = 1117;
const long long k2 = 1e9 + 7;
// 选择两个合适的质数 k1=1117, k2=10^9+7 来计算longUrl的哈希值：
class Solution {
private:
    // int id;//法一key自增用
    unordered_map<int, string> dataBase;//哈希键-->longUrl
    unordered_map<string, int> urlToKey;//longUrl-->哈希键
    //相同的longUrl的哈希值相同，因此哈希冲突会频繁发生。为了避免这一点，我们使用一个额外的哈希表urlToKey记录从longUrl(key)到key(value)的映射。
public:
    Solution() {
        // id = 0;//法一key自增用
        // srand(time(0));//随机数种子（对于生成随机数来说是必须的，否则生成的随机数可能重复）
    }
    string encode(string longUrl) {
        // 法一、自增key
        
        // id++;
        // dataBase[id] = longUrl;
        // return string("http://tinyurl.com/") + to_string(id);

        // 法二、哈希生成
        
        if (urlToKey.count(longUrl) > 0) { 
            //如已经有了相同的longUrl，直接返回其在urlToKey中的value，也就是哈希键
            return string("http://tinyurl.com/") + to_string(urlToKey[longUrl]);
        }
        long long key = 0, base = 1;
        for (auto c : longUrl) { //计算longUrl的哈希值
            key = (key + c * base) % k2;
            base = (base * k1) % k2;
        }
        //如果发生哈希冲突，我们采用线性探测再散列的方法，将key加一，直到没有冲突。
        while (dataBase.count(key) > 0) key = (key + 1) % k2; 
        // 将哈希值作为longUrl的key，将键值对(key,longUrl)插入数据库dataBase，然后返回带有 key的字符串作为shorUrl。
        dataBase[key] = longUrl;
        urlToKey[longUrl] = key;
        return string("http://tinyurl.com/") + to_string(key);//返回shorUrl

        // 法三、随机生成
        
        // int key = 0;
        // // 使用一个随机生成的整数作为longUrl 的 key
        // while (true) { //如果 key已经重复，则不断尝试随机生成整数，直到key 唯一
        //     key = rand();
        //     if (dataBase.count(key) == 0) break;
        // }
        // //将键值对(key,longUrl)插入dataBase，然后返回带有 key的字符串作为 shorUrl
        // dataBase[key] = longUrl;
        // return string("http://tinyurl.com/") + to_string(key);//返回shorUrl
    }

    string decode(string shortUrl) { //解密 TinyURL
        // 将shortUrl尾部的哈希键(key)从字符串转换成对应的int型，然后在dataBase中查找key对应的longUrl
        int i = shortUrl.rfind('/') + 1;//找到最右边的'/'的位置并返回其下一个位置的索引
        int key = stoi(shortUrl.substr(i, shortUrl.size() - i));
        //先截取shortUrl中下标[i,shortUrl.size()]表示的哈希键 子串，再将其转换为int型整数
        return dataBase[key];
    }
};
```

### 复杂度分析

**法一**

- 时间复杂度：
    - Encode()函数是O(n)  ，n是longUrl的长度

    - Decode()函数是O(1)  ，我们把shortUr当成有限长度的字符串看待。

- 空间复杂度：
    - Encode()函数是O(n) ，因为保存longUrl需要 O(n)的空间。
    - Decode()函数是O(1)  


**法二**

- 时间复杂度：
    - Encode()函数是O(n)  ，n是longUrl的长度，在数据量远小于10^9+7的情况下，发生哈希冲突的可能性非常小

    - Decode()函数是O(1)  ，我们把shortUr当成有限长度的字符串看待。

- 空间复杂度：
    - Encode()函数是O(n) ，因为保存longUrl需要 O(n)的空间。
    - Decode()函数是O(1)  

**法三**

- 时间复杂度：
    - Encode()函数是O(n)  ，n是longUrl的长度，在数据量远小于2^32的情况下，随机生成的整数重复的可能性十分小。

    - Decode()函数是O(1)  ，我们把shortUr当成有限长度的字符串看待。

- 空间复杂度：
    - Encode()函数是O(n) ，因为保存longUrl需要 O(n)的空间。
    - Decode()函数是O(1)  

## [lc299. 猜数字游戏](https://leetcode.cn/problems/bulls-and-cows/)

### **题意**

给你一个秘密数字 `secret` 和朋友猜测的数字 `guess` ，请你返回对朋友这次猜测的提示。

提示的格式为 `"xAyB"` ，`x` 是公牛个数， `y` 是奶牛个数，`A` 表示公牛，`B` 表示奶牛。朋友每猜测一次，你就会给他下述提示：

- 猜测数字中，有多少位，属于数字和位置都猜对了（称为公牛），
- 有多少位属于数字猜对了但是位置不对（称为奶牛）。

请注意秘密数字和朋友猜测的数字都可能含有重复数字.

**示例 1：**

```cpp
输入：secret = "1807", guess = "7810"
输出："1A3B"
解释：数字和位置都对（公牛）用 '|' 连接，数字猜对位置不对（奶牛）的采用斜体加粗标识。
"1807"
  |
"7810"
```

**示例 2：**

```cpp
输入：secret = "1123", guess = "0111"
输出："1A1B"
解释：数字和位置都对（公牛）用 '|' 连接，数字猜对位置不对（奶牛）的采用斜体加粗标识。
"1123"        "1123"
  |      or     |
"0111"        "0111"
注意，两个不匹配的 1 中，只有一个会算作奶牛（数字猜对位置不对）。通过重新排列非公牛数字，其中仅有一个 1 可以成为公牛数字。
```

**提示：**

- `1 <= secret.length, guess.length <= 1000`
- `secret.length == guess.length`
- `secret` 和 `guess` 仅由数字组成

### 参考题解

1. [官解](https://leetcode.cn/problems/bulls-and-cows/solutions/1088724/cai-shu-zi-you-xi-by-leetcode-solution-q9lz/)

### 代码

```c++
string getHint(string secret, string guess) {
    int bulls = 0, cows = 0;
    int cntS[10] = {0}, cntG[10] = {0};
    //下标(对应数字0~9),值(对应数字的出现次数
    // vector 在构造时会自动将数组元素初始化为零，而普通的数组声明不会自动初始化，它们可能会包含不确定的值，可能会导致错误的计数结果。
    //遍历secret和guess统计公牛数并分别统计两个字符串中的数字的出现次数
    for (int i = 0; i < secret.size(); ++i) {
        //统计公牛数
        if(secret[i] == guess[i]) bulls++;
        //另外要统计就是奶牛数（数字对但是位置不对）
        else { //统计secret 和 guess 的各个字符的出现次数
            ++cntS[secret[i] - '0'];//统计secret的各个字符的出现次数
            ++cntG[guess[i] - '0'];//统计guess的各个字符的出现次数
        }
    }
    //由于多余的数字匹配不上
    for (int i = 0; i < 10; ++i) cows += min(cntS[i], cntG[i]);
    return to_string(bulls) + "A" + to_string(cows) + "B";
}
```

### 复杂度分析

- 时间复杂度：O(n)  

- 空间复杂度：O(1)


## [506. 相对名次](https://leetcode.cn/problems/relative-ranks/)

### 题意

给你一个长度为 `n` 的整数数组 `score` ，其中 `score[i]` 是第 `i` 位运动员在比赛中的得分。所有得分都 **互不相同** 。

运动员将根据得分 **决定名次** ，其中名次第 `1` 的运动员得分最高，名次第 `2` 的运动员得分第 `2` 高，依此类推。运动员的名次决定了他们的获奖情况：

- 名次第 `1` 的运动员获金牌 `"Gold Medal"` 。
- 名次第 `2` 的运动员获银牌 `"Silver Medal"` 。
- 名次第 `3` 的运动员获铜牌 `"Bronze Medal"` 。
- 从名次第 `4` 到第 `n` 的运动员，只能获得他们的名次编号（即，名次第 `x` 的运动员获得编号 `"x"`）。

使用长度为 `n` 的数组 `answer` 返回获奖，其中 `answer[i]` 是第 `i` 位运动员的获奖情况。

**示例 1：**

```
输入：score = [5,4,3,2,1]
输出：["Gold Medal","Silver Medal","Bronze Medal","4","5"]
解释：名次为 [1st, 2nd, 3rd, 4th, 5th] 。
```

**示例 2：**

```
输入：score = [10,3,8,9,4]
输出：["Gold Medal","5","Bronze Medal","Silver Medal","4"]
解释：名次为 [1st, 5th, 3rd, 2nd, 4th] 。
```

**提示：**

- `n == score.length`
- `1 <= n <= 104`
- `0 <= score[i] <= 106`
- `score` 中的所有值 **互不相同**

### 代码

```c++
vector<string> findRelativeRanks(vector<int>& score) {
    vector<pair<int, int>> arr;//p.first是成绩，p.second是下标
    string topThree[3] = {"Gold Medal", "Silver Medal", "Bronze Medal"};
    for (int i = 0; i < score.size(); ++i) arr.emplace_back(score[i], i);
    //按成绩由高到低降序排序
    sort(arr.begin(), arr.end(), [](const pair<int,int>& p1, const pair<int,int>& p2){return p1.first > p2.first;});
    vector<string> res(score.size());
    for (int i = 0; i < score.size(); ++i) { // 成绩由高到低取出每个pair
        if (i < 3) res[arr[i].second] = topThree[i];
        else res[arr[i].second] = to_string(i + 1);
    }
    return res;
}
```

## [lc539. 最小时间差](https://leetcode.cn/problems/minimum-time-difference/)

### **题意**

给定一个 24 小时制（小时:分钟 **"HH:MM"**）的时间列表，找出列表中任意两个时间的最小时间差并以分钟数表示。

**示例 1：**

```
输入：timePoints = ["23:59","00:00"]
输出：1
```

**示例 2：**

```
输入：timePoints = ["00:00","23:59","00:00"]
输出：0
```

### 参考题解

1. [官解](https://leetcode.cn/problems/minimum-time-difference/solutions/1216027/zui-xiao-shi-jian-chai-by-leetcode-solut-xolj/)
2. [微扰理论](https://leetcode.cn/problems/minimum-time-difference/solutions/1217750/wei-rao-li-lun-fen-tong-hong-hei-shu-jia-esxf/)  法二桶排序

==:star: **核心思路： 排序 + 鸽巢原理  **:star:==

**:key:  key：**

- 排序有两种思路：
    1. 直接sort给vector<string>排序
    2. 桶排序：按hour分桶->key(int)，每个桶代表[0-24]中某个小时，桶内装不同minutes->value(set)

**:question:   problems:** 

1. 为什么能直接sort给vector<string>排序? 这是怎么排的？
2. 该题的鸽巢原理是个啥？

:heavy_check_mark:  **answer:** 

1. 因为sort给vector<string>排序默认是按**字符串的字典序**进行排序的。按字符串的字典序排序刚好能达到我们想要的效果。

    【按字典序比较是怎么比较？】比如对于 "11:10" 和 "05:23"，从左到右逐字符比较。首先比较第一个字符：'1'>'0'，因此"05:23"排在 "11:10" 之前。如果第一个字符相同，将继续比较下一个字符...

2. 根据题意，一共有 24×60=1440 种不同的时间。由鸽巢原理可知，如果 timePoints的长度超过 1440，那么必然会有两个相同的时间，此时可以直接返回 0。


### 法一

**:small_red_triangle_down: steps: **

1.  使用鸽巢原理进行优化
2.  给`vector<string> timePoints` sort排序
3.  初始化
4.  遍历排序后的timePoints，算出相邻时间差并更新preMinutes，如果相邻时间差为0，直接return 0
5.  因为首尾时间差也可能是最小时间差，因此还要将minSub与其进行比较

```c++
int getMinutes(string &t) {
    // (法1) 逐字符分割数字
    // int h = (t[0] - '0') * 10 + (t[1] - '0');
    // int m = (t[3] - '0') * 10 + (t[4] - '0');

    // (法2) 直接substr分割时和分，再stoi转换成int
    int h = stoi(t.substr(0, 2));
    int m = stoi(t.substr(3, 2));

    return h * 60 + m;
}
int findMinDifference(vector<string>& timePoints) {
    int n = timePoints.size();
    //优化1:鸽巢原理
    if (n > 1440) return 0;
    //排序（默认按字符串的字典序进行比较）
    sort(timePoints.begin(), timePoints.end());
    //初始化 
    int curMinutes = getMinutes(timePoints[1]), preMinutes = getMinutes(timePoints[0]); 
    int minSub = curMinutes - preMinutes;
    //遍历排序后的timePoints
    for (int i = 1; i < n; ++i) {
        curMinutes = getMinutes(timePoints[i]);
        minSub = min(minSub, curMinutes - preMinutes);
        preMinutes = curMinutes;
        if (minSub == 0) return 0;//优化2:存在时间差为0则直接返回0
    }
    //最后退出循环时preMinutes就是最后一个最大的时间
    //由于首尾时间差也可能是最小时间差，因此还需要将minSub与其进行比较
    return min(minSub, 1440 - preMinutes + getMinutes(timePoints[0]));
}
```

#### 复杂度分析

- 时间复杂度：O(min(n, 1440) log min(n, 1440))

    由于当 n>1440 时直接返回 0，排序时的 1440 不会超过 CCC，因此排序需要 O(min(n, 1440) log min(n, 1440))的时间。

- 空间复杂度：O(1） 

### 法二

**:small_red_triangle_down: steps: **

1.  使用鸽巢原理进行优化
2.  创建桶
3.  遍历timePoints同时将时间插入桶中，插入同时就会自动进行排序
    - 如果出现过相同时间，直接返回0
4.  遍历桶，从最大的时间与最小时间的时间差开始计算时间差，更新ans和last

```c++
int findMinDifference(vector<string>& timePoints) {
    int n = timePoints.size();
    //优化: 鸽巢原理
    if (n > 1440) return 0;
    //桶排序（按hour分桶->key(int)，桶内装不同minutes->value(set)）
    //创建桶（这里为了方便选择map和set）
    map<int, set<int>> hours;//map和set都会在插入的时候就自动排序
    for (auto &str : timePoints) {
        int h = stoi(str.substr(0, 2));
        int m = stoi(str.substr(3, 2));
        if (hours[h].count(h * 60 + m)) return 0;//出现过相同时间，直接返回0
        hours[h].insert(h * 60 + m);
        //不能写成:hours[h] = h * 60 + m;因为value是一个set集合！因此必须用insert!
    }
    //rbegin()返回一个逆序迭代器，它指向容器的最后一个元素
    // last初始化为最大的时间
    int last = -(24 * 60 - *hours.rbegin()->second.rbegin());
    /* 写成 - 的形式是为了之后能与计算时间差的式子合并.因为前一天的时间与今天的时间算时间差是算加法，-负就是+
    *hours.rbegin()就是取最大的hour,
    *hours.rbegin()->second就是取这个最大的hour对应的桶内元素的集合
    *hours.rbegin()->second.rbegin()就是取最大的hour对应的桶中最大的minutes,也就是说取最大的时间*/
    int ans = INT_MAX;
    //遍历桶
    for (auto p : hours) {
        for (auto m : p.second) {
            //第一次循环计算的是  最大的时间与最小的时间的时间差
            ans = min(ans, m - last);
            last = m;
        }
    }
    return ans;
}
```

#### 复杂度分析

- 时间复杂度：O(24*log24 * (n * logn))  

- 空间复杂度：O(24 * n)

    ​    

## [lc553. 最优除法](https://leetcode.cn/problems/optimal-division/)

### **题意**

给定一正整数数组 `nums`**，**`nums` 中的相邻整数将进行浮点除法，以字符串格式返回具有最大值的对应表达式。例如，`nums = [2,3,4]`，我们将求表达式的值 `"2/3/4"`。

但是，你可以在任意位置添加任意数目的括号，来改变算数的优先级。你需要找出怎么添加括号，以便计算后的表达式的值为最大值。

**注意：**你的表达式不应该包含多余的括号。

**示例 1：**

```
输入: [1000,100,10,2]
输出: "1000/(100/10/2)"
解释: 1000/(100/10/2) = 1000/((100/10)/2) = 200
但是，以下加粗的括号 "1000/((100/10)/2)" 是冗余的，
因为他们并不影响操作的优先级，所以你需要返回 "1000/(100/10/2)"。
其他用例:
1000/(100/10)/2 = 50
1000/(100/(10/2)) = 50
1000/100/10/2 = 0.5
1000/100/(10/2) = 2
```

**示例 2:**

```
输入: nums = [2,3,4]
输出: "2/(3/4)"
解释: (2/(3/4)) = 8/3 = 2.667
可以看出，在尝试了所有的可能性之后，我们无法得到一个结果大于 2.667 的表达式。
```

**说明:**

- `1 <= nums.length <= 10`
- `2 <= nums[i] <= 1000`
- 对于给定的输入只有一种最优除法。

### 参考题解

1. [官解](https://leetcode.cn/problems/optimal-division/solutions/)

### 思路

==:star: **核心思路： 数学   **:star:==

**:key:  key：**

- 设最大值为 a / b，a要越大越好，b要越小越好

    - a要越大，则a就是nums[0]，不除任何数的时候就是最大的
    - b要越小，令b = c / d，则除的越多b就越小

    因此让 a = nums[0] ，剩下的一坨全作为 b 时，结果最小。

### 代码

```c++
string optimalDivision(vector<int>& nums) {
    int n = nums.size();
    // 特殊情况：不需要加括号
    if (n == 1) return to_string(nums[0]);
    if (n == 2) return to_string(nums[0]) + "/" + to_string(nums[1]);

    string res = to_string(nums[0]) + "/(" + to_string(nums[1]);
    for (int i = 2; i < n; ++i) {
        res += "/" + to_string(nums[i]);
    }
    res += ")";
    return res;
}
```

### 复杂度分析

- 时间复杂度：O(n)  

- 空间复杂度：O(1) . 除函数返回值以外，不需要额外的存储空间


## [lc537. 复数乘法](https://leetcode.cn/problems/complex-number-multiplication/)

### 题意

[复数](https://baike.baidu.com/item/复数/254365?fr=aladdin) 可以用字符串表示，遵循 `"实部+虚部 i "` 的形式，并满足下述条件：

- `实部` 是一个整数，取值范围是 `[-100, 100]`
- `虚部` 也是一个整数，取值范围是 `[-100, 100]`
- `i2 == -1`

给你两个字符串表示的复数 `num1` 和 `num2` ，请你遵循复数表示形式，返回表示它们乘积的字符串。

**示例 1：**

```
输入：num1 = "1+1i", num2 = "1+1i"
输出："0+2i"
解释：(1 + i) * (1 + i) = 1 + i2 + 2 * i = 2i ，你需要将它转换为 0+2i 的形式。
```

**示例 2：**

```
输入：num1 = "1+-1i", num2 = "1+-1i"
输出："0+-2i"
解释：(1 - i) * (1 - i) = 1 + i2 - 2 * i = -2i ，你需要将它转换为 0+-2i 的形式。 
```

### 思路

![image-20231221095142313](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202312210951448.png[592. 分数加减运算](https://leetcode.cn/problems/fraction-addition-and-subtraction/))

### 代码

```c++
string complexNumberMultiply(string num1, string num2) {
    int addIndex1 = num1.find('+'), addIndex2 = num2.find('+');
    //find原型:int find(const string& s, int pos = 0) const;
    int real1 = stoi(num1.substr(0, addIndex1));
    int imag1 = stoi(num1.substr(addIndex1 + 1));
    int real2 = stoi(num2.substr(0, addIndex2));
    int imag2 = stoi(num2.substr(addIndex2 + 1));
    
    int real = real1 * real2 - imag1 * imag2;
    int imaginary = real1 * imag2 + imag1 * real2;
    return to_string(real) + "+" + to_string(imaginary) + "i";
}
```

## [lc592. 分数加减运算](https://leetcode.cn/problems/fraction-addition-and-subtraction/)

### 题意

给定一个表示分数加减运算的字符串 `expression` ，你需要返回一个字符串形式的计算结果。 这个结果应该是不可约分的分数，即[最简分数](https://baike.baidu.com/item/最简分数)。 如果最终结果是一个整数，例如 `2`，你需要将它转换成分数形式，其分母为 `1`。所以在上述例子中, `2` 应该被转换为 `2/1`。

**示例 1:**

```
输入: expression = "-1/2+1/2"
输出: "0/1"
```

 **示例 2:**

```
输入: expression = "-1/2+1/2+1/3"
输出: "1/3"
```

**示例 3:**

```
输入: expression = "1/3-1/2"
输出: "-1/6"
```

**提示:**

- 输入和输出字符串只包含 `'0'` 到 `'9'` 的数字，以及 `'/'`, `'+'` 和 `'-'`。 
- 输入和输出分数格式均为 `±分子/分母`。如果输入的第一个分数或者输出的分数是正数，则 `'+'` 会被省略掉。
- 输入只包含合法的**最简分数**，每个分数的**分子**与**分母**的范围是 [1,10]。 如果分母是1，意味着这个分数实际上是一个整数。
- 输入的分数个数范围是 [1,10]。
- **最终结果**的分子与分母保证是 32 位整数范围内的有效整数。


$$
\frac{up}{down} + \frac{x}{y} = \frac{up*y+x*down}{down*y}
$$

### 参考题解

1. [官解](https://leetcode.cn/problems/fraction-addition-and-subtraction/solutions/1699131/fen-shu-jia-jian-yun-suan-by-leetcode-so-2mto/)

### 思路

==:star: **核心思路： 推理数学公式 + `gcd()` **:star:==

**:key:  key：**

- 两个分数做加法
    $$
    \frac{up}{down} + \frac{x}{y} = \frac{up*y+x*down}{down*y}
    $$

- 获取分子分母的最大公约数`gcd(abs(up), down)`，将结果约分，化简为最简分数

**:small_red_triangle_down: steps: **

1. 初始化结果的分子分母

2. 遍历字符串

    1. 初始化当前遍历分数的分子分母

    2. 处理符号位

    3. 求分子

        - 求分子的数值位（斜杠前）
        - 给分子带上符号
        - 遍历指针++让其指向分母的首字符

    4. 求分母

    5. （经过上面的步骤，现在我们已经求得当前遍历的这个分数就是`x/y`）

    6. 根据下面的公式，将当前分数`x/y`与之前的结果做加法
        $$
        \frac{up}{down} + \frac{x}{y} = \frac{up*y+x*down}{down*y}
        $$

3. 特判，若结果的分子为0，则结果为0，直接返回"0/1"

4. 获取结果分数的分子分母的最大公约数，约分化简为最简分数

5. 将结果分数转换为字符串形式返回

:smiley: **收获： ** 

- `isdigit(ch)`:判断字符ch是否是0~9中的一个
- `gcd(x,y)`:求x和y的最大公约数

### 代码

```c++
string fractionAddition(string expression) {
    long long up = 0, down = 1;//初始化结果的分子分母
    int n = expression.size(), index = 0, sign = 1;
    while (index < n) { //每一次循环都会进行一次分数加法运算
        // 1.处理符号位
        if (expression[index] == '-' || expression[index] == '+') {
            sign = expression[index] == '-' ? -1 : 1;
            index++;
        }
        // 2.初始化当前遍历分数的分子分母
        long long x = 0, y = 0;
        // 3.求分子
        while (index < n && isdigit(expression[index])) {
            // 求分子的数值位（斜杠前）
            x = x * 10 + expression[index] - '0';
            index++;
        }
        x = sign * x; //给分子带上符号，得到带符号的分子
        index++; //让index指向分母的首字符
        // 4.求分母
        while (index < n && isdigit(expression[index])) {
            // isdigit():判断字符是否是0~9中的一个
            y = y * 10 + expression[index] - '0';
            index++;
        }
        // 得到该分数为 x/y, 将之前的结果分数与x/y做加法
        up = up * y + x * down;
        down *= y;
    }
    if (up == 0) return "0/1";//结果为0，直接返回
    // 获取结果分数的分子分母的最大公约数，约分化简为最简分数
    long long g = gcd(abs(up), down);
    // 将结果分数转换为字符串形式返回
    return to_string(up / g) + "/" + to_string(down / g);
}
```

### 复杂度分析

- 时间复杂度：O(n + logC).其中C为化简前分子分母的最大值，求最大公约数需要O(logC) 

- 空间复杂度：O(1)

## [lc640. 求解方程](https://leetcode.cn/problems/solve-the-equation/)

### **题意**

求解一个给定的方程，将`x`以字符串 `"x=#value"` 的形式返回。该方程仅包含 `'+'` ， `'-'` 操作，变量 `x` 和其对应系数。

如果方程没有解或存在的解不为整数，请返回 `"No solution"` 。如果方程有无限解，则返回 `“Infinite solutions”` 。

题目保证，如果方程中只有一个解，则 'x' 的值是一个整数。

**示例 1：**

```
输入: equation = "x+5-3+x=6+x-2"
输出: "x=2"
```

**示例 2:**

```
输入: equation = "x=x"
输出: "Infinite solutions"
```

**示例 3:**

```
输入: equation = "2x=x"
输出: "x=0"
```

**提示:**

- `3 <= equation.length <= 1000`
- `equation` 只有一个 `'='`. 
- 方程由绝对值在 `[0, 100]` 范围内且无任何前导零的整数和变量 `'x'` 组成。

### 参考题解

1. [宫水三叶](https://leetcode.cn/problems/solve-the-equation/solutions/1736347/by-ac_oier-fvee)

### 思路

**:small_red_triangle_down: steps: **

1.  用xPrefix和cons分别表示变量x的系数和常数项，用sign表示计算项的正负
2.  遍历字符串，遍历字符有四种情况：'+/-'， '='， 'x'， '数值'
    - 若为'+/-'，则改变sign
    - 若为 '='，则将左边的运算结果移项到右边
    - 若为 'x'，需要分x有无系数两种情况
        - 无系数，则xPrefix直接+-1
        - 有系数，则`xPrefix += sign*stoi(substr())`，放到为'数值'的逻辑中统一处理
    - 若为  '数值'，则需要判断是常数项还是x的系数
        - 先让一个快指针后移直到不指向数字为止，判断此时指向的是'x'还是其它
            - 若指向'x'，说明是x的系数，累加到xPrefix
            - 否则，说明是常数项，累加到常数项
3.  判断是无解（xPrefix == 0 && cons != 0）还是有无限解（xPrefix == 0 && cons == 0）
4.  有解返回计算结果：系数*x+常数=0 ==> x=-常数/xPrefix=`-cons/xPrefix`

### 代码

```c++
string solveEquation(string equation) {
    int n = equation.size();
    int xPrefix = 0, cons = 0;//xPrefix和cons分别表示x的系数和常数项
    int sign = 1;//符号，表示正负
    for(int i = 0; i < n;) {
        char ch = equation[i];
        // ch有四种情况：'+/-', '=', 'x', '数值'
        if (ch == '+' || ch == '-') {
            sign = (ch == '-') ? -1 : 1; 
            ++i;
        }
        else if (ch == '=') {//将左边的运算结果移项到右边
            xPrefix = -xPrefix; cons = -cons;
            sign = 1;
            ++i;
        }
        //如果是'x'，则需要判断x有没有系数
        else if (ch == 'x') { //x没有系数，这时候就xPrefix就只需要+1或-1
            xPrefix += sign;
            ++i;
        }
        else { //如果是数字，则需要判断是常数项还是x的系数
            int j = i;
            while (j < n && isdigit(equation[j])) ++j;
            int num = sign * stoi(equation.substr(i, j - i));
            if (equation[j] == 'x') {
                xPrefix += num;
                i = j + 1;//跳过'x',否则下次循环又会执行if (ch == 'x')导致重复计算
            }
            else {
                cons += num;
                i = j;
            }
        }
    }
    if (xPrefix == 0) return cons == 0 ? "Infinite solutions" : "No solution";
    return "x=" + to_string(-cons / xPrefix);//系数*x+常数=0 ==> x=-常数/xPrefix=-cons/xPrefix
}
```

### 复杂度分析

- 时间复杂度：O(n)  

- 空间复杂度：O(1)


## **[lc38. 外观数列](https://leetcode.cn/problems/count-and-say/)**

### **题意**

「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。你可以将其视作是由递归公式定义的数字字符串序列：

- `countAndSay(1) = "1"`
- `countAndSay(n)` 是对 `countAndSay(n-1)` 的描述，以数字字符串的。

给定一个正整数 `n` ，输出外观数列的第 `n` 项。

前五项如下：

```
1.     1
2.     11
3.     21
4.     1211
5.     111221
第一项是数字 1 
描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 "11"
描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 "21"
描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 "1211"
描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 "111221"
```

要 **描述** 一个数字字符串，首先要将字符串分割为 **最小** 数量的组，每个组都由连续的最多 **相同字符** 组成。然后**对于每个组，先描述字符的数量，然后描述字符，形成一个数字字符串形式的描述组。**再将所有描述组连接起来。

例如，数字字符串 `"3322251"` 的描述如下图：![image-20231225092325962](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202312250923070.png)

**提示：**`1 <= n <= 30` 

**示例 2：**

```
输入：n = 4
输出："1211"
解释：
countAndSay(1) = "1"
countAndSay(2) = 读 "1" = 一 个 1 = "11"
countAndSay(3) = 读 "11" = 二 个 1 = "21"
countAndSay(4) = 读 "21" = 一 个 2 + 一 个 1 = "12" + "11" = "1211"
```

### 参考题解

1. 明明几行就能搞完而且理解也更简单，一个个题解写的又长又臭:neutral_face:

### 思路

所谓的「外观数列」，本质上就是依次统计字符串中连续相同字符的个数。

**:question:   problems:** 

1. 循环条件能不能写成`res[j]==res[j-1]`，为什么?

:heavy_check_mark:  **answer:** 

1. 不行！自己试试就知道了，麻烦得很

**:small_red_triangle_down: steps: **

1.  外观数列初始化为"1"
2.  循环n-1次以得到第n项的外观数列，每一次循环都要得到第 i 项外观数列
3.  初始化当前项外观数列为空字符串（因为每一次得到的外观数列都是对前一项外观数列的描述，是全新的！而不是直接就能追加在前一项的结果后面的。因此在求得当前项外观数列时必须要先初始化该次的外观数列）
4.  遍历前一项外观数列，以求得当前项外观数列
    1.  初始化当前遍历字符的数量为1
    2.  如果相邻字符相等则快指针后移，统计字符数量
    3.  得到当前遍历字符的数量后，将【数量】+【字符】形成一个数字字符串形式的【描述组】，追加在要 求的当前项外观数列后

5.  得到当前项外观数列后，给res赋值为这次遍历求得的外观数列，以作为下一次循环用来参考遍历的前一项外观数列

:smiley: **收获： ** 

- `tmp += to_string(cnt) + ch;`可以写成`tmp += cnt + '0'; tmp += ch;`但是不可以写成`tmp += cnt + '0' + ch;`。比如cnt=1，ch='1'时，
    - `tmp += 1 + '0' + '1'`：相当于`tmp += "(1 + 48 + 49)" == "98"`。也就是说，当整数和char做加法时，会将字符的ASCII值加到整数上，再把最终计算出的整数用" "引起来转换为字符串形式 
    - `tmp += to_string(1) + '1'`：相当于`tmp += "1" + '1'== "11"`。也就是说，当字符串和char做加法时，是直接将它们拼接起来，而不会做ASCII的相关计算 


### 代码

```c++
string countAndSay(int n) {
    string res = "1";//1.
    for (int i = 1; i < n; ++i) { //2.
        string tmp = "";//3.
        for (int j = 0; j < res.size(); ++j) { //4.
            int cnt = 1;//4.1
            while (j + 1 < res.size() && res[j] == res[j + 1]) {//4.2
                cnt++;
                j++;
            }
            tmp += to_string(cnt) + res[j];//4.3
        }
        res = tmp;//5.
    }
    return res;
}
```

### 复杂度分析

- 时间复杂度：O(n*m)，n为给定的正整数是，m为生成过的所有外观数列字符串中的最大长度  

- 空间复杂度：O(m)


##   [lc443. 压缩字符串](https://leetcode.cn/problems/string-compression/)

### **题意**

给你一个字符数组 `chars` ，请使用下述算法压缩：

从一个空字符串 `s` 开始。对于 `chars` 中的每组 **连续重复字符** ：

- 如果这一组长度为 `1` ，则将字符追加到 `s` 中。
- 否则，需要向 `s` 追加字符，后跟这一组的长度。

压缩后得到的字符串 `s` **不应该直接返回** ，需要转储到字符数组 `chars` 中。需要注意的是，如果组长度为 `10` 或 `10` 以上，则在 `chars` 数组中会被拆分为多个字符。

请在 **修改完输入数组后** ，返回该数组的新长度。

你必须设计并实现一个只使用常量额外空间的算法来解决此问题。

**示例 1：**

```
输入：chars = ["a","a","b","b","c","c","c"]
输出：返回 6 ，输入数组的前 6 个字符应该是：["a","2","b","2","c","3"]
解释："aa" 被 "a2" 替代。"bb" 被 "b2" 替代。"ccc" 被 "c3" 替代。
```

**示例 3：**

```
输入：chars = ["a","b","b","b","b","b","b","b","b","b","b","b","b"]
输出：返回 4 ，输入数组的前 4 个字符应该是：["a","b","1","2"]。
解释：由于字符 "a" 不重复，所以不会被压缩。"bbbbbbbbbbbb" 被 “b12” 替代。
```

### 思路

==:star: **核心思路：指向新旧数组的双指针  **:star:==

**:key:  key：**

- 关键是注意"如果组长度为 `10` 或 `10` 以上，则在 `chars` 数组中会被拆分为多个字符。"不要漏了！

**:small_red_triangle_down: steps: **

1. 初始化两个指针，分别指向新数组的末尾( j ) 和旧数字的末尾( i )

2. 遍历字符数组

    1. 初始化当前遍历字符的个数cnt为1

    2. i 后移遍历相同字符，得到该字符的个数

    3. 如果个数为1，则直接将其放到新数组；否则还需要再将其个数追加上去

        - 注意！当追加cnt时，如果cnt>=10就需要将cnt的每一位拆成单独的字符，此时有两种拆法

            1. ```c++
                string cntStr = to_string(cnt);//将cnt转字符串，再用[]取每个字符
                for (int k = 0; k < cntStr.size(); ++k) chars[j++] = cntStr[k];
                ```

            2. ```c++
                int tmp = j;//用cnt%10逐位取个位到最高位，再反转位置
                for(; cnt; cnt /= 10) chars[j++] = cnt % 10 + '0';//12%10=2,1%10=1
                reverse(chars.begin() + tmp, chars.begin() + j);
                ```

3. 此时 j 指向新数组末尾的下一个位置，新数组长度就是 j

### 代码

```c++
int compress(vector<char>& chars) {
    int n = chars.size(), j = 0;//1.j指向新数组的末尾
    for (int i = 0; i < n; ++i) { //2.i指向旧数组的末尾
        int cnt = 1; //2.1
        // 2.2
        while (i + 1 < n && chars[i] == chars[i + 1]) {++i;++cnt;}
        // 退出循环时,i仍指向遍历字符，i+1指向另外一个不同字符
        // 2.3如果个数为1，则直接将其放到新数组，否则还需要将其个数追加上去
        chars[j++] = chars[i];  
        if (cnt != 1) { //还需追加cnt,如果cnt>=10就需要将cnt的每一位拆成单独的字符
            // 第一种拆法:
            // string cntStr = to_string(cnt);
            // for (int k = 0; k < cntStr.size(); ++k) chars[j++] = cntStr[k];
            
            // 第二种拆法:
            int tmp = j;
            for(; cnt; cnt /= 10) chars[j++] = cnt % 10 + '0';//12%10=2,1%10=1
            reverse(chars.begin() + tmp, chars.begin() + j);
        }
    }
    return j;
}
```

## **[lc8. 字符串转换整数 (atoi)](https://leetcode.cn/problems/string-to-integer-atoi/)**

### **题意**

请你来实现一个 `myAtoi(string s)` 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 `atoi` 函数）。

函数 `myAtoi(string s)` 的算法如下：

1. 读入字符串并丢弃无用的前导空格
2. 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。
3. 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。
4. 将前面步骤读入的这些数字转换为整数（即，"123" -> 123， "0032" -> 32）。如果没有读入数字，则整数为 `0` 。必要时更改符号（从步骤 2 开始）。
5. 如果整数数超过 32 位有符号整数范围 `[−2^31, 2^31 − 1]` ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 `−2^31` 的整数应该被固定为 `−2^31` ，大于 `2^31 − 1` 的整数应该被固定为 `2^31 − 1` 。
6. 返回整数作为最终结果。

**注意：**

- 本题中的空白字符只包括空格字符 `' '` 。
- 除前导空格或数字后的其余字符串外，**请勿忽略** 任何其他字符。

**示例 1：**

```
输入：s = "42"
输出：42
解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。
第 1 步："42"（当前没有读入字符，因为没有前导空格）
         ^
第 2 步："42"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）
         ^
第 3 步："42"（读入 "42"）
           ^
解析得到整数 42 。
由于 "42" 在范围 [-231, 231 - 1] 内，最终结果为 42 。
```

**示例 2：**

```
输入：s = "   -42"
输出：-42
解释：
第 1 步："   -42"（读入前导空格，但忽视掉）
            ^
第 2 步："   -42"（读入 '-' 字符，所以结果应该是负数）
             ^
第 3 步："   -42"（读入 "42"）
               ^
解析得到整数 -42 。
由于 "-42" 在范围 [-231, 231 - 1] 内，最终结果为 -42 。
```

**提示：**

- `0 <= s.length <= 200`
- `s` 由英文字母（大写和小写）、数字（`0-9`）、`' '`、`'+'`、`'-'` 和 `'.'` 组成

> **此题一定要理解清楚题意！在出现数字之前只能出现空格和一个符号，否则就返回0。比如"+-12"和"words and 987"都是返回0！**

### 法一

参考题解：[官解](https://leetcode.cn/problems/string-to-integer-atoi/solutions/183164/zi-fu-chuan-zhuan-huan-zheng-shu-atoi-by-leetcode-)

==:star: **核心思路：状态机  **:star:==

**什么是自动机?** —— 我们的程序在每个时刻有一个状态s，每次从序列中输入一个字符c，并根据字符c 转移到下一个状态s'。这样，我们只需要建立一个覆盖所有情况的从s与c映射到s'的表格即可解决题目中的问题。

![image-20231228084113666](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202312280841729.png)

根据状态转移图**建立一个覆盖所有情况的、从s与c映射到s'的表格**：

![image-20231228091723187](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202312280917261.png)

**状态机流程（以"    -42"举例）**

1. 一开始，必然是开始状态start，所以初始在第0行

2. 第一个字符是`' '`，进入[0, 0] start状态（保持不变）

3. 第二个字符是`' '`，同上一样...不再赘述

4. 第四个字符是`'-'`，进入[0, 1] signed状态

5. 接下来是`4`，进入 [1, 2] in_number状态

6. 接着是`2`，进入 [2, 2] in_number状态

7. 没有字符了，遍历结束

    ![image-20231228091915101](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202312280919189.png)

注意遍历获取字符所处状态时，若所处状态为 `in_number`需要更新结果（注意范围）。

**:small_red_triangle_down: steps: **

1.  定义状态机，得到状态表
2.  遍历字符串取得每个字符的状态，如果是`in_number`则更新结果ans，如果是`signed`则更新正负sign
    - 注意若ans超出了32位INT表示范围则需要对结果进行限制
3.  返回 sign * ans

#### 代码

```c++
class Automaton {
    string state = "start";
    //定义状态表
    unordered_map<string, vector<string>> table = {
        {"start", {"start", "signed", "in_number", "end"}},
        {"signed", {"end", "end", "in_number", "end"}},
        {"in_number", {"end", "end", "in_number", "end"}},
        {"end", {"end", "end", "end", "end"}}
    };
    int get_col(char c) { //获取当前字符所处于的状态的索引
        //isspace()检查字符是否是空白字符
        if (isspace(c)) return 0;//是空格则处于的状态在索引0
        if (c == '+' or c == '-') return 1;//是符号则处于的状态在索引1
        if (isdigit(c)) return 2;//如果是数字则处于的状态在索引2
        return 3;//否则处于的状态在索引3
    }
public:
    int sign = 1;
    long long ans = 0;

    void get(char c) { //获取当前字符所处于的状态，如果是in_number则更新结果，如果是符号则更新正负
        state = table[state][get_col(c)];
        if (state == "in_number") {  
            ans = ans * 10 + c - '0';
            //若ans超出了32位INT表示范围
            ans = sign == 1 ? min(ans, (long long)INT_MAX) : min(ans, -(long long)INT_MIN);
        }
        else if (state == "signed") sign = c == '+' ? 1 : -1;
    }
};

class Solution {
public:
    int myAtoi(string str) {
        Automaton automaton;
        for (char c : str) automaton.get(c);
        return automaton.sign * automaton.ans;
    }
};
```

#### 复杂度分析

- 时间复杂度：O(n)。因为只需要遍历一次字符串的所有字符，且处理每个字符的时间为O(1) 

- 空间复杂度：O(1)


### 法二

**:small_red_triangle_down: steps: **

1.  跳过前置空格

    - 如果 i 到了结尾n 或者【i 指向非数字、非正负符号】，则不会进入之后的while循环，ans = 0，因此最终仍会return 0

2.  如果 i 指向正负符号，则相应地改变sign并让 i 后移

    - 若 i 后移指向的并不是数字而是其它字符，则不会进入之后的while循环，ans = 0，因此最终仍会return 0

3.  处理每个数字，计算结果。另外，若ans超出了32位INT表示范围则需要对结果进行限制，限制逻辑分析如下：

    - 对于写法一、用long保存ans变量，此时直接判断ans数值是否超过INT_MAX即可

    - 对于写法二、用int保存ans变量，此时判断溢出的 if 分析如下：
        1. `ans > INT_MAX / 10`：
            - 这个条件检查当前计算出的数值 ans 是否已经大于INT_MAX 除以 10。
            - 如果是，那么下面的计算中，乘以 10 会int型的ans变量导致溢出。
        2. `ans == INT_MAX / 10 && s[i] - '0' > 7`
            - 这个条件检查当前计算出的数值 ans 是否 == INT_MAX 除以 10，并检查当前数字是否超过了7。
            - 为什么是7？因为在将字符串转换为整数时，最大值 `INT_MAX` 的**个位**是 7。超过这个数字，就会造成整数溢出。 

4.  返回结果

**:x: careless | ignore :**

- 不能直接用stoi(),本题要我们实现字符串到整数的转换，怎么能直接调用类似的C++api呢

#### 代码

```c++
int myAtoi(string s) {
    int sign = 1, i = 0, n = s.size();
    while(s[i] == ' ') i++;
    if(s[i] == '-' || s[i] == '+') sign = (s[i++] == '-') ? -1 : 1;
    // 写法一、用long保存ans变量
    long ans = 0;
    while(i < n && isdigit(s[i])){
        ans = ans * 10 + s[i++] - '0';
        //若ans超出了32位INT的表示范围
        if(ans > INT_MAX) return sign == 1 ? INT_MAX : INT_MIN; 
    }
    // 写法二、用int保存ans变量
    // int ans = 0; 
    // while(i < n && isdigit(s[i])) {
    //     if(ans > INT_MAX / 10 || (ans == INT_MAX / 10 && s[i] - '0' > 7)) return sign == 1 ? INT_MAX : INT_MIN;
    //     ans = ans * 10 + (s[i++] - '0'); //不加括号则"21474836460"会溢出
    // }
    // return ans * sign;
    return ans * sign;
}
```

#### 复杂度分析

- 时间复杂度：O(n)。 

- 空间复杂度：O(1)



## [lc13. 罗马数字转整数](https://leetcode.cn/problems/roman-to-integer/)

### **题意**

罗马数字包含以下七种字符: `I`， `V`， `X`， `L`，`C`，`D` 和 `M`。

```
字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
```

例如， 罗马数字 `2` 写做 `II` ，即为两个并列的 1 。`12` 写做 `XII` ，即为 `X` + `II` 。 `27` 写做 `XXVII`, 即为 `XX` + `V` + `II` 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 `IIII`，而是 `IV`。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 `IX`。这个特殊的规则只适用于以下六种情况：

- `I` 可以放在 `V` (5) 和 `X` (10) 的左边，来表示 4 和 9。
- `X` 可以放在 `L` (50) 和 `C` (100) 的左边，来表示 40 和 90。 
- `C` 可以放在 `D` (500) 和 `M` (1000) 的左边，来表示 400 和 900。

给定一个罗马数字，将其转换成整数。 

**示例 1:**

```
输入: s = "III"
输出: 3
```

**示例 2:**

```
输入: s = "IV"
输出: 4
```

**示例 3:**

```
输入: s = "IX"
输出: 9
```

**示例 4:**

```
输入: s = "LVIII"
输出: 58
解释: L = 50, V= 5, III = 3.
```

**示例 5:**

```
输入: s = "MCMXCIV"
输出: 1994
解释: M = 1000, CM = 900, XC = 90, IV = 4.
```

**提示：**

- `1 <= s.length <= 15`
- `s` 仅含字符 `('I', 'V', 'X', 'L', 'C', 'D', 'M')`
- 题目数据保证 `s` 是一个有效的罗马数字，且表示整数在范围 `[1, 3999]` 内
- 题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。
- **罗马数字书写规范**
    - 罗马数字一般从高位到低位书写，从左向右阅读。若位于高位的数较大，则用高位的数加上低位的数；若位于高位的数较小，则用低位的数减去高位的数
    - 低位减去高位时 **不能跨越一个位数** 且 **高位的数只能是I，X，C（即只能减1，减10，减100···）**
    - 什么是跨位？拿"IVC"（1 5 100）这个无效的罗马数字举例，本来5-1=4，之后可以从两个角度解释无效：
        1. 高位的数只能是I，X，C（即只能减1，减10，减100···），得到4之后，若100-4，4作为减数，其值不合规范（必须是1，10，100···）
        2. 跨位了，得到4之后，若100-4，100是三位，4是一位，中间跨了一位。

### 思路

主要是弄懂题意！

**:key:  key：**比较相邻字符，若左>=右则直接将左边字符加到res，否则减去左边字符

### 代码

```c++
class Solution {
private:
    unordered_map<char, int> symbolValues = {
        {'I', 1},
        {'V', 5},
        {'X', 10},
        {'L', 50},
        {'C', 100},
        {'D', 500},
        {'M', 1000}
    };

public:
    int romanToInt(string s) {
        int res = 0, n = s.size();
        //写法一、
        if (n == 1) return symbolValues[s[0]];
        for (int i = 0; i < n - 1; ) {
            int curVal = symbolValues[s[i]], nextVal = symbolValues[s[i + 1]];
            if (curVal >= nextVal) {
                res += curVal;
                ++i;
            }
            else {  
                res += nextVal - curVal;
                i += 2;
            }
        }
        if (n - 2 >= 0 && symbolValues[s[n - 2]] >= symbolValues[s[n - 1]]) res += symbolValues[s[n - 1]];
        
        //写法一、
        for (int i = 0; i < n; ++i) {
            if (i + 1 < n && symbolValues[s[i]] < symbolValues[s[i + 1]]) 
                res -= symbolValues[s[i]];
            else res += symbolValues[s[i]];
        }

        return res;
    }
```

### 复杂度分析

- 时间复杂度：O(n)  

- 空间复杂度：O(1)


## [lc12. 整数转罗马数字](https://leetcode.cn/problems/integer-to-roman/)

### **题意**

罗马数字包含以下七种字符： `I`， `V`， `X`， `L`，`C`，`D` 和 `M`。

```
字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
```

例如， 罗马数字 2 写做 `II` ，即为两个并列的 1。12 写做 `XII` ，即为 `X` + `II` 。 27 写做 `XXVII`, 即为 `XX` + `V` + `II` 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 `IIII`，而是 `IV`。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 `IX`。这个特殊的规则只适用于以下六种情况：

- `I` 可以放在 `V` (5) 和 `X` (10) 的左边，来表示 4 和 9。
- `X` 可以放在 `L` (50) 和 `C` (100) 的左边，来表示 40 和 90。 
- `C` 可以放在 `D` (500) 和 `M` (1000) 的左边，来表示 400 和 900。

给你一个整数，将其转为罗马数字。

**示例 1:**

```
输入: num = 3
输出: "III"
```

**示例 2:**

```
输入: num = 4
输出: "IV"
```

**示例 3:**

```
输入: num = 9
输出: "IX"
```

**示例 4:**

```
输入: num = 58
输出: "LVIII"
解释: L = 50, V = 5, III = 3.
```

**示例 5:**

```
输入: num = 1994
输出: "MCMXCIV"
解释: M = 1000, CM = 900, XC = 90, IV = 4.
```

**提示：**

- `1 <= num <= 3999`

### 参考题解

1. [官解](https://leetcode.cn/problems/integer-to-roman/solutions/774611/zheng-shu-zhuan-luo-ma-shu-zi-by-leetcod-75rs)

### 思路

==:star: **核心思路：贪心 （贪心一般要对数据进行预处理--排序）  **:star:==

**:key:  key：**

- 这道题可以算作贪心算法的【找零钱问题】，即 **优先选择面值大的**纸币找给顾客，这样需要找的纸币就能尽可能少
- num从左到右，给每一位都选择尽可能大的符号值，选完一个就将num-该符号值继续重复循环，直到num==0

:smiley: **收获： ** 

- 不要看到键值对映射就只想到map，有时候也需要考虑顺序的pair数组

### 代码

```c++
//如果写在类内必须要给[]内写上数组大小13！！否则会报错：error: array bound cannot be deduced from an in-class initializer
//deduced:推断、in-class initializer:类内初始化程序
const pair<int, string> valueSymbols[] = {
    {1000, "M"},
    {900,  "CM"},
    {500,  "D"},
    {400,  "CD"},
    {100,  "C"},
    {90,   "XC"},
    {50,   "L"},
    {40,   "XL"},
    {10,   "X"},
    {9,    "IX"},
    {5,    "V"},
    {4,    "IV"},
    {1,    "I"},
};
class Solution {
public:
    string intToRoman(int num) {
        string res;
        for (const auto&[value, symbol] : valueSymbols) { 
            //将num与valueSymbols中的pair依次比较
            //当value>num时会一路跳过，直到num>=value，即找到了第一个不超过num的最大的value值
            while (num >= value) {
                num -= value;
                res += symbol;
            } 
            if (num == 0) break;
        }
        return res;
    }
};
```

### 复杂度分析

- 时间复杂度：O(1)  

- 空间复杂度：O(1)

## [273. 整数转换英文表示](https://leetcode.cn/problems/integer-to-english-words/)

### **题意**

将非负整数 `num` 转换为其对应的英文表示。

**示例 1：**

```
输入：num = 123
输出："One Hundred Twenty Three"
```

**示例 2：**

```
输入：num = 12345
输出："Twelve Thousand Three Hundred Forty Five"
```

**示例 3：**

```
输入：num = 1234567
输出："One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven"
```

**提示：**

- `0 <= num <= 231 - 1`

### 参考题解

1. [宫水三叶](https://leetcode.cn/problems/integer-to-english-words/solutions/1040978/gong-shui-san-xie-zi-fu-chuan-da-mo-ni-b-0my6)

### 思路

==:star: **核心思路：分解  **:star:==

**:key:  key：**

- **数字的英文表示是 从左到右 每3位为一组进行表示的！因此我们只需要将数字拆成多个三位组处理即可【分解的思想，化繁为简】**

    - 如果不够三位也一样当作三位组处理，而不是和后面的位组合成三位组！如1 234 567就应该分成三个三位组，第一个三位组是不够3位的单独的1，另外两个三位组分别是234和567

- **表示三位一组的所有数字，即表示1~999的数，我们用函数`GroupOfThree(num)`来处理。该函数的作用就是：**

    1. 将1~999用英文单词拼接表示出来；（为什么不表示0在2.中有说明）

    2. 在后面跟上"Billion /Million /Thousand "打配合，以表示正确的基数大小

        【从这里我们也能知道，由于"Zero"后面是不能跟上这三个大基数打配合的，因此我们需要对"Zero"的情况做特判】

**:small_red_triangle_down: steps: **

- **`GroupOfThree(num)`的实现逻辑如下：**

    1. 若num有三位，即在[100,999]之间，则res += `百位对应的单词(1~9)+" Hundred "`，然后剥掉百位变成两位数，继续往下执行
    2. 若num在[20,100)之间，则res += `"十位对应的单词(***ty)"+空格`，然后剥掉十位变成个位数，继续往下执行
    3. 若num不等于0，则res += `"个位对应的单词(1~9)"+空格`，表示结束

- **主函数的实现逻辑如下：**

    1. 先对"Zero"(0)的情况进行特判

    2. 以一个三位组为单位, 从左到右处理数字（i 从10^9^->10^6^->10^3^->1逐个处理三位组，j 从0->1->2->3（通过 j 从THOUSANDS中取的基数从"Billion"十亿->"Million"百万->"Thousand"千->""空））

        > 关于为什么基数是从Billion十亿（10^9^）开始。是因为num<=2^31^-1约等于10^9^，因此基数最大也就是从10^9^（十亿）开始，而不会从10^10^开始。

        1. 如果num比当前基数 i 还小（比如num<10^9^而此时基数i=10^9^，此时num无法用十亿表示），则continue让 基数 i/10^3^ 变小，直到num能用基数i表示为止
        2. 除法运算以取当前num的最高三位组，利用`GroupOfThree(num)`得到三位组的英文表示之后，再用 j 从THOUSAND中取出对应基数进行拼接，完事再拼接上空格

        > 举例：1 234 567 。
        >
        > 第一个三元组1的英文表示是"One "+"Million"+" "，
        > 第二个三元组234的英文表示是"Two "+" Hundred "+"Thirty "+"Four "+"Thousand"+" "，
        > 第三个三元组567的英文表示是"Five "+" Hundred "+"Sixty "+"Seven "+" "。
        >
        > 合到一起就是"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven  "。

    3. 更新

        - num取余运算以剥离最高三位组
        - i / 10^3^ 得到下一个三位组的基数
        - ++j（基数/10^3^则指向 THOUSANDS中基数对应英文单词 的指针也要后移指向/10^3^后的基数的英文表示）

    4. 移除末尾的空格，返回结果

### 代码

#### 无注释的版本

```c++
class Solution {
private:
    string LESS20[20] = {"", "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine", "Ten", "Eleven", "Twelve", "Thirteen", "Fourteen", "Fifteen", "Sixteen", "Seventeen", "Eighteen", "Nineteen"};
    string TENS[10] = {"", "", "Twenty", "Thirty", "Forty", "Fifty", "Sixty", "Seventy", "Eighty", "Ninety"};
    string THOUSANDS[4] = {"Billion", "Million", "Thousand", ""};
public:
    string GroupOfThree(int x) { 
        string ans;
        if (x >= 100) { ans += LESS20[x / 100] + " Hundred ";   x %= 100; }
        if (x >= 20) { ans += TENS[x / 10] + " ";   x %= 10; }
        if (x != 0) ans += LESS20[x] + " ";
        return ans;
    }
    string numberToWords(int num) {
        if (num == 0) return "Zero";
        string res;
        for (int i = (int)1e9, j = 0; i >= 1; i /= 1000, j++) { 
            if (num < i) continue;
            res += GroupOfThree(num / i) + THOUSANDS[j] + " ";
            num %= i;
        }
        return res.substr(0, res.find_last_not_of(' ') + 1);
    }
};
```

#### 有注释的版本

```c++
class Solution {
private:
    // 所有不可再分的、数字英文单词的表示
    //LESS20表示1~19的单词
    string LESS20[20] = {"", "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine", "Ten", "Eleven", "Twelve", "Thirteen", "Fourteen", "Fifteen", "Sixteen", "Seventeen", "Eighteen", "Nineteen"};
    //TENS表示整十的单词
    string TENS[10] = {"", "", "Twenty", "Thirty", "Forty", "Fifty", "Sixty", "Seventy", "Eighty", "Ninety"};
    //TENS表示十亿、百万、千的单词 => 10^9, 10^6, 10^3 (都是三位组的最高位)
    string THOUSANDS[4] = {"Billion", "Million", "Thousand", ""};
public:
    string GroupOfThree(int x) { //返回一个三位组的表示结果
        string ans;
        //注意下面的分支逻辑都是if而不是if-else，因为除了高位外，还有其它低位需要表示
        //先表示百位(如果有的话)
        if (x >= 100) { 
            ans += LESS20[x / 100] + " Hundred ";//LESS20[x/100]:提取百位(1~9)代表的单词
            x %= 100;//让x剥掉百位
        }
        //再表示十位(如果有且非0的话)
        if (x >= 20) {
            ans += TENS[x / 10] + " ";//TENS[x/10]:提取十位(1~9)代表的单词
            x %= 10;//让x剥掉十位
        }
        //最后表示个位(如果非0的话)
        if (x != 0) ans += LESS20[x] + " ";//LESS20[x]:个位(1~9)代表的单词
        return ans;
    }
    string numberToWords(int num) {
        //(1) 0要单独拎出来特判
        if (num == 0) return "Zero";
        string res;
        //(2) 以一个三位组为单位处理数字（从左到右处理）
        // 如果不够三位也一样当作三位组处理。如1234就应该分成两个三位组，一个三位组是不够3位的单独的1，一个三位组是234
        for (int i = (int)1e9, j = 0; i >= 1; i /= 1000, j++) { //每一次循环都是处理一个三位组
            //1e9就是10^9
            if (num < i) continue;
            res += GroupOfThree(num / i) + THOUSANDS[j] + " ";//除法运算以取最高三位组
            num %= i;//取余运算以剥离最高三位组
        }
        //(3) 移除末尾的空格
        return res.substr(0, res.find_last_not_of(' ') + 1);//直接从头截取至最后一个不为空格的字符
        // 或者        
        // while (res[res.size() - 1] == ' ') res.pop_back();
        // return res;
    }
};
```

### 复杂度分析

- 时间复杂度：O(1)  

- 空间复杂度：O(1)


## [165. 比较版本号](https://leetcode.cn/problems/compare-version-numbers/)

### 题意

给你两个版本号 `version1` 和 `version2` ，请你比较它们。

版本号由一个或多个修订号组成，各修订号由一个 `'.'` 连接。每个修订号由 **多位数字** 组成，可能包含 **前导零** 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，`2.5.33` 和 `0.1` 都是有效的版本号。

比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 **忽略任何前导零后的整数值** 。也就是说，修订号 `1` 和修订号 `001` **相等** 。如果版本号没有指定某个下标处的修订号，则该修订号视为 `0` 。例如，版本 `1.0` 小于版本 `1.1` ，因为它们下标为 `0` 的修订号相同，而下标为 `1` 的修订号分别为 `0` 和 `1` ，`0 < 1` 。

返回规则如下：

- 如果 `version1 > version2` 返回 `1`，
- 如果 `version1 < version2` 返回 `-1`，
- 除此之外返回 `0`。

 

**示例 1：**

```
输入：version1 = "1.01", version2 = "1.001"
输出：0
解释：忽略前导零，"01" 和 "001" 都表示相同的整数 "1"
```

**示例 2：**

```
输入：version1 = "1.0", version2 = "1.0.0"
输出：0
解释：version1 没有指定下标为 2 的修订号，即视为 "0"
```

**示例 3：**

```
输入：version1 = "0.1", version2 = "1.1"
输出：-1
解释：version1 中下标为 0 的修订号是 "0"，version2 中下标为 0 的修订号是 "1" 。0 < 1，所以 version1 < version2
```

**提示：**

- `1 <= version1.length, version2.length <= 500`
- `version1` 和 `version2` 仅包含数字和 `'.'`
- `version1` 和 `version2` 都是 **有效版本号**
- `version1` 和 `version2` 的所有修订号都可以存储在 **32 位整数** 中

### 参考题解

1. [官解](https://leetcode.cn/problems/compare-version-numbers/solutions/970416/bi-jiao-ban-ben-hao-by-leetcode-solution-k6wi)

### 思路

==我们不采用分割字符串的方法来计算修订号数值，而是逐字符数值累加，这样会简单很多。==
（至少对于C++是这样）

**:small_red_triangle_down: steps: **

1.  从左到右遍历v1和v2，分别计算它们当前正在遍历的修订号的数值（遇`'.'`停止），若这俩数值不等，则直接return，否则还需要继续遍历比较

### 代码

```c++
int compareVersion(string version1, string version2) {
    int n = version1.size(), m = version2.size();
    int i = 0, j = 0;
    while (i < n || j < m) { 
        //就算有一个到了末尾，只要还没有比较出结果，我们就需要继续遍历剩下那个
        int num1 = 0, num2 = 0;//该次while循环要计算两个修订号的数值

        // 循环以计算v1,v2的修订号数值，直到遇到'.'
        for (; i < n && version1[i] != '.'; ++i) num1 = num1 * 10 + (version1[i] - '0');
        for (; j < m && version2[j] != '.'; ++j) num2 = num2 * 10 + (version2[j] - '0');
       
        if (num1 != num2) return num1 > num2 ? 1 : -1;
        //跳过点号
        ++i, ++j;
    }
    return 0;
}
```

### 复杂度分析

- 时间复杂度：O(n + m)  

- 空间复杂度：O(1)

## [481. 神奇字符串](https://leetcode.cn/problems/magical-string/)

----

### **题意**

神奇字符串 `s` 仅由 `'1'` 和 `'2'` 组成，并需要遵守下面的规则：

- 神奇字符串 s 的神奇之处在于，串联字符串中 `'1'` 和 `'2'` 的连续出现次数可以生成该字符串。

`s` 的前几个元素是 `s = "1221121221221121122……"` 。如果将 `s` 中连续的若干 `1` 和 `2` 进行分组，可以得到 `"1 22 11 2 1 22 1 22 11 2 11 22 ......"` 。每组中 `1` 或者 `2` 的出现次数分别是 `"1 2 2 1 1 2 1 2 2 1 2 2 ......"` 。上面的出现次数正是 `s` 自身。

给你一个整数 `n` ，返回在神奇字符串 `s` 的前 `n` 个数字中 `1` 的数目。

**示例 1：**

```
输入：n = 6
输出：3
解释：神奇字符串 s 的前 6 个元素是 “122112”，它包含三个 1，因此返回 3 。 
```

**示例 2：**

```
输入：n = 1
输出：1
```

**提示：**

- `1 <= n <= 105`

### 参考题解

1. [灵茶山艾府的动图，看完自己写写画画就能明白题意了](https://leetcode.cn/problems/magical-string/solutions/1938214/by-endlesscheng-z8o1)

### 思路

==:star: **核心思路： 双指针   **:star:==

关键在于理解清楚题意

**:key:  key：**

- s中每个字符就代表了之后要尾加的'1'或'2'的个数，且从第四个元素开始，之后每次要尾加的元素都和  尾加前的末尾元素不一样（即如果尾加前的末尾元素是'1'，则要尾加的元素就是'2'），因此可以由前面的字符(确定cnt)以及末尾元素(确定ch)来确定要尾加多少个ch
- 注意如果s当前长度+cnt超过了n，则超过n之后的'1'就不能算进结果了

### 代码

#### 第一种写法（mine）

每次在原字符串的基础上尾加string

```c++
int magicalString(int n) {
    if (n <= 3) return 1;
    string s("122");
    int i = 2, j = 3;//快慢指针分别指向：j要拓展的字符的个数、要拓展的字符(也即s末尾字符的下一个位置)
    int cnt = 0, res = 1;
    while (j < n) {
        cnt = s[i] - '0';
        char ch = s[j - 1] == '1' ? '2' : '1';
        s += string(cnt, ch);
        //注意特判 当要添加的字符数算上前面的长度超过了n时，超过部分的字符个数不能算入
        if (ch == '1') res += (j + cnt > n) ? n - j : cnt;
        //更新
        ++i;//慢指针后移一位
        j += cnt;//快指针后移
    }
    return res;
}
```

#### 第二种写法

一开始就开辟好大小为n的空间

```c++
int magicalString(int n) {
    if (n <= 3) return 1;
    string s(n, '0');
    s[0] = '1', s[1] = '2', s[2] = '2';
    int i = 2, j = 3;
    int cnt = 0, res = 1;
    while (j < n) {
        cnt = s[i] - '0';
        char ch = s[j - 1] == '1' ? '2' : '1';
        if (ch == '1') res += (j + cnt > n) ? n - j : cnt;
        while (cnt-- > 0 && j < n) s[j++] = ch;
        ++i;//更新慢指针后移一位
    }
    return res;
}
```

### 复杂度分析

- 时间复杂度和空间复杂度都是O(n)


## [482. 密钥格式化](https://leetcode.cn/problems/license-key-formatting/)

### **题意**

给定一个许可密钥字符串 `s`，仅由字母、数字字符和破折号组成。字符串由 `n` 个破折号分成 `n + 1` 组。你也会得到一个整数 `k` 。

我们想要重新格式化字符串 `s`，使每一组包含 `k` 个字符，除了第一组，它可以比 `k` 短，但仍然必须包含至少一个字符。此外，两组之间必须插入破折号，并且应该将所有小写字母转换为大写字母。

返回 *重新格式化的许可密钥* 。

**示例 1：**

```
输入：S = "5F3Z-2e-9-w", k = 4
输出："5F3Z-2E9W"
解释：字符串 S 被分成了两个部分，每部分 4 个字符；
     注意，两个额外的破折号需要删掉。
```

**示例 2：**

```
输入：S = "2-5g-3-J", k = 2
输出："2-5G-3J"
解释：字符串 S 被分成了 3 个部分，按照前面的规则描述，第一部分的字符可以少于给定的数量，其余部分皆为 2 个字符。
```

**提示:**

- `1 <= s.length <= 105`
- `s` 只包含字母、数字和破折号 `'-'`.
- `1 <= k <= 104`

### 参考题解

1. [官解](https://leetcode.cn/problems/license-key-formatting/solutions/1029860/mi-yao-ge-shi-hua-by-leetcode-solution-xnae)

### 思路

==:star: **核心思路： 倒序遍历取出符合的字符尾加到res + reverse   **:star:==

**:question:   problems:** 

1. 为什么不能用快慢双指针倒序遍历，原地修改字符串？

    反正很复杂，要考虑很多，给我写崩溃了老铁。

**:small_red_triangle_down: steps: **

1.  我们可以从字符串 s 的末尾开始往前取出字符构建新的字符串 ans。每次取出字符时首先判断该字符是否为破折号，
    - 如果为破折号则跳过；
    - 否则将当前的字符计数 cnt 加 1 ，同时检查如果当前字符为小写字母则将其转化为大写字母，将当前字符加入到字符串 ans 的末尾。对字符进行计数时，每隔 k 个字符就在字符串 ans 中添加一个破折号。
2.  处理特殊情况，字符串 ans 的最后一个字符为破折号则将其去掉。
3.  反转 ans 即为返回结果。

### 代码

```c++
string licenseKeyFormatting(string s, int k) {
    int n = s.size(), cnt = 0;
    string res;
    for (int i = n - 1; i >= 0; --i) {
        if (s[i] == '-') continue;
        res += toupper(s[i]);//如果是小写字母则会转换为大写
        cnt++;
        if (cnt % k == 0) res += '-';
    }
    if (res.size() > 0 && res[res.size() - 1] == '-') res.pop_back();
    //判断末尾字符是否为'-'也可以直接用res.back()取到末尾字符。res.size() > 0 也可以写成!result.empty()
    reverse(res.begin(), res.end());
    return res;
}
```

### 复杂度分析

- 时间复杂度：O(n)

    遍历取s字符是O(n)，最后reverse也是O(n)  

- 空间复杂度：O(n)。

## [6. Z 字形变换](https://leetcode.cn/problems/zigzag-conversion/)

### **题意**

将一个给定字符串 `s` 根据给定的行数 `numRows` ，以从上往下、从左到右进行 Z 字形排列。

比如输入字符串为 `"PAYPALISHIRING"` 行数为 `3` 时，排列如下：

```
P   A   H   N
A P L S I I G
Y   I   R
```

之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：`"PAHNAPLSIIGYIR"`。

请你实现这个将字符串进行指定行数变换的函数：

```
string convert(string s, int numRows);
```

**示例 1：**

```
输入：s = "PAYPALISHIRING", numRows = 3
输出："PAHNAPLSIIGYIR"
```

**示例 2：**

```
输入：s = "PAYPALISHIRING", numRows = 4
输出："PINALSIGYAHRPI"
解释：
P     I    N
A   L S  I G
Y A   H R
P     I
```

**示例 3：**

```
输入：s = "A", numRows = 1
输出："A"
```

**提示：**

- `1 <= s.length <= 1000`
- `s` 由英文字母（小写和大写）、`','` 和 `'.'` 组成
- `1 <= numRows <= 1000`

### 参考题解

1. [K神](https://leetcode.cn/problems/zigzag-conversion/solutions/21610/zzi-xing-bian-huan-by-jyd)

### 思路

==:star: **核心思路：flag + 取反   **:star:==

想到了就很简单，想不到就emmmm....硬想

**:key:  key：**

- 注意到s[i]在N字形中对应所处的行号是递增递减交替的，每当到Z字的拐点时就从递增变为递减或递减变为递增，因此我们需要一个flag来表示遍历s时行号是递增还是递减，并适时地对其取反

**:small_red_triangle_down: steps: **

1.  初始化要把s中字符装进Z字的vector，每个vector是Z中的一行
2.  顺序遍历s
    1.  将ch填入对应行rows[i]中
    2.  如果当前处于Z的拐点则让flag取反
    3.  更新当前字符对应的行索引 `row += flag;`


### 代码

```c++
string convert(string s, int numRows) {
    if (numRows <= 1) return s;
    int n = s.size();
    vector<string> rows(numRows);
    int row = 0, flag = -1;
    for (auto ch : s) {
        rows[row] += ch;
        if (row == 0 || row == numRows - 1) flag = -flag;
        row += flag;
    }
    string ans;
    for (const string &str : rows) ans += str;
    return ans;
}
```

### 复杂度分析

- 时间复杂度：O(n)  

- 空间复杂度：O(n)

## **[68. 文本左右对齐](https://leetcode.cn/problems/text-justification/)**

### **题意**

给定一个单词数组 `words` 和一个长度 `maxWidth` ，重新排版单词，使其成为每行恰好有 `maxWidth` 个字符，且左右两端对齐的文本。

你应该使用 “**贪心算法**” 来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格 `' '` 填充，使得每行恰好有 *maxWidth* 个字符。

要求尽可能均匀分配单词间的空格数量。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。

文本的最后一行应为左对齐，且单词之间不插入**额外的** 空格。

**注意:**

- 单词是指由非空格字符组成的字符序列。
- 每个单词的长度大于 0，小于等于 *maxWidth*。
- 输入单词数组 `words` 至少包含一个单词。

**示例 1:**

```
输入: words = ["This", "is", "an", "example", "of", "text", "justification."], maxWidth = 16
输出:
[
   "This    is    an",
   "example  of text",
   "justification.  "
]
```

**示例 2:**

```
输入:words = ["What","must","be","acknowledgment","shall","be"], maxWidth = 16
输出:
[
  "What   must   be",
  "acknowledgment  ",
  "shall be        "
]
解释: 注意最后一行的格式应为 "shall be    " 而不是 "shall     be",
     因为最后一行应为左对齐，而不是左右两端对齐。       
     第二行同样为左对齐，这是因为这行只包含一个单词。
```

**示例 3:**

```
输入:words = ["Science","is","what","we","understand","well","enough","to","explain","to","a","computer.","Art","is","everything","else","we","do"]，maxWidth = 20
输出:
[
  "Science  is  what we",
  "understand      well",
  "enough to explain to",
  "a  computer.  Art is",
  "everything  else  we",
  "do                  "
]
```

**提示:**

- `1 <= words.length <= 300`
- `1 <= words[i].length <= 20`
- `words[i]` 由小写英文字母和符号组成
- `1 <= maxWidth <= 100`
- `words[i].length <= maxWidth`

### 参考题解

1. [官解](https://leetcode.cn/problems/text-justification/solutions/986756/wen-ben-zuo-you-dui-qi-by-leetcode-solut-dyeg)

### 思路

==:star: **核心思路： 快慢指针，剩下的就是想清楚处理逻辑了   **:star:==

**:key:  key：**

- 分析题意知，每一行可能的情况有两种：

    1. 若为最后一行或者该行只能放下一个单词，则左对齐，多余空格填在末尾。

    2. 其余为一般情况，就不是左对齐而是两端对齐了，也就是我们需要将所有空格均匀分配在单词之间，末尾不能有空格。
        - 因此需要计算：该行的单词个数`wordCnt`、总空格数`spaceCnt`、单词间平均空格数 `avgSpace`、平均之后多出来的空格数`extraSpace`
        - 由于`spaceCnt = (wordCnt- 1) * avg + extra` ，即总空格数 =（单词间隔数 * 单词间平均空格数）+ 平均后多出来的空格数。因此，`avg = spaceCnt / (wordCnt - 1)`，`extra = spaceCnt % (wordCnt  - 1)`
        - 而平均之后多出来的空格数`extraSpace`要分别拿一个添到前extraSpace个单词之间。因此前extraSpace个单词之间要填充 avg+1 个空格，之后的单词之间要填充 avg 个空格

**:small_red_triangle_down: steps: **

循环遍历words，一次循环处理一行。慢指针 i 始终指向当前行的行首，快指针 j 用来寻找要装入这一行的单词

1.  初始化：用快指针 j 给慢指针 i 初始化，初始化当前行的单词总字符数 len
2.  j 不断向后遍历，寻找要装入这一行的单词。退出循环时 j 指向下一行的第一个单词，也是这一行的最后一个单词的后一个位置
3.  如果此时 j 指向words.size()，说明 i 到 j - 1的这一行就是最后一行，最后一行的处理原则是：左对齐，多余空格填到末尾
    1.  用单空格拼接从 i 到 j - 1的单词
    2.  尾插多余空格组成的字符串
    3.  将该行字符串尾插到结果，并return

4.  计算该行的单词数`wordCnt`和空格数`spaceCnt`，以处理【该行只有一个单词】 和 【该行不为最后一行且有多个单词】的这两种情况
5.  如果这一行只有一个单词，则该行的处理原则是：左对齐，多余空格填到末尾
    1.  拼接该单词和其余空格
    2.  将该行字符串尾插到结果

6.  到这里就只剩下一种情况：当前行不为最后一行且有多个单词，则该行的处理原则是：所有空格均匀分配在单词之间，末尾不能有空格
    1.  计算：单词间平均空格数 `avgSpace`、平均之后多出来的空格数`extraSpace`
    2.  用avgSpace+1个空格组成的字符串，拼接前extraSpace个单词，得到s1
    3.  用avgSpace个空格组成的字符串，拼接之后的单词，得到s2
    4.  将该行字符串` s = s1 + avgSpace + s2`尾插到结果


### 代码

#### 带注释的版本

```c++
class Solution {
    string blank(int n) {// 返回由n个空格组成的字符串
        return string(n, ' ');
    }
    // 用sep(一个或多个空格组成的字符串)拼接words[i,j)之间的单词，并返回结果字符串
    string join(vector<string> &words, int i, int j, string sep) {
        string s = words[i++];//在words[i]的基础上进行拼接
        while (i < j) s += sep + words[i++];
        return s;
    }

public:
    vector<string> fullJustify(vector<string> &words, int maxWidth) {
        vector<string> ans;
        int j = 0, n = words.size();
        while (true) {
            // i,j分别是慢指针和快指针，i始终指向当前行的第一个单词，j用来寻找该行能放哪些单词
            // 给当前行的相关变量进行初始化(指向行首单词的 i 以及该行单词的总字符数 len )
            int i = j; //上一次循环结束后 j 指向下一行也就是当前行的第一个单词，因此在这一次循环一开始就给 i 初始化
            int len = 0; //这一行【单词】的总字符数

            // 循环确定当前行可以装入多少单词，注意单词之间应至少有一个空格
            while (j < n && len + words[j].size() + j - i <= maxWidth) len += words[j++].size();
            // len + words[j].size() + j - i ：目前该行所有已装入单词的字符数 + j 当前指向单词的字符数 + 单词间至少需要的空格数
            // j - i : 从i到j有 j-i+1个单词，单词之间的间隔数为 j-i ，由于单词间至少要有一个空格，因此j-i+1个单词之间至少需要 j-i个空格
            // 循环退出后 j 指向当前行最后一个单词的后一个位置（也即下一行的第一个单词）
            // 该行单词在words中的索引范围是[i,j)

            // 当前行是最后一行，则: 单词左对齐，且单词之间应只有一个空格，在行末填充剩余空格
            if (j == n) {
                string s = join(words, i, n, " ");//用单空格拼接words[i,j)之间的单词
                ans.emplace_back(s + blank(maxWidth - s.size()));//在末尾拼接剩余空格后，将该行字符串尾插进结果
                return ans;
            }
            
            //计算该行的单词数和空格数
            int wordCnt = j - i;//在下标[i,j)中有j-1-i+1 = j-i个单词
            int spaceCnt = maxWidth - len;//该行的总空格数

            // 若当前行只有一个单词，则: 该单词左对齐，在行末填充剩余空格
            if (wordCnt == 1) {
                ans.emplace_back(words[i] + blank(spaceCnt));
                continue;
            }

            // 若当前行不只一个单词，计算
            int avgSpace = spaceCnt / (wordCnt - 1);//单词间平均空格数
            int extraSpace = spaceCnt % (wordCnt - 1);//平均之后多出来的空格（要平均填在前extraSpaces个单词之间，即从下标 i 到 i+extraSpace 的单词（间隔数为extraSpace），也就是说前extraSpaces个单词需要比平均的avg还多填一个）
            string s1 = join(words, i, i + extraSpace + 1, blank(avgSpace + 1)); //前extraSpace个单词之间填的空格数要比平均的avg还额外多一个空格
            //用avgSpace+1个空格组成的字符串，拼接words[i, i + extraSpace + 1)之间的单词
            string s2 = join(words, i + extraSpace + 1, j, blank(avgSpace)); // 拼接其余单词
            //用avgSpace个空格组成的字符串，拼接words[i + extraSpace + 1, j)之间的单词
            ans.emplace_back(s1 + blank(avgSpace) + s2);
        }
    }
};
```

#### 不带注释的版本

```c++
class Solution {
    // 返回由n个空格组成的字符串
    string blank(int n) {
        return string(n, ' ');
    }
    // 用sep(一个或多个空格组成的字符串)拼接words[i,j)之间的单词，并返回结果字符串
    string join(vector<string> &words, int i, int j, string sep) {
        string s = words[i++]; 
        while (i < j) s += sep + words[i++];
        return s;
    }

public:
    vector<string> fullJustify(vector<string> &words, int maxWidth) {
        vector<string> ans;
        int j = 0, n = words.size();
        while (true) {
            int i = j;  
            int len = 0;  

            while (j < n && len + words[j].size() + j - i <= maxWidth) len += words[j++].size();

            if (j == n) {
                string s = join(words, i, n, " "); 
                ans.emplace_back(s + blank(maxWidth - s.size())); 
                return ans;
            }
            
            int wordCnt = j - i; 
            int spaceCnt = maxWidth - len; 

            if (wordCnt == 1) {
                ans.emplace_back(words[i] + blank(spaceCnt));
                continue;
            }

            int avgSpace = spaceCnt / (wordCnt - 1); 
            int extraSpace = spaceCnt % (wordCnt - 1);
            string s1 = join(words, i, i + extraSpace + 1, blank(avgSpace + 1));  
            string s2 = join(words, i + extraSpace + 1, j, blank(avgSpace));
            ans.emplace_back(s1 + blank(avgSpace) + s2);
        }
    }
};
```

