## 目录

[TOC]



## 💛总结

- 设计链表--插删查
- 虚拟头结点
- 双指针
- 反转链表
- 环

## :car:[707. 设计链表](https://leetcode.cn/problems/design-linked-list/)

```c++
class MyLinkedList {
public:
    struct Listnode { //定义链表结点结构体
        int val;
        Listnode* next;
        //三个构造函数
        Listnode(): val(0), next(nullptr) {}
        Listnode(int x): val(x), next(nullptr) {}
        Listnode(int x, Listnode* p): val(x), next(p) {}
    };
    int len;//链表长度
    Listnode* dummyhead;////虚拟头结点
        
    MyLinkedList() {
        len = 0;
        dummyhead = new Listnode(0);//实例化虚拟头结点
    }
    
    int get(int index) {
        if (index > len - 1 || index < 0)  return -1;//下标无效
        //下面就是下标有效的情况
        Listnode* p = dummyhead->next;
        //从下标为0的dummmyhead->next到下标为index的节点需要p = p->next index次
        while (index--) p = p->next;//计数从index到1共index次
        return p->val;
    }
    
    void addAtHead(int val) {
        Listnode* head = new Listnode(val);
        head->next = dummyhead->next;//新头结点接管旧头结点以及其后所有
        dummyhead->next = head;
        ++len;
    }
    
    void addAtTail(int val) {
        Listnode* p = dummyhead;//用于遍历
        Listnode* end = new Listnode(val);
        while (p->next) p = p->next;
        p->next = end;
        ++len;
    }
    
    void addAtIndex(int index, int val) {
        if (index > len || index < 0) return;//越界
        Listnode* ins = new Listnode(val);
        Listnode* p = dummyhead;//用于遍历
        while (index--) p = p->next;//操作index次, p从dummyhead(-1)指到下标为index-1的节点
        ins->next = p->next;
        p->next = ins;
        ++len;
    }
    
    void deleteAtIndex(int index) {
        if (index > len - 1 || index < 0)  return;//下标无效
        Listnode* p = dummyhead;//遍历
        while (index--) p = p->next;//操作index次, p从dummyhead(-1)指到下标为index-1的节点
        Listnode* tmp = p->next;
        p->next = p->next->next;
        delete tmp;
        tmp = nullptr;//delete后记得置空
        --len;
    }
};
```

## :fire:[206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)   

### 题意

给你单链表的头节点 `head` , 请你反转链表, 并返回反转后的链表。

**示例 1：**

![img](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202402081313999.jpeg)

```
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
```

### 迭代

```c++
ListNode* reverseList(ListNode* head) {
    // tmp = 要反转的结点cur的next; 然后反转cur; 之后cur = tmp, 重复上述步骤
    ListNode* pre = nullptr; 
    ListNode* cur = head;
    while (cur) {
        ListNode* tmp = cur->next;
        cur->next = pre;
        pre = cur;
        cur = tmp;
    }
    return pre;
}
```

复杂度分析

- 时间复杂度：O(n)  

- 空间复杂度：O(1)

### 递归

```c++
ListNode* reverse(ListNode* cur, ListNode* pre) {
    // 2.递归结束的条件
    if (cur == nullptr) return pre;
    // 3.单层递归的逻辑：
    // 暂存要反转的结点的next为tmp，然后反转一个结点，反转后该节点变为pre，tmp变为cur
    ListNode* tmp = cur->next;
    cur->next = pre; 
    // pre = cur;
    // cur = tmp;
    // return reverse(cur, pre);
    //上面三步可以直接合为一步
    return reverse(tmp, cur);
}
ListNode* reverseList(ListNode* head) {
    return reverse(head, nullptr);
}
```

**复杂度分析**

- 时间复杂度：O(n)  

- 空间复杂度：O(n)

## :fire:[92. 反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii/)

### **题意**

给你单链表的头指针 `head` 和两个整数 `left` 和 `right` ，其中 `left <= right` 。请你反转从位置 `left` 到位置 `right` 的链表节点，返回 **反转后的链表** 。

**示例 1：**

![img](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202405161310118.jpeg)

```
输入：head = [1,2,3,4,5], left = 2, right = 4
输出：[1,4,3,2,5]
```

**示例 2：**

```
输入：head = [5], left = 1, right = 1
输出：[5]
```

**提示：**

- 链表中节点数目为 `n`
- `1 <= n <= 500`
- `-500 <= Node.val <= 500`
- `1 <= left <= right <= n`

**进阶：** 你可以使用一趟扫描完成反转吗？

### 法一

==:star: **核心思路：   **:star:==

**:key:  key：**

- 关键就是最后一步接上去的时候! 不能先改变frontLast的next! 否则我们想要的原来的frontLast->next就丢失了!

**:question:   problems:** 

- 为什么需要虚拟头节点？

:heavy_check_mark:  **answer:** 

- 因为当开始反转的结点是head结点时，如果不加虚拟头节点那么frontLast就无法表示了。

**:small_red_triangle_down:  steps: **

1.  让两个指针走到反转区间的两端
2.  反转链表
3.  将反转部分接上

### 代码

```cpp
ListNode* reverseBetween(ListNode* head, int left, int right) {
/*
    frontEnd -> [i->···->j] -> backStart
    frontEnd -> [j->···->i] -> backStart
    用cur和prev反转结点，当cur==backStart时，停止反转，然后将反转区间接回去: frontEnd->next后面要接backStart，frontEnd后面要接prev 
*/ 
    ListNode* dummyhead = new ListNode(0, head);
    // 1. 找到frontEnd和backStart的位置
    ListNode* frontEnd = dummyhead; //处在下标0的位置
    for (int i = 0; i < left - 1; ++i) { //下标i==left-1时就不能进入循环了
        frontEnd = frontEnd->next;
    }
    ListNode* backStart = frontEnd; 
    for (int i = left - 1; i < right + 1; ++i) {//i==right+1时就不能进入循环了
        backStart = backStart->next;
    } 
    // 2. 反转区间 
    ListNode* prev = reverse(frontEnd->next, nullptr, backStart);
    //3. 将反转部分接上 (这两行的顺序不能变)
    frontEnd->next->next = backStart;
    frontEnd->next = prev; 
    
    ListNode* ans = dummyhead->next; 
    delete dummyhead;
    dummyhead = nullptr;
    return ans;
}
ListNode* reverse(ListNode* cur, ListNode* prev, ListNode* backStart) {
    if (cur == backStart) {
        return prev;
    }
    ListNode* tmp = cur->next;
    cur->next = prev;
    return reverse(tmp, cur, backStart);
}
```

**复杂度分析**

- 时间复杂度：O(n). 两次遍历  

- 空间复杂度：O(1)

### 法二

==:star: **核心思路：头插法  **==  进阶解法, 一趟扫描



#### 复杂度分析

- 时间复杂度：O(n). 一次遍历  

- 空间复杂度：O(1)

## :fire:[25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)

### 题意



[常见的链表翻转，字节跳动加了个条件，面试者高呼「我太难了」| 图解算法 (qq.com)](https://mp.weixin.qq.com/s?__biz=MzIxNjc0ODExMA%3D%3D&chksm=9785150ea0f29c18526d17cefccce47720e8942cb2c96d9b0cd22544385ec17c50073326d9f4&idx=1&mid=2247486511&scene=21&sn=26d1ca6342a05dea1cb885da7a4c5ddc#wechat_redirect)

==:star: **核心思路： 双指针  **:star:==



### 代码

```cpp
```



## [:fire: 141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/)

### **题意**

给你一个链表的头节点 `head` , 判断链表中是否有环。存在返回 `true` 。 否则返回 `false` 。

 提示：链表中节点的数目范围是 `[0, 104]`

==:star: **核心思路： 双指针  **:star:==

注意：

1. 链表的题要注意开头都要特判！！！
2. 循环条件. 第n次把循环条件写成`while (slow != fast && fast->next && fast)`了...

### 代码

```c++
bool hasCycle(ListNode *head) {
    // 链表的题要注意开头都要特判！！！
    if (!head || !head->next) return false;
    ListNode *slow = head, *fast = head; 
    //芙拉! 一开始slow就==fast, 循环条件怎么能是slow != fast啊！！！
    //while (slow != fast && fast->next && fast) 或者写成 while (slow && fast->next) 都是错误的
    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast) return true;
    }
    return false;
}
```

### 复杂度分析

- 时间复杂度：O(n)  

- 空间复杂度：O(1)

## [:fire: 142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

### **题意**

给定一个链表的头节点  `head` , **返回链表开始入环的第一个节点**。 *如果链表无环, 则返回 `null`。*

### 法一

哈希

**代码**

```c++
 ListNode *detectCycle(ListNode *head) {
    // 法一、用哈希存放遍历过的结点, 当遍历到哈希中存在的结点时就说明有环
    unordered_set<ListNode*> visited;
    while (head != nullptr) {
        if (visited.count(head)) return head;
        visited.insert(head);
        head = head->next;
    }
    return nullptr;
 }
```

### 法二

==:star: **核心思路： 双指针  **:star:==

**:question:   problems:** 

1. 怎样判断是否成环？ 
2. 怎样找到入环的第一个结点？

:heavy_check_mark:  **answer:** 

![SmartSelect_20240126_225643_Samsung Notes](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202402091057729.jpeg)

### 代码

```c++
ListNode *detectCycle(ListNode *head) {
/*
    先用快慢双指针判断链表是否有环，
    如果有环，那么再接着找环入口：
    设链头走x步到环入口，快慢双指针相遇在A点，从环入口到A点需要走y步，一圈为y+z步
    相遇时，慢指针走了x+y+T1圈，快指针走了x+y+T2圈，它俩走的步数是两倍关系
    2(x+y+T1圈) = x+y+T2圈 => x+y=(T2-2T1)圈，x+y=n(y+z), x+y=(n-1)(y+z)+(y+z), x=(n-1)(y+z)+z, x=(n-1)圈+z，也就是说，走x步相当于走N圈+z步
    因此如果让两个指针，分别从链头和相遇点A开始走，它们相遇的点就是环入口（由于x=(n-1)圈+z，它俩各自走了 x 和 (n-1)圈+z 步时就会相遇）
*/
    ListNode* slow = head;
    ListNode* fast = head;
    //因为一开始slow就==fast，因此不能写成while (slow != fast && fast->next && fast) 
    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast) {
            ListNode* p = head;
            while (p != slow) {
                p = p->next;
                slow = slow->next;
            }
            return p;
        }
    }
    return nullptr;
}
```

为什么找环入口的逻辑必须写while里？不能写在外面？

如果写在外面则是：

```cpp
ListNode *detectCycle(ListNode *head) {
    ListNode* slow = head;
    ListNode* fast = head;
    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast) break;
    }
    if (slow != fast) {
        return nullptr;
    }
    ListNode* p = head;
    while (p != slow) {
        p = p->next;
        slow = slow->next;
    }
    return p;
}
```

那么当head =[1]，无环时，不会进while循环，因此slow和fast仍为初始值，它俩相等，不会返回nullptr。而本来无环是应该返回nullptr的。



##  :fire:[146. LRU 缓存](https://leetcode.cn/problems/lru-cache/)

### **题意**

请你设计并实现一个满足 [LRU (最近最少使用) 缓存](https://baike.baidu.com/item/LRU) 约束的数据结构。

实现 `LRUCache` 类：

- `LRUCache(int capacity)` 以 **正整数** 作为容量 `capacity` 初始化 LRU 缓存
- `int get(int key)` 如果关键字 `key` 存在于缓存中, 则返回关键字的值, 否则返回 `-1` 。
- `void put(int key, int value)` 如果关键字 `key` 已经存在, 则变更其数据值 `value` ；如果不存在, 则向缓存中插入该组 `key-value` 。如果插入操作导致关键字数量超过 `capacity` , 则应该 **逐出** 最久未使用的关键字。

函数 `get` 和 `put` 必须以 `O(1)` 的平均时间复杂度运行。

**示例：**

```
输入
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
输出
[null, null, null, 1, null, -1, null, -1, 3, 4]

解释
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // 缓存是 {1=1}
lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}
lRUCache.get(1);    // 返回 1
lRUCache.put(3, 3); // 该操作会使得关键字 2 作废, 缓存是 {1=1, 3=3}
lRUCache.get(2);    // 返回 -1 (未找到)
lRUCache.put(4, 4); // 该操作会使得关键字 1 作废, 缓存是 {4=4, 3=3}
lRUCache.get(1);    // 返回 -1 (未找到)
lRUCache.get(3);    // 返回 3
lRUCache.get(4);    // 返回 4
```

**提示：**

- `1 <= capacity <= 3000`
- `0 <= key <= 10000`
- `0 <= value <= 105`
- 最多调用 `2 * 105` 次 `get` 和 `put`

### 参考题解

1. [【字节一面】 LRU Cache 实现剖析]( https://www.bilibili.com/video/BV1hp4y1x7MH/?share_source=copy_web&vd_source=8086e0fb4ccc0ee9410370076867092c)
1. [官解](https://leetcode.cn/problems/lru-cache/solutions/259678/lruhuan-cun-ji-zhi-by-leetcode-solution)

### 思路

==:star: **核心思路：哈希表 + 双向链表**:star:==

#### 1. 确定选用什么数据结构

由题，

- LRUCache维护一个cap容量，如果添加元素后size>cap，就需要逐出最久未使用的元素。
- LRUCache有两个时间复杂度为O(1)的成员函数：get()和put()
    - get()中的逻辑是：
        - 根据key获取value，这个操作要想时间复杂度为O(1)，那么就需要用到unordered_map
        - 另外还有一个重要但容易遗漏的点：如果key存在于缓存中，那么get(key)之后，key就变为了最近使用的关键字。
    - put()中的逻辑是：
        - 如果key存在，改变其value，然后将key变为最近使用的；
        - 否则，向缓存中插入key-value，然后将key变为最近使用的，如果put后LRUCache的size>cap，那么就需要将最久未使用的关键字逐出。
    - 从这两个函数的逻辑我们就可以知道缓存应该选用什么结构了：
        - 除了要能快速根据键获取value之外，缓存选用的结构要能够体现关键字是最近使用还是最久未使用，因为我们需要在get以及put后，将操作的关键字变为最近使用的，以及如果put后LRUCache的size>cap，那就需要将最久未使用的关键字逐出。
        - 因此，关键字还需要按序组织，这个顺序就是从：最近使用->最久未使用。
        - 考虑到插入删除所需的时间复杂度，我们选用链表而不是数组。
        - 那用单向链表还是双向循环链表？
        - 双向循环链表！因为我们不仅需要操作最近使用的关键字，还需要操作最久未使用的关键字。如果是单向的，那么我们只能操作最近使用的关键字，最久未使用的关键字需要遍历到链表结尾才能获取到。而如果是双向循环的，最久未使用的关键字就能直接根据尾结点得到，这个时间就是O(1)的。
        - 结合前面说的unordered_map，我们就能确定LRUCache选用的结构是unordered_map+双向循环链表，这样LRUCache查找插入删除的时间复杂度都是O(1)。
        - 这两个结构怎么联系起来呢？unordered_map的key就是关键字key，value是key对应的存在于双向循环链表中的结点。双向循环链表每个结点存放了关键字key和它的value。

![image-20240211084944957](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202402110849032.png)

#### 2. get和put的具体实现

确定了LRUCache选用的结构，我们再重新梳理一下get()和put()的逻辑。

- get的逻辑是：
    - 根据key从unordered_map中获取key对应在链表中的结点，如果key存在于map中，根据结点获取value，之后，将key变为最近使用的关键字（将原来key对应在链表中的结点删除，再重新new一个结点头插到链表，注意需要同步在map中删除添加）。
        - 为啥“将key变为最近使用的关键字”，需要同步把key从map中删除再添加？不是多此一举吗？只操作链表不就可以了吗？
        - 不可以！因为如果只把key对应在链表中的结点删除，那么此时map[key]指向哪呢？？因此，在结点从链表中删除的同时，也要把map中的key-value删除。头插的时候，也要将key-value添加到map中。
- put的逻辑是：
    - 判断key是否存在于unordered_map：
        - 如果key存在，将其对应结点从链表中删除，**同时要在unordered_map删除键值对**，然后用key和新的value重新new一个结点头插到链表，**同时要在unordered_map添加键值对**。
        - 否则，key不存在，将key-value头插到链表中，同时要在unordered_map添加键值对，如果put后LRUCache的size>cap，那么就需要将最久未使用的关键字逐出，同时要在unordered_map删除键值对。

### 代码

```c++
struct Node { //链表结点
    int key, value;
    Node *prev, *next;
    Node(): key(-1), value(-1), prev(nullptr), next(nullptr) {}
    Node(int x, int y) : key(x), value(y), prev(nullptr), next(nullptr) {}
};
struct DoubleLinkedList { //双向循环链表 
    Node *head, *tail; 
    // head: recently used 最近使用
    // tail: LRU (least recently used) 最近最久未使用

    DoubleLinkedList() : head(new Node()), tail(new Node()){
        head->next = tail;
        tail->prev = head;
    }
    // 头插 
    void insertHead(Node* newNode) {
        // 先将newNode的两个指针接在head和head->next之间
        newNode->prev = head;
        newNode->next = head->next;
        // 然后再将head的next以及head->next的prev接上newNode
        head->next->prev = newNode;
        head->next = newNode;
    }
    // 删除链表中的结点node
    int deleteNode(Node* node) {
        // 返回int是尾删函数需要返回int
        int _key = node->key;
        node->next->prev = node->prev;
        node->prev->next = node->next;
        delete node;
        node = nullptr;
        return _key;
    }
    // 尾删
    int deleteTail() {
        // 需要返回int是因为尾删掉的结点也需要在哈希map中删掉
        // 如果链表中就只有head和tail两个哨兵结点，直接返回
        if (tail->prev == head) return -1;
        return deleteNode(tail->prev);
    }
};
class LRUCache {  //结合了哈希map和双向循环链表
private:
    DoubleLinkedList cache; //从链头到链尾是 最近被使用的节点-->最久没被使用的节点
    unordered_map<int, Node*> umap;
    int cap;
public:
    LRUCache(int capacity) : cap(capacity) {}
    
    int get(int key) {
        if (umap.count(key) == 0) {
           return -1;
        } 
        Node* node = new Node(key, umap[key]->value);
        // 从链表中删除原来key对应的结点，然后将其头插到链表
        // 注意！map中也要同步删除插入
        cache.deleteNode(umap[key]);
        umap.erase(key);
        // 上面这两句不能调换位置，为什么？
        // 因为如果先调用umap.erase(key)，那就会导致key被删除，umap[key]就不能用了
        cache.insertHead(node);
        umap[key] = node;
        
        return node->value;
    }
    
    void put(int key, int value) {
        if (umap.count(key)) {
            cache.deleteNode(umap[key]);
            umap.erase(key);
        } 
        Node* node = new Node(key, value);
        cache.insertHead(node);
        umap[key] = node;
        if (umap.size() > cap) { 
            int _key = cache.deleteTail();
            umap.erase(_key);
        }
    }
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache* obj = new LRUCache(capacity);
 * int param_1 = obj->get(key);
 * obj->put(key,value);
 */
```

### 复杂度分析

- 时间复杂度：O(1) ，对于 put 和 get 都是 O(1)。 
- 空间复杂度：O(capacity)，因为哈希表和双向链表最多存储 capacity+1个元素

## [:fire: 21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)

### **题意**

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

**提示：**

- 两个链表的节点数目范围是 `[0, 50]`
- `-100 <= Node.val <= 100`
- `l1` 和 `l2` 均按 **非递减顺序** 排列

### 参考题解

1. 递归
    1. [腐烂的橘子](https://leetcode.cn/problems/merge-two-sorted-lists/solutions/103891/yi-kan-jiu-hui-yi-xie-jiu-fei-xiang-jie-di-gui-by-)
    1. [评论](https://leetcode.cn/problems/merge-two-sorted-lists/solutions/103891/yi-kan-jiu-hui-yi-xie-jiu-fei-xiang-jie-di-gui-by-/comments/1228656) ==递归思路！优秀！==

1. 迭代：[官解](https://leetcode.cn/problems/merge-two-sorted-lists/solutions/226408/he-bing-liang-ge-you-xu-lian-biao-by-leetcode-solu)

### 递归

```c++
ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
    // 递归出口
    if (!list1 || !list2) return list1 ? list1 : list2;
    // 单层递归要做啥事？要merge L1,L2
    // 如果L1第一个元素小于L2, 则这个大项目要交给L1负责
    if (list1->val <= list2->val) {
        // L1先接过下级员工干完的活: mergeTwoLists(list1->next, list2)
        // 然后把自己干的活附上去: list1->next = ()
        list1->next = mergeTwoLists(list1->next, list2);
        // 最后将任务结果提交给上级
        return list1;
    }
    // 否则, 这个大项目交给L2负责
    list2->next = mergeTwoLists(list1, list2->next);
    return list2;
}
```

**复杂度分析**

- 时间复杂度：O(n + m)  

- 空间复杂度：O(n + m)

### 迭代

- 设一个虚拟头节点, 让tail指针也指向它，
- 比较list1和list2指向的结点值的大小，谁小谁就接在tail后面，如果list1小，更新list1为list1->next
- 循环直到遍历到其中一个链表的末尾，把另一条没遍历完的链表接上。

![image-20240221200322546](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202402212003767.png)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode* dummyHead = new ListNode();
        ListNode* tail = dummyHead;
        while (list1 && list2) {
            if (list1->val < list2->val) {
                tail->next = list1;
                list1 = list1->next;
            } else {
                tail->next = list2;
                list2 = list2->next;
            }
            tail = tail->next;
        }
        tail->next = list1 ? list1 : list2;
        ListNode* head = dummyHead->next;
        delete dummyHead;
        dummyHead = nullptr;
        return head;
    }
};
```

**复杂度分析**

- 时间复杂度：O(n + m)  

- 空间复杂度：O(1)

### Follow Up：合并两个有序链表并去重

待补充。。。





## [:fire:160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

### **题意**

给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null` 。

**注意**，函数返回结果后，链表必须 **保持其原始结构** 。

**示例 1：**

[![img](https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png)

```
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
输出：Intersected at '8'
解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。
在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
— 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。
```

**提示：**

- `listA` 中节点数目为 `m`
- `listB` 中节点数目为 `n`
- `1 <= m, n <= 3 * 104`
- `1 <= Node.val <= 105`
- `0 <= skipA <= m`
- `0 <= skipB <= n`
- 如果 `listA` 和 `listB` 没有交点，`intersectVal` 为 `0`
- 如果 `listA` 和 `listB` 有交点，`intersectVal == listA[skipA] == listB[skipB]`

**进阶：**你能否设计一个时间复杂度 `O(m + n)` 、仅用 `O(1)` 内存的解决方案？

### 思路

==:star: **核心思路：双指针 + 数学   **:star:==

![image-20240226223915806](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202402262239913.png)

**代码**

关键是循环条件

```c++
ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
/*
    若两链表相交，设他们相交在某个结点处，headA走a步到那，headB走b步到那，
    之后它们都走c步到达链表末尾.
    那么链表A从头走到尾需要a+c步，链表B从头走到尾需要b+c步，
    如果HeadA走完链表A之后再走链表B走b步，总共走a+c+b步，
    如果HeadB走完链表B之后再走链表A走a步，总共走b+c+a步，
    此时headA与headB走的步数相同，它俩应当相遇在非空结点。
    如果它俩都指向了Null，就说明两链表不相交
*/
    ListNode* pA = headA;
    ListNode* pB = headB;
    while (pA != pB) {
        pA = pA ? pA->next : headB;
        pB = pB ? pB->next : headA;
        // 如果相交那么循环会因为pa==pb(不为空)结束
        // 如果不相交那么a走完A和B同时也b走完A和B，pa和pb都等于nullptr
    }
    return pA;
}
```

**复杂度分析**

- 时间复杂度：O(n + m)  

- 空间复杂度：O(1)

## :fire:[143. 重排链表](https://leetcode.cn/problems/reorder-list/)

### 题意

给定一个单链表 `L` 的头节点 `head` ，单链表 `L` 表示为：

```
L0 → L1 → … → Ln - 1 → Ln
```

请将其重新排列后变为：

```
L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …
```

不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

 

**示例 1：**

![img](https://pic.leetcode-cn.com/1626420311-PkUiGI-image.png)

```
输入：head = [1,2,3,4]
输出：[1,4,2,3]
```

**示例 2：**

![img](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202405220845288.png)

```
输入：head = [1,2,3,4,5]
输出：[1,5,2,4,3]
```

**提示：**

- 链表的长度范围为 `[1, 5 * 104]`
- `1 <= node.val <= 1000` 

### 法一

==:star: **核心思路：分割链表->反转->合并   **:star:==

```c++
void reorderList(ListNode* head) {
/*
    1. 先找到链表中点，分割链表，（用快慢双指针）
    2. 反转分割下来的后半部分链表
    3. 合并两链表
*/
    // 1 分割，截断
    ListNode* frontback = middlePrevNode(head);//O(n)
    ListNode* cur = frontback->next;
    frontback->next = nullptr;//要截断!
    // 2 反转
    ListNode* p2 = reverse(cur, nullptr);//O(n/2)
    // 3 合并
    // 注意这里合并，不能新建一个结点作为合并后的头节点，然后逐个将两链表的结点接过去
    // 因为按题意，是要在head这条原链表上进行合并的
    ListNode* p1 = head;
    mergeList(p1, p2);//O(n)
} 

ListNode* middlePrevNode(ListNode* head) {
    ListNode* slow = head;
    ListNode* fast = head;
    // 如果不把分割链表的逻辑单独分离出来，那么循环条件也可以是while (fast && fast->next)
    while (fast->next && fast->next->next) {
        slow = slow->next;
        fast = fast->next->next;
    }
    // 1 2 3 4
    //   s f
    // 1 2 3 4 5
    //     s   f
    // 后半部分链表从slow->next开始
    // 返回slow而不是slow->next是因为要截断slow和slow->next
    return slow; 
}

ListNode* reverse(ListNode* cur, ListNode* prev) {
    if (!cur) {
        return prev;
    }
    ListNode* tmp = cur->next;
    cur->next = prev;
    return reverse(tmp, cur);
}

void mergeList(ListNode* p1, ListNode* p2) {
    // 1 2 3
    // |/|/
    // 5 4
    while (p2) {
        ListNode* tmp1 = p1->next;//2 //3
        ListNode* tmp2 = p2->next;//4 //^
        p1->next = p2;//15 //1524
        p2->next = tmp1;//152 //15243
        p1 = tmp1;//2 //3
        p2 = tmp2;//4 //^
    }
}
```

#### 复杂度分析

- 时间复杂度：O(n)

- 空间复杂度：O(1)

### 法二

==:star: **核心思路：用数组或deque模拟   **:star:==

通过把链表放进某结构中，再经过一系列操作重构链表。
重构链表都要注意结尾那步必要操作！

（1）数组模拟
首先遍历一边原链表，将所有的结点都存到数组中
把链表放进数组中，然后通过左右指针法遍历数组，构造链表。

（2）双向队列模拟
首先遍历一边原链表，将所有的结点都存到双端队列中
把链表放进双向队列，然后通过双向队列一前一后弹出数据，来构造新的链表。这种方法比操作数组容易一些，不用双指针模拟一前一后了

#### 代码

##### 数组模拟

```c++
void reorderList(ListNode* head) {
    vector<ListNode*> vec;//把链表放进数组中
    ListNode* cur = head;
    while (cur) {//将链表中指向每个结点的指针都存到vec1中
        vec.push_back(cur);
        cur = cur->next;
    }
    cur = head;
    // 利用左右双指针从第二个开始构造链表
    int i = 1, j = vec.size() - 1;
    for (; i <= j; i++, j--) {
        cur->next = vec[j];
        if (i == j) {//当链长为偶数时，最后一次循环i会==j
            cur = cur->next;//让cur指向最后一个结点
        }
        else {
            cur->next->next = vec[i];
            cur = cur->next->next;//让cur指向最后一个结点
        }
    }
    //前面统一让cur指向重排后的最后一个结点以统一执行末尾置空操作
    cur->next = nullptr; // 注意结尾这步是必要的！
/* 
    因为重构了链表，末尾也要重构，要不然可能死循环。
    假设原来的链表是1,2,3,4,null，重排后的链表就应为1,4,2,3,null。（实际每个结点都有专属的地址，这里为了方便直接用其值表示结点）
    没执行这一步之前，除了最后一个结点外其余结点的next域都重构了，都指向了另外的结点（next里存的地址变了）。
    重排后的最后一个结点(值为3的结点)原来的next域是指向值为4的结点(存的值为4的结点的地址),若没有这一步则依然会指向值为4的那个结点，也就是本来没有环的链表中形成了环。
*/
```

##### 双向队列模拟

```c++
void reorderList(ListNode* head) {
    ListNode* cur = head;
    deque<ListNode*> que;
    while (cur->next) {//从第二个结点开始把链表放进双向队列
        que.push_back(cur->next);//也可以使用C++11的emplace_back()
        cur = cur->next;
    }
    cur = head;
    while (que.size()) {//当que中没有元素(都被用去构造链表了)时循环结束
        cur->next = que.back();//先取后面的
        que.pop_back();
        if (que.size() == 0) {//当链长为偶数时，最后一次循环que中就只剩一个元素了,而上一步已经将这最后一个元素弹出了，因此此时que中没有元素了
            cur = cur->next;
        }
        else {
            cur->next->next = que.front();//再取前面的
            que.pop_front();
            cur = cur->next->next;
        }
    }
    //退出循环后cur都指向最后一个结点
    cur->next = nullptr;//同数组模拟一样，注意结尾给最后一个结点的next域置空
}
```



## [:fire:23. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)

### **题意**

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

**示例 1：**

```
输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6
```

**示例 2：**

```
输入：lists = []
输出：[]
```

**示例 3：**

```
输入：lists = [[]]
输出：[]
```

**提示：**

- `k == lists.length`
- `0 <= k <= 10^4`
- `0 <= lists[i].length <= 500`
- `-10^4 <= lists[i][j] <= 10^4`
- `lists[i]` 按 **升序** 排列
- `lists[i].length` 的总和不超过 `10^4`

### 参考题解

1. [官解](https://leetcode.cn/problems/merge-k-sorted-lists/solutions/219756/he-bing-kge-pai-xu-lian-biao-by-leetcode-solutio-2)

### 法一

暴力：合并两个有序链表。

将每条链表取出来与ans合并（合并两个有序链表），将合并结果返给ans，不断更新ans，最终ans就是所有链表合并后的结果。

```c++
ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
    if (!list1 || !list2) return list1 ? list1 : list2;
    ListNode* head = new ListNode();
    ListNode* cur = head;

    while (list1 && list2) { 
        if (list1->val <= list2->val) {
            cur->next = list1;
            list1 = list1->next;
        } else {
            cur->next = list2;
            list2 = list2->next;
        }
        cur = cur->next;
    } 
    cur->next = list1 ? list1 : list2;
    
    ListNode* ans = head->next;
    delete head;
    head = nullptr; 
    return ans;
}
ListNode* mergeKLists(vector<ListNode*>& lists) {
    ListNode* ans = nullptr;
    for (auto list : lists) {
        ans = mergeTwoLists(ans, list);
    }
    return ans;
}
```

#### 复杂度分析

假设每个链表的最长长度是 n.

- 时间复杂度：O(k^2^n)  

    ![image-20240226230825439](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202402262308498.png)

- 空间复杂度：O(1)

### 法二

==:star: **核心思路： 分治合并  **:star:==

**:question:   problems:** 

1. 为什么mid下取整不能用上取整的分治写法? 即为什么mid下取整时不能写成 `ListNode* L1 = merge(lists, left, mid); ListNode* L2 = merge(lists, mid + 1, right);` ?

:heavy_check_mark:  **answer:** 

1. 如果mid下取整时分治逻辑写成 `ListNode* L1 = merge(lists, left, mid); ListNode* L2 = merge(lists, mid + 1, right);`如下：

![image-20240227124231265](C:\Users\Oscar\AppData\Roaming\Typora\typora-user-images\image-20240227124231265.png)

#### 代码

```c++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        if (!list1 || !list2) return list1 ? list1 : list2;
        ListNode* head = new ListNode();
        ListNode* cur = head;

        while (list1 && list2) { 
            if (list1->val <= list2->val) {
                cur->next = list1;
                list1 = list1->next;
            } else {
                cur->next = list2;
                list2 = list2->next;
            }
            cur = cur->next;
        } 
        cur->next = list1 ? list1 : list2;
        
        ListNode* ans = head->next;
        delete head;
        head = nullptr; 
        return ans;
    }
    ListNode* merge(vector<ListNode*>& lists, int left, int right) {
        // 1.递归参数以及返回值: 需要两个int表示分治区间的两端点
        // 2.递归结束的条件: 分治区间长度为1时,即只有一个链表时
        if (left == right) return lists[left];
        else if (left > right) return nullptr;
        // 3.单层递归做什么事? 先分治(一分为二),再合并
        // 先分治
        int mid = left + (right - left) / 2; 		//mid下取整
        ListNode* L1 = merge(lists, left, mid);
        ListNode* L2 = merge(lists, mid + 1, right); 
        
        // int mid = left + (right - left + 1) / 2; // mid上取整
        // ListNode* L1 = merge(lists, left, mid - 1);
        // ListNode* L2 = merge(lists, mid, right);
        
        // 再合并
        return mergeTwoLists(L1, L2);
    }
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if (lists.size() == 0) return nullptr; 
        return merge(lists, 0, lists.size() - 1);
    }
};
```

#### 复杂度分析

假设每个链表的最长长度是 n

- 时间复杂度：*O*(knlogk) 

    通过递归分治的方式将k个链表两两合并，每次合并的时间复杂度是O(kn)，而总共需要合并logk次，因此总的时间复杂度是*O*(knlogk) 。

    ![image-20240227150029742](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202402271500841.png)

- 空间复杂度：O(logk)

### 法三

==:star: **核心思路：小根堆  **:star:==

#### 代码

##### 优先级队列实现小根堆

- 维护一个大小为 k （=链表数量）的小根堆（用优先级队列实现），堆中维护每个链表中最前面的那个未被合并的元素，每次选取堆顶元素尾插到 已合并的链表。

```c++
class compare {
public: //不要忘了class默认是private, 所以要写public
    bool operator() (ListNode* a, ListNode* b) {
        return a->val > b->val;
    }
};
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        priority_queue<ListNode*, vector<ListNode*>, compare> pri_que; 
        // 初始化小根堆为k个链表的首结点
        for (auto firstNode : lists) {
            // 注意判空！！！
            if (firstNode) pri_que.push(firstNode);
        }
        ListNode* dummyHead = new ListNode();
        ListNode* cur = dummyHead;
        // 开始边pop边合并边push
        while (!pri_que.empty()) {
            auto node = pri_que.top(); pri_que.pop();
            cur->next = node; 
            cur = cur->next;
            // 将该节点所在的链表的下一节点进堆。注意判空！！！
            if (node->next) pri_que.push(node->next);
        }
        ListNode* ans = dummyHead->next;
        delete dummyHead;
        dummyHead = nullptr;
        return ans;
    }
};
```

##### 手写小根堆

建堆调整堆都很熟了，就剩合并的地方还有一些要注意的细节。

```cpp
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
/* 
    维护一个小根堆，里面存了每个链表剩下待选结点中的第一个结点，
    每次选堆顶结点尾加到合并后的链表, 然后将该节点所在链表的下一个结点push到小根堆
    再将用完的堆顶结点换到minHeap数组的末尾以便pop_back从堆中删除，
    然后重新调整堆
*/
        vector<ListNode*> minHeap; 
        // 不能一开始就初始化大小为lists.size()，因为之后边pop边合并 边push边调整堆时，
        // 需要将用完的堆顶结点换到minHeap数组的末尾以便pop_back从堆中删除

        // 1.建小根堆
        for (auto firstNode : lists) {
            if (firstNode) minHeap.emplace_back(firstNode);
        }
        buildMinHeap(minHeap);
        ListNode* dummyHead = new ListNode();
        ListNode* cur = dummyHead;
        // 2.边pop边合并 边push边调整堆
        while (!minHeap.empty()) {
            // 选堆顶结点尾加到合并后的链表
            ListNode* node = minHeap[0];
            cur->next = node;
            cur = cur->next;
            // 将node->next加入到堆中(注意判空)
            if (node->next) {
                minHeap.emplace_back(node->next);
            }
            // 将用完的堆顶结点换到minHeap数组的末尾以便pop_back从堆中删除
            swap(minHeap[0], minHeap.back());
            minHeap.pop_back();
            // 然后才是重新调整堆
            adjustMinHeap(minHeap, 0);
        }
        ListNode* ans = dummyHead->next;
        delete dummyHead;
        dummyHead = nullptr;
        return ans;
    }
    void buildMinHeap(vector<ListNode*>& minHeap) {
        for (int i = minHeap.size() / 2 - 1; i >= 0; --i) {
            adjustMinHeap(minHeap, i);
        }
    }
    void adjustMinHeap(vector<ListNode*>& minHeap, int start) {
        int parent = start;
        int Lnode = 2 * start + 1;
        int Rnode = 2 * start + 2;
        // 下滤操作让父节点作为三者中的最小的结点
        if (Lnode < minHeap.size() && minHeap[Lnode]->val < minHeap[parent]->val) {
            parent = Lnode;
        }
        if (Rnode < minHeap.size() && minHeap[Rnode]->val < minHeap[parent]->val) {
            parent = Rnode;
        }
        // 如果调整了结点，则继续调整原来父节点被换到的结点所在的子树
        if (parent != start) {
            swap(minHeap[parent], minHeap[start]);
            adjustMinHeap(minHeap, parent);
        }
    }
};
```

#### 复杂度分析

- 时间复杂度：O(knlogn)  。往堆中插入和删除元素的时间复杂度都是O(log k)，总共有 kn 个元素会被插入和删除各一次，因此总的时间复杂度就是O(knlogn)。

- 空间复杂度：O(k)

## [:fire:19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/) 

### **题意**

给你一个链表, 删除链表的倒数第 `n` 个结点, 并且返回链表的头结点。

### 思路

==:star: **核心思路：快慢双指针   **:star:==

关键：这一题必须要设置虚拟头节点！！！

**:small_red_triangle_down:  steps: **

1.  先要找到倒数第N个结点的前一个结点pre：让两个指针相隔N从左往右遍历,当快指针到链表末尾结点时慢指针就指向倒数第N+1个结点了
2.  然后让pre->next=pre->next->next就删除了倒数第N个结点

**:x: careless | ignore :**

- while ((n + 1)--)会造成无限循环。因为++、--都只能用于变量, 而不能用于常量或表达式。而(n+1)并不是一个变量, 而是一个确定值, 所以(n+1)--非法。

### 代码

```   c++
ListNode* removeNthFromEnd(ListNode* head, int n) {
/*
    用快慢指针分别指向链表末尾和链表倒数第n个结点的前一结点
    1 2 3 [4] 5
        sl    fa
    考虑到【链表只有一个结点，且该节点就是待删结点】的这种情况，我们应该用虚拟头节点
*/
    ListNode* dummyhead = new ListNode(-1, head);
    ListNode* slow = dummyhead;
    ListNode* fast = dummyhead;
    // 快指针先走n步，然后慢指针才开始同步和快指针一起走，这样它们就始终距离n步
    while (n--) {
        fast = fast->next;
    }
    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next;
    }
    // 删除节点，释放内存
    ListNode* delNode = slow->next;
    slow->next = slow->next->next;
    delete delNode;
    delNode = nullptr;

    ListNode* ans = dummyhead->next;
    delete dummyhead;
    dummyhead = nullptr;
    return ans; 
}
```

## :fire:[2. 两数相加](https://leetcode.cn/problems/add-two-numbers/)

### 题意

给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

**示例 1：**

![img](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202403020030331.jpeg)

```
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
```

**示例 2：**

```
输入：l1 = [0], l2 = [0]
输出：[0]
```

**示例 3：**

```
输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出：[8,9,9,9,0,0,0,1]
```

**提示：**

- 每个链表中的节点数在范围 `[1, 100]` 内
- `0 <= Node.val <= 9`
- 题目数据保证列表表示的数字不含前导零

### 思路 

**:key:  key：**

- 逐位进行相加并处理进位。步骤如下：

    1. 初始化一个虚拟头节点 `dummy` 和一个指针 `cur`，用于构建相加后的链表。同时，初始化一个变量 `carry` 用于存储进位。

    2. 循环直到两条链表都遍历完毕：

        - 计算两个节点值之和以及进位值(如果某条链表已经遍历完，则认为其值为 0)，更新进位值 `carry`。

        - 创建一个新节点，连在新链表后，并更新指针 `cur`。 

        - 更新l1和l2。
    3. 当两个链表都遍历完后，检查 `carry` 是否大于 0，如果大于 0，说明还有进位需要处理，创建一个值为 `carry` 的节点连在新链表后。
    4. 返回虚拟头节点的下一个节点。

**:x: careless | ignore :**

主要是注意两个地方：

- 循环条件是 || 而不是 &&（为了方便后续处理）=> 也因此，要记得在while中对l1和l2判空
- 退出循环后不能直接返回就完事了，还需要检查carry是否>0，是则需要新增结点到链表末尾。

**模拟：**

![image-20240416083716213](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202404160837331.png)

### 代码

```c++
ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
    ListNode* dummyhead = new ListNode();
    ListNode* cur = dummyhead;
    int carry = 0;
    while (l1 || l2) {
        // 计算新节点的值
        int val1 = l1 ? l1->val : 0;
        int val2 = l2 ? l2->val : 0;
        int sum = (val1 + val2 + carry) % 10;
        // 计算进位
        carry = (val1 + val2 + carry) / 10;
        // new新节点
        cur->next = new ListNode(sum, nullptr);
        // 更新cur,l1,l2
        cur = cur->next;
        if (l1) l1 = l1->next;
        if (l2) l2 = l2->next;
    }
    if (carry) {
        cur->next = new ListNode(1, nullptr);
    } 
    ListNode* ans = dummyhead->next;
    delete dummyhead;
    dummyhead = nullptr;
    return ans;
}
```

### 复杂度分析

- 时间复杂度：O(max(n, m))  

- 空间复杂度：O(1)。返回值不计入空间复杂度。

## :fire:[234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/)

### 题意

给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false` 。

**示例 1：**

![img](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202403091934808.jpeg)

```
输入：head = [1,2,2,1]
输出：true
```

**示例 2：**

![img](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202403091934648.jpeg)

```
输入：head = [1,2]
输出：false
```

**提示：**

- 链表中节点数目在范围`[1, 105]` 内
- `0 <= Node.val <= 9`

**进阶：**你能否用 `O(n)` 时间复杂度和 `O(1)` 空间复杂度解决此题？

### 参考题解

1. [官解](https://leetcode.cn/problems/palindrome-linked-list/solutions/457059/hui-wen-lian-biao-by-leetcode-solution)

### 思路

==:star: **核心思路：反转链表 + 快慢指针  **:star:==

**:key:  key：**

- ![SmartSelect_20240310_100226_Samsung Notes](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202403101003735.jpg)

**:question:   problems:** 

1. 为什么【1.找到前半部分链表的尾节点】中循环条件是`while (fast->next && fast->next->next)`而不是`while (fast && fast->next)`? 可以是`while (fast && fast->next)`吗？

:heavy_check_mark:  **answer:** 

1. 不可以（会很麻烦）。因为要反抓后半部分链表，不仅要找到开始反转的结点，还要找到起始反转结点的前一个结点（即前半部分链表的尾节点）。

    - 如果用while (fast && fast->next) ，那么当节点数为偶数，退出循环时!fast，slow刚好指向开始反转的结点。也就是说此时会获取不到起始反转结点的前一个结点

        ```cpp
         1 2 3 4 5    需要 s 指向 3
        sf   f   f
           s s
        
         1 2 3 4     需要 s 指向 2
        sf   f   f
           s s
        ```

    - 因此要将条件改成`while (fast->next && fast->next->next)`，这样不管节点数为奇数还是为偶数，退出循环时slow都指向起始反转结点的前一个结点。
    
        ```cpp
         1 2 3 4 5 	 需要 s 指向 3
        sf   f   f
           s s
        
         1 2 3 4     需要 s 指向 2
        sf   f   
           s 
        ```
    
        

**:small_red_triangle_down:  steps: **

1. 找到前半部分链表的尾节点:  用快慢双指针(步数是两倍关系)，快指针走到末尾时，慢指针就指向了中间
2. 反转链表后半部分
3. 同向双指针判断是否回文
4. 还原链表（不是必须的，但最好将链表恢复原样，因为使用该函数的人通常不希望链表结构被更改）

### 代码

最后不还原链表的代码

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverse(ListNode* cur) {
        ListNode* pre = nullptr;
        while (cur) {
            ListNode* tmp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = tmp;
        }
        return pre;
    }
    bool isPalindrome(ListNode* head) {
        // 快慢双指针, fast的速度是slow的两倍, 当fast遍历到链表末尾时, slow指向链表中间
        ListNode *slow = head; 
        ListNode *fast = head; 
        // 1. 先找到中间
        while (fast->next && fast->next->next) {
            // 循环条件是细节！！！
            slow = slow->next;
            fast = fast->next->next;
        }
        // 2. 开始反转后半部分链表
        slow->next = reverse(slow->next);
        // 2. 开始判断回文
        fast = slow->next;
        slow = head;
        while (fast) {
            if (slow->val != fast->val) {
                return false;
            }
            slow = slow->next;
            fast = fast->next;
        }
        return true;
    }
};
```

最后还原链表的代码

```c++
class Solution {
public:
    ListNode* reverseList(ListNode* cur) {
        ListNode* pre = nullptr;
        while (cur) {
            ListNode* tmp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = tmp;
        }
        return pre;
    }
    bool isPalindrome(ListNode* head) {
        if (head == nullptr) return true;
        // 1.找到前半部分链表的尾节点
        ListNode* slow = head;
        ListNode* fast = head;
        while (fast->next && fast->next->next) {
            // 循环条件是细节！！！
            slow = slow->next;
            fast = fast->next->next;
        }
        // 两种情况退出循环时slow都指向开始反转的结点的前一个结点
        ListNode* pre = slow;       //开始反转的结点的前一个结点
        ListNode* cur = slow->next; //开始反转的结点
        // 2.反转链表后半部分，并接在链表前半部分的末尾
        pre->next = reverseList(cur);
        // 3.同向双指针判断是否回文
        slow = head;
        fast = pre->next;
        while (fast) {
            if (slow->val != fast->val) {
                return false;
            }
            slow = slow->next;
            fast = fast->next;
        } 
        // 4.还原链表
        pre->next = reverseList(pre->next);
        return true;
    }
};
```

**复杂度分析**

- 时间复杂度：O(n)  

- 空间复杂度：O(1)

### 迭代

```c++

```

**复杂度分析**

- 时间复杂度：O()  

- 空间复杂度：O()

## [24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/) 

```c++
ListNode* swapPairs(ListNode* head) {
    ListNode *dummyhead = new ListNode(0,head), *tmp = nullptr, *pre = dummyhead;
    while (head && head->next) { //交换head和head->next
        // 交换操作
        tmp = head->next;//tmp->2
        head->next = head->next->next;//1->3
        tmp->next = head;//2->  1->3
        pre->next = tmp;//dummyhead->  2->1->3
        // 更新指针
        pre = head;
        head = head->next;
    } 
    return dummyhead->next;
}
```



## :fire:[82. 删除排序链表中的重复元素 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/)

### **题意**

给定一个已排序的链表的头 `head` ,  *删除原始链表中所有重复数字的节点, 只留下不同的数字* 。返回 *已排序的链表* 。

**示例 1：**

![img](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202401221037613.jpeg)

```
输入：head = [1,2,3,3,4,4,5]
输出：[1,2,5]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/01/04/linkedlist2.jpg)

```
输入：head = [1,1,1,2,3]
输出：[2,3]
```

**提示：**

- 链表中节点数目在范围 `[0, 300]` 内
- `-100 <= Node.val <= 100`
- 题目数据保证链表已经按升序 **排列**

### 思路

==:star: **核心思路： 双指针  **:star:==

![image-20240115160934861](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202401151609014.png)

### 代码

```c++
ListNode* deleteDuplicates(ListNode* head) {
/*
    用两个指针，prev指向这些值相同的结点的前一个结点，cur用来遍历重复数字，初始时prev->next == cur
    - 如果cur没有遇到重复的，即prev->next仍为cur，此时只需让prev = cur, cur = cur->next即可
    - 如果遇到重复的，则prev->next = cur->next删除重复的，然后cur = cur->next
*/
    ListNode* dummyhead = new ListNode(0, head);
    ListNode* prev = dummyhead;
    ListNode* cur = dummyhead->next;
    while (cur) {
        // 1. 跳过所有重复数字，直到cur指向最后一个重复数字结点 (如果cur没有遇到值相同的结点, 则cur的指向不会变)
        while (cur->next && cur->val == cur->next->val) {
            cur = cur->next;
        }
        // 2. 删除重复的
        if (prev->next == cur) { //如果cur没有值相同的结点，则更新prev指针即可
            prev = cur;
        } else { //否则才要删除重复的
            prev->next = cur->next;
        }
        // 3. 更新指针
        cur = cur->next;
    }
    return dummyhead->next;
}
```

### 复杂度分析

- 时间复杂度：O(n)  

- 空间复杂度：O(1)

## :fire:[LCR 140. 训练计划 II](https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

### 题意

查找并返回链表的倒数第 `n` 个结点。

**示例 1：**

```
输入：head = [2,4,7,8], n = 1
输出：8
```

**提示：**

- `1 <= head.length <= 100`
- `0 <= head[i] <= 100`
- `1 <= n <= head.length`

### 代码

```cpp
ListNode* trainingPlan(ListNode* head, int n) {
/* 
    先让快指针走n步，然后让慢指针从头开始与快指针同步走，
    当快指针走到链表末尾时，慢指针指向倒数第n个结点
        2 4 7 8, n = 2, 返回7
    最终    s   f
        s   f
    与[19. 删除链表的倒数第 N 个结点]不同，该题只需要查找倒数第n个结点，因此不需要用虚拟头节点
*/
    ListNode* fast = head;
    int k = n;
    while (k--) {
        fast = fast->next;
    }
    ListNode* slow = head;
    while (fast != nullptr) {
        slow = slow->next;
        fast = fast->next;
    }
    return slow;
}
```

