## 💛总结

- 设计链表--插删查
- 虚拟头结点
- 双指针
- 反转链表
- 环

## :car:[lc707 设计链表](https://leetcode.cn/problems/design-linked-list/)

```c++
class MyLinkedList {
public:
    struct Listnode { //定义链表结点结构体
        int val;
        Listnode* next;
        //三个构造函数
        Listnode(): val(0), next(nullptr) {}
        Listnode(int x): val(x), next(nullptr) {}
        Listnode(int x, Listnode* p): val(x), next(p) {}
    };
    int len;//链表长度
    Listnode* dummyhead;////虚拟头结点
        
    MyLinkedList() {
        len = 0;
        dummyhead = new Listnode(0);//实例化虚拟头结点
    }
    
    int get(int index) {
        if (index > len - 1 || index < 0)  return -1;//下标无效
        //下面就是下标有效的情况
        Listnode* p = dummyhead->next;
        //从下标为0的dummmyhead->next到下标为index的节点需要p = p->next index次
        while (index--) p = p->next;//计数从index到1共index次
        return p->val;
    }
    
    void addAtHead(int val) {
        Listnode* head = new Listnode(val);
        head->next = dummyhead->next;//新头结点接管旧头结点以及其后所有
        dummyhead->next = head;
        ++len;
    }
    
    void addAtTail(int val) {
        Listnode* p = dummyhead;//用于遍历
        Listnode* end = new Listnode(val);
        while (p->next) p = p->next;
        p->next = end;
        ++len;
    }
    
    void addAtIndex(int index, int val) {
        if (index > len || index < 0) return;//越界
        Listnode* ins = new Listnode(val);
        Listnode* p = dummyhead;//用于遍历
        while (index--) p = p->next;//操作index次, p从dummyhead(-1)指到下标为index-1的节点
        ins->next = p->next;
        p->next = ins;
        ++len;
    }
    
    void deleteAtIndex(int index) {
        if (index > len - 1 || index < 0)  return;//下标无效
        Listnode* p = dummyhead;//遍历
        while (index--) p = p->next;//操作index次, p从dummyhead(-1)指到下标为index-1的节点
        Listnode* tmp = p->next;
        p->next = p->next->next;
        delete tmp;
        tmp = nullptr;//delete后记得置空
        --len;
    }
};
```

## :fire:[lc206 反转链表](https://leetcode.cn/problems/reverse-linked-list/)   

### 题意

给你单链表的头节点 `head` , 请你反转链表, 并返回反转后的链表。

**示例 1：**

![img](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202402081313999.jpeg)

```
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
```

### 迭代

```c++
ListNode* reverseList(ListNode* head) {
    // tmp = 要反转的结点cur的next; 然后反转cur; 之后cur = tmp, 重复上述步骤
    ListNode* pre = nullptr; 
    ListNode* cur = head;
    while (cur) {
        ListNode* tmp = cur->next;
        cur->next = pre;
        pre = cur;
        cur = tmp;
    }
    return pre;
}
```

复杂度分析

- 时间复杂度：O(n)  

- 空间复杂度：O(1)

### 递归

```c++
ListNode* reverse(ListNode* cur, ListNode* pre) {
    // 2.递归结束的条件
    if (cur == nullptr) return pre;
    // 3.单层递归的逻辑：
    // 暂存要反转的结点的next为tmp，然后反转一个结点，反转后该节点变为pre，tmp变为cur
    ListNode* tmp = cur->next;
    cur->next = pre;
    
    // pre = cur;
    // cur = tmp;
    // return reverse(cur, pre);
    //上面三步可以直接合为一步
    return reverse(tmp, cur);
}
ListNode* reverseList(ListNode* head) {
    return reverse(head, nullptr);
}
```

**复杂度分析**

- 时间复杂度：O(n)  

- 空间复杂度：O(n)


## [:fire: 141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/)

### **题意**

给你一个链表的头节点 `head` , 判断链表中是否有环。存在返回 `true` 。 否则返回 `false` 。

 提示：链表中节点的数目范围是 `[0, 104]`

==:star: **核心思路： 双指针  **:star:==

注意：

1. 链表的题要注意开头都要特判！！！
2. 循环条件

### 代码

```c++
bool hasCycle(ListNode *head) {
    // 链表的题要注意开头都要特判！！！
    if (!head || !head->next) return false;
    ListNode *slow = head, *fast = head;
    //错误写法：while (slow != fast && fast->next && fast) {
    //真的服了, 一开始slow就==fast, 循环条件怎么能是slow != fast啊！！！
    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast) return true;
    }
    return false;
}
```

### 复杂度分析

- 时间复杂度：O(n)  

- 空间复杂度：O(1)

## [:fire: 142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

### **题意**

给定一个链表的头节点  `head` , **返回链表开始入环的第一个节点**。 *如果链表无环, 则返回 `null`。*

### 法一

哈希

**代码**

```c++
 ListNode *detectCycle(ListNode *head) {
    // 法一、用哈希存放遍历过的结点, 当遍历到哈希中存在的结点时就说明有环
    unordered_set<ListNode*> visited;
    while (head != nullptr) {
        if (visited.count(head)) return head;
        visited.insert(head);
        head = head->next;
    }
    return nullptr;
 }
```

### 法二

==:star: **核心思路： 双指针  **:star:==

**:question:   problems:** 

1. 怎样判断是否成环？ 
2. 怎样找到入环的第一个结点？

:heavy_check_mark:  **answer:** 

1. 用slow和fast遍历链表, fast每次比slow多走一步, 如果遍历过程中fast==slow说明有环

2. 

![SmartSelect_20240126_225643_Samsung Notes](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202402091057729.jpeg)

### 代码

```c++
ListNode *detectCycle(ListNode *head) {
    if (!head || !head->next) return nullptr;
    ListNode *slow = head, *fast = head;
    //错误写法：while (slow != fast && fast->next && fast) {
    //真的服了, 一开始slow就==fast, 循环条件怎么能是slow != fast啊！！！
    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast) { //如果有环, 则接着找环入口
            fast = head; //让fast从链头开始, slow从相遇点开始
            while (slow != fast) {
                slow = slow->next;
                fast = fast->next;
            }
            return fast;
        }
    }
    return nullptr;
}
```

##  :fire:[146. LRU 缓存](https://leetcode.cn/problems/lru-cache/)

### **题意**

请你设计并实现一个满足 [LRU (最近最少使用) 缓存](https://baike.baidu.com/item/LRU) 约束的数据结构。

实现 `LRUCache` 类：

- `LRUCache(int capacity)` 以 **正整数** 作为容量 `capacity` 初始化 LRU 缓存
- `int get(int key)` 如果关键字 `key` 存在于缓存中, 则返回关键字的值, 否则返回 `-1` 。
- `void put(int key, int value)` 如果关键字 `key` 已经存在, 则变更其数据值 `value` ；如果不存在, 则向缓存中插入该组 `key-value` 。如果插入操作导致关键字数量超过 `capacity` , 则应该 **逐出** 最久未使用的关键字。

函数 `get` 和 `put` 必须以 `O(1)` 的平均时间复杂度运行。

**示例：**

```
输入
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
输出
[null, null, null, 1, null, -1, null, -1, 3, 4]

解释
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // 缓存是 {1=1}
lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}
lRUCache.get(1);    // 返回 1
lRUCache.put(3, 3); // 该操作会使得关键字 2 作废, 缓存是 {1=1, 3=3}
lRUCache.get(2);    // 返回 -1 (未找到)
lRUCache.put(4, 4); // 该操作会使得关键字 1 作废, 缓存是 {4=4, 3=3}
lRUCache.get(1);    // 返回 -1 (未找到)
lRUCache.get(3);    // 返回 3
lRUCache.get(4);    // 返回 4
```

**提示：**

- `1 <= capacity <= 3000`
- `0 <= key <= 10000`
- `0 <= value <= 105`
- 最多调用 `2 * 105` 次 `get` 和 `put`

### 参考题解

1. [【字节一面】 LRU Cache 实现剖析]( https://www.bilibili.com/video/BV1hp4y1x7MH/?share_source=copy_web&vd_source=8086e0fb4ccc0ee9410370076867092c)
1. [官解](https://leetcode.cn/problems/lru-cache/solutions/259678/lruhuan-cun-ji-zhi-by-leetcode-solution)

### 思路

==:star: **核心思路：哈希表 + 双向链表**:star:==

#### 1. 确定选用什么数据结构

由题，

- LRUCache维护一个cap容量，如果添加元素后size>cap，就需要逐出最久未使用的元素。
- LRUCache有两个时间复杂度为O(1)的成员函数：get()和put()
    - get()中的逻辑是：
        - 根据key获取value，这个操作要想时间复杂度为O(1)，那么就需要用到unordered_map
        - 另外还有一个重要但容易遗漏的点：如果key存在于缓存中，那么get(key)之后，key就变为了最近使用的关键字。
    - put()中的逻辑是：
        - 如果key存在，改变其value，然后将key变为最近使用的；
        - 否则，向缓存中插入key-value，然后将key变为最近使用的，如果put后LRUCache的size>cap，那么就需要将最久未使用的关键字逐出。
    - 从这两个函数的逻辑我们就可以知道缓存应该选用什么结构了：
        - 除了要能快速根据键获取value之外，缓存选用的结构要能够体现关键字是最近使用还是最久未使用，因为我们需要在get以及put后，将操作的关键字变为最近使用的，以及如果put后LRUCache的size>cap，那就需要将最久未使用的关键字逐出。
        - 因此，关键字还需要按序组织，这个顺序就是从：最近使用->最久未使用。
        - 考虑到插入删除所需的时间复杂度，我们选用链表而不是数组。
        - 那用单向链表还是双向循环链表？
        - 双向循环链表！因为我们不仅需要操作最近使用的关键字，还需要操作最久未使用的关键字。如果是单向的，那么我们只能操作最近使用的关键字，最久未使用的关键字需要遍历到链表结尾才能获取到。而如果是双向循环的，最久未使用的关键字就能直接根据尾结点得到，这个时间就是O(1)的。
        - 结合前面说的unordered_map，我们就能确定LRUCache选用的结构是unordered_map+双向循环链表，这样LRUCache查找插入删除的时间复杂度都是O(1)。
        - 这两个结构怎么联系起来呢？unordered_map的key就是关键字key，value是key对应的存在于双向循环链表中的结点。双向循环链表每个结点存放了关键字key和它的value。

![image-20240211084944957](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202402110849032.png)

#### 2. get和put的具体实现

确定了LRUCache选用的结构，我们再重新梳理一下get()和put()的逻辑。

- get()中的逻辑是：
    - 根据key从unordered_map中获取key对应在链表中的结点，如果key存在于map中，根据结点获取value，之后，将key变为最近使用的关键字（将原来key对应在链表中的结点删除，再重新new一个结点头插到链表，注意需要同步在map中删除添加）。
        - 为啥“将key变为最近使用的关键字”，需要同步把key从map中删除再添加？不是多此一举吗？只操作链表不就可以了吗？
        - 不可以！因为如果只把key对应在链表中的结点删除，那么此时map[key]指向哪呢？？因此，在结点从链表中删除的同时，也要把map中的key-value删除。头插的时候，也要将key-value添加到map中。
- put()中的逻辑是：
    - 判断key是否存在于unordered_map：
        - 如果key存在，将其对应结点从链表中删除，**同时要在unordered_map删除键值对**，然后用key和新的value重新new一个结点头插到链表，**同时要在unordered_map添加键值对**。
        - 否则，key不存在，将key-value头插到链表中，同时要在unordered_map添加键值对，如果put后LRUCache的size>cap，那么就需要将最久未使用的关键字逐出，同时要在unordered_map删除键值对。

### 代码

```c++
struct Node { //链表结点
    int key, value;
    Node *prev, *next;
    Node(): key(-1), value(-1), prev(nullptr), next(nullptr) {}
    Node(int x, int y) : key(x), value(y), prev(nullptr), next(nullptr) {}
};
struct DoubleLinkedList { //双向循环链表 
    Node *head, *tail; 
    // head: recently used 最近使用
    // tail: LRU (least recently used) 最近最久未使用

    DoubleLinkedList() : head(new Node()), tail(new Node()){
        head->next = tail;
        tail->prev = head;
    }
    // 头插 
    void insertHead(Node* newNode) {
        // 先将newNode的两个指针接在head和head->next之间
        newNode->prev = head;
        newNode->next = head->next;
        // 然后再将head的next以及head->next的prev接上newNode
        head->next->prev = newNode;
        head->next = newNode;
    }
    // 删除链表中的结点node
    int deleteNode(Node* node) {
        // 返回int是尾删函数需要返回int
        int _key = node->key;
        node->next->prev = node->prev;
        node->prev->next = node->next;
        delete node;
        node = nullptr;
        return _key;
    }
    // 尾删
    int deleteTail() {
        // 需要返回int是因为尾删掉的结点也需要在哈希map中删掉
        // 如果链表中就只有head和tail两个哨兵结点，直接返回
        if (tail->prev == head) return -1;
        return deleteNode(tail->prev);
    }
};
class LRUCache {  //结合了哈希map和双向循环链表
private:
    DoubleLinkedList cache; //从链头到链尾是 最近被使用的节点-->最久没被使用的节点
    unordered_map<int, Node*> umap;
    int cap;
public:
    LRUCache(int capacity) : cap(capacity) {}
    
    int get(int key) {
        if (umap.count(key) == 0) {
           return -1;
        } 
        Node* node = new Node(key, umap[key]->value);
        // 从链表中删除原来key对应的结点，然后将其头插到链表
        // 注意！map中也要同步删除插入
        cache.deleteNode(umap[key]);
        umap.erase(key);
        // 上面这两句不能调换位置，为什么？
        // 因为如果先调用umap.erase(key)，那就会导致key被删除，umap[key]就不能用了
        cache.insertHead(node);
        umap[key] = node;
        
        return node->value;
    }
    
    void put(int key, int value) {
        if (umap.count(key)) {
            cache.deleteNode(umap[key]);
            umap.erase(key);
        } 
        Node* node = new Node(key, value);
        cache.insertHead(node);
        umap[key] = node;
        if (umap.size() > cap) { 
            int _key = cache.deleteTail();
            umap.erase(_key);
        }
    }
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache* obj = new LRUCache(capacity);
 * int param_1 = obj->get(key);
 * obj->put(key,value);
 */
```

### 复杂度分析

- 时间复杂度：O(1) ，对于 put 和 get 都是 O(1)。 
- 空间复杂度：O(capacity)，因为哈希表和双向链表最多存储 capacity+1个元素

## [:fire: 21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)

### **题意**

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

**提示：**

- 两个链表的节点数目范围是 `[0, 50]`
- `-100 <= Node.val <= 100`
- `l1` 和 `l2` 均按 **非递减顺序** 排列

### 参考题解

1. 递归
    1. [腐烂的橘子](https://leetcode.cn/problems/merge-two-sorted-lists/solutions/103891/yi-kan-jiu-hui-yi-xie-jiu-fei-xiang-jie-di-gui-by-)
    1. [评论](https://leetcode.cn/problems/merge-two-sorted-lists/solutions/103891/yi-kan-jiu-hui-yi-xie-jiu-fei-xiang-jie-di-gui-by-/comments/1228656) ==递归思路！优秀！==

1. 迭代：[官解](https://leetcode.cn/problems/merge-two-sorted-lists/solutions/226408/he-bing-liang-ge-you-xu-lian-biao-by-leetcode-solu)

### 递归

```c++
ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
    // 递归出口
    if (!list1 || !list2) return list1 ? list1 : list2;
    // 单层递归要做啥事？要merge L1,L2
    // 如果L1第一个元素小于L2, 则这个大项目要交给L1负责
    if (list1->val <= list2->val) {
        // L1先接过下级员工干完的活: mergeTwoLists(list1->next, list2)
        // 然后把自己干的活附上去: list1->next = ()
        list1->next = mergeTwoLists(list1->next, list2);
        // 最后将任务结果提交给上级
        return list1;
    }
    // 否则, 这个大项目交给L2负责
    list2->next = mergeTwoLists(list1, list2->next);
    return list2;
}
```

**复杂度分析**

- 时间复杂度：O(n + m)  

- 空间复杂度：O(n + m)

### 迭代

![image-20240221200322546](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202402212003767.png)

```c++
ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
    if (!list1 || !list2) return list1 ? list1 : list2;
    
    // 先根据两链表的头结点确定合并后的头结点
    // ListNode* head = nullptr;
    // ListNode* cur = nullptr;
    // if (list1->val <= list2->val) {
    //     head = list1;
    //     cur = list1;
    //     list1 = list1->next;
    // } else {
    //     head = list2;
    //     cur = list2;
    //     list2 = list2->next;
    // }

    // 也可以直接把head当作虚拟头节点, 就省的上面写这么多单独确定head了
    ListNode* head = new ListNode();
    ListNode* cur = head;

    while (list1 && list2) {
        // 循环结束的条件是其中一个链表处理完所有节点
        if (list1->val <= list2->val) {
            cur->next = list1;
            list1 = list1->next;
        } else {
            cur->next = list2;
            list2 = list2->next;
        }
        cur = cur->next;
    }
    // 如果是L1全合并完了, 则将L2后面所有节点直接加到尾部; 否则, 将L1后面所有节点直接加到尾部
    cur->next = list1 == nullptr ? list2 : list1;
    
    ListNode* ans = head->next;
    delete head;
    head = nullptr; 
    return ans;
}
```

**复杂度分析**

- 时间复杂度：O(n + m)  

- 空间复杂度：O(1)

### Follow Up：合并两个有序链表并去重

待补充。。。





## [:fire:160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

### **题意**

给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null` 。

**注意**，函数返回结果后，链表必须 **保持其原始结构** 。

**示例 1：**

[![img](https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png)

```
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
输出：Intersected at '8'
解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。
在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
— 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。
```

**提示：**

- `listA` 中节点数目为 `m`
- `listB` 中节点数目为 `n`
- `1 <= m, n <= 3 * 104`
- `1 <= Node.val <= 105`
- `0 <= skipA <= m`
- `0 <= skipB <= n`
- 如果 `listA` 和 `listB` 没有交点，`intersectVal` 为 `0`
- 如果 `listA` 和 `listB` 有交点，`intersectVal == listA[skipA] == listB[skipB]`

**进阶：**你能否设计一个时间复杂度 `O(m + n)` 、仅用 `O(1)` 内存的解决方案？

### 思路

==:star: **核心思路：双指针 + 数学   **:star:==

![image-20240226223915806](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202402262239913.png)

**代码**

```c++
ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
    ListNode* head = new ListNode();
    ListNode* cur = head;
    ListNode* pA = headA;
    ListNode* pB = headB;
    while (pA != pB) {
        pA = (pA ? pA->next : headB);
        pB = (pB ? pB->next : headA);
    }
    cur->next = (pA ? pA : pB);

    ListNode* ans = head->next;
    delete head;
    head = nullptr;

    return ans;
}
```

**复杂度分析**

- 时间复杂度：O(n + m)  

- 空间复杂度：O(1)

## [:fire:23. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)

### **题意**

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

**示例 1：**

```
输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6
```

**示例 2：**

```
输入：lists = []
输出：[]
```

**示例 3：**

```
输入：lists = [[]]
输出：[]
```

**提示：**

- `k == lists.length`
- `0 <= k <= 10^4`
- `0 <= lists[i].length <= 500`
- `-10^4 <= lists[i][j] <= 10^4`
- `lists[i]` 按 **升序** 排列
- `lists[i].length` 的总和不超过 `10^4`

### 参考题解

1. [官解](https://leetcode.cn/problems/merge-k-sorted-lists/solutions/219756/he-bing-kge-pai-xu-lian-biao-by-leetcode-solutio-2)

### 法一

暴力：顺序合并。

将每条链表取出来与ans合并（合并两个有序链表），将合并结果返给ans，不断更新ans，最终ans就是所有链表合并后的结果。

```c++
ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
    if (!list1 || !list2) return list1 ? list1 : list2;
    ListNode* head = new ListNode();
    ListNode* cur = head;

    while (list1 && list2) { 
        if (list1->val <= list2->val) {
            cur->next = list1;
            list1 = list1->next;
        } else {
            cur->next = list2;
            list2 = list2->next;
        }
        cur = cur->next;
    } 
    cur->next = list1 ? list1 : list2;
    
    ListNode* ans = head->next;
    delete head;
    head = nullptr; 
    return ans;
}
ListNode* mergeKLists(vector<ListNode*>& lists) {
    ListNode* ans = nullptr;
    for (auto list : lists) {
        ans = mergeTwoLists(ans, list);
    }
    return ans;
}
```

#### 复杂度分析

假设每个链表的最长长度是 n.

- 时间复杂度：O(k^2^n)  

    ![image-20240226230825439](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202402262308498.png)

- 空间复杂度：O(1)

### 法二

==:star: **核心思路： 分治合并  **:star:==

**:question:   problems:** 

1. 为什么mid下取整不能用上取整的分治写法? 即为什么mid下取整时不能写成 `ListNode* L1 = merge(lists, left, mid); ListNode* L2 = merge(lists, mid + 1, right);` ?

:heavy_check_mark:  **answer:** 

1. 如果mid下取整时分治逻辑写成 `ListNode* L1 = merge(lists, left, mid); ListNode* L2 = merge(lists, mid + 1, right);`如下：

![image-20240227124231265](C:\Users\Oscar\AppData\Roaming\Typora\typora-user-images\image-20240227124231265.png)

#### 代码

```c++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        if (!list1 || !list2) return list1 ? list1 : list2;
        ListNode* head = new ListNode();
        ListNode* cur = head;

        while (list1 && list2) { 
            if (list1->val <= list2->val) {
                cur->next = list1;
                list1 = list1->next;
            } else {
                cur->next = list2;
                list2 = list2->next;
            }
            cur = cur->next;
        } 
        cur->next = list1 ? list1 : list2;
        
        ListNode* ans = head->next;
        delete head;
        head = nullptr; 
        return ans;
    }
    ListNode* merge(vector<ListNode*>& lists, int left, int right) {
        // 1.递归参数以及返回值: 需要两个int表示分治区间的两端点
        // 2.递归结束的条件: 分治区间长度为1时,即只有一个链表时
        if (left == right) return lists[left];
        else if (left > right) return nullptr;
        // 3.单层递归做什么事? 先分治(一分为二),再合并
        // 先分治
        int mid = left + (right - left) / 2; 		//mid下取整
        ListNode* L1 = merge(lists, left, mid);
        ListNode* L2 = merge(lists, mid + 1, right); 
        
        // int mid = left + (right - left + 1) / 2; // mid上取整
        // ListNode* L1 = merge(lists, left, mid - 1);
        // ListNode* L2 = merge(lists, mid, right);
        
        // 再合并
        return mergeTwoLists(L1, L2);
    }
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if (lists.size() == 0) return nullptr; 
        return merge(lists, 0, lists.size() - 1);
    }
};
```

#### 复杂度分析

假设每个链表的最长长度是 n

- 时间复杂度：*O*(knlogk) 

    通过递归分治的方式将k个链表两两合并，每次合并的时间复杂度是O(kn)，而总共需要合并logk次，因此总的时间复杂度是*O*(knlogk) 。

    ![image-20240227150029742](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202402271500841.png)

- 空间复杂度：O(logk)

### 法三

==:star: **核心思路：小根堆（优先级队列实现）  **:star:==

**:key:  key：**

- 维护一个大小为 k （=链表数量）的小根堆（用优先级队列实现），堆中维护每个链表中最前面的那个未被合并的元素，每次选取堆顶元素尾插到 已合并的链表。
- 手写堆也要掌握！参考【排序】那一章节的topK。

#### 代码

##### 优先级队列实现小根堆

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class compare {
public: //不要忘了class默认是private, 所以要写public
    bool operator() (ListNode* a, ListNode* b) {
        return a->val > b->val;
    }
};
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        priority_queue<ListNode*, vector<ListNode*>, compare> pri_que; 
        // 初始化小根堆为k个链表的首结点
        for (auto firstNode : lists) {
            // 注意判空！！！
            if (firstNode) pri_que.push(firstNode);
        }
        ListNode* dummyHead = new ListNode();
        ListNode* cur = dummyHead;
        // 开始边pop边合并边push
        while (!pri_que.empty()) {
            auto node = pri_que.top(); pri_que.pop();
            cur->next = node; 
            cur = cur->next;
            // 将该节点所在的链表的下一节点进堆。注意判空！！！
            if (node->next) pri_que.push(node->next);
        }
        ListNode* ans = dummyHead->next;
        delete dummyHead;
        dummyHead = nullptr;
        return ans;
    }
};
```

##### 手写小根堆

```cpp
class Solution {
public:
    void buildMinHeap(vector<ListNode*>& minHeap) {
        for (int i = minHeap.size() / 2 - 1; i >= 0; --i) {
            adjustMinHeap(minHeap, i, minHeap.size());
        }
    }
    void adjustMinHeap(vector<ListNode*>& minHeap, int start, int end) {
        int parent = start;
        int Lnode = 2 * start + 1;
        int Rnode = 2 * start + 2;
        if (Lnode < end && minHeap[Lnode]->val < minHeap[parent]->val) {
            parent = Lnode;
        } 
        if (Rnode < end && minHeap[Rnode]->val < minHeap[parent]->val) {
            parent = Rnode;
        } 
        // 交换完之后父节点就是三者中最小的
        // 原父节点被换到哪棵子树，哪个子树就要再调整
        if (parent != start) {
            swap(minHeap[start], minHeap[parent]);
            adjustMinHeap(minHeap, parent, end);
        }
    }
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        vector<ListNode*> minHeap; 
        // 1.建小根堆
        for (auto firstNode : lists) {
            if (firstNode) minHeap.emplace_back(firstNode);
        }
        buildMinHeap(minHeap);
        ListNode* dummyHead = new ListNode();
        ListNode* cur = dummyHead;
        // 2.边pop边合并 边push边调整堆
        while (minHeap.size() > 0) {
            auto node = minHeap[0];
            cur->next = node;
            cur = cur->next;
            if (node->next) {
                minHeap.emplace_back(node->next); 
            }
            // 将用了的堆顶minHeap[0]换到堆尾以便pop_back
            swap(minHeap[0], minHeap.back());
            minHeap.pop_back();
            // 重新调整堆
            adjustMinHeap(minHeap, 0, minHeap.size());
        }
        ListNode* ans = dummyHead->next;
        delete dummyHead;
        dummyHead = nullptr;
        return ans;
    }
};
```

#### 复杂度分析

- 时间复杂度：O(knlogn)  。往堆中插入和删除元素的时间复杂度都是O(log k)，总共有 kn 个元素会被插入和删除各一次，因此总的时间复杂度就是O(knlogn)。

- 空间复杂度：O(k)

## [:fire: 19 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/) 

### **题意**

给你一个链表, 删除链表的倒数第 `n` 个结点, 并且返回链表的头结点。

### 思路

==:star: **核心思路：快慢双指针   **:star:==

**:small_red_triangle_down:  steps: **

1.  先要找到倒数第N个结点的前一个结点pre：让两个指针相隔N从左往右遍历,当快指针到链表末尾结点时慢指针就指向倒数第N+1个结点了
2.  然后让pre->next=pre->next->next就删除了倒数第N个结点

**:x: careless | ignore :**

- while ((n + 1)--)会造成无限循环。因为++、--都只能用于变量, 而不能用于常量或表达式。而(n+1)并不是一个变量, 而是一个确定值, 所以(n+1)--非法。

### 代码

```   c++
ListNode* removeNthFromEnd(ListNode* head, int n) {
    if (head == nullptr && head->next == nullptr) return nullptr;
    ListNode *dummyhead = new ListNode(0, head), *slow = dummyhead, *fast = dummyhead;
    // 1. 先找到倒数第N+1个结点
    //倒数第2个结点和倒数第1个结点相隔1个next, 倒数倒数第n+1个结点和倒数第1个结点就相隔n个next
    while (n--) fast = fast->next;
    while (fast->next) { //退出循环时fast指向末尾非空结点, 即倒数第一个结点, slow指向倒数第n+1个结点
        slow = slow->next;
        fast = fast->next;
    }
    // 2. 然后删除倒数第N个结点
    slow->next = slow->next->next;
    
    return dummyhead->next;
    // 若要释放dummyhead内存, 则应写成
    // head = dummyhead->next;
    // delete dummyhead;
    // dummyhead = nullptr;
    // return head;
}
```

## :fire:[2. 两数相加](https://leetcode.cn/problems/add-two-numbers/)

### 题意

给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

**示例 1：**

![img](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202403020030331.jpeg)

```
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
```

**示例 2：**

```
输入：l1 = [0], l2 = [0]
输出：[0]
```

**示例 3：**

```
输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出：[8,9,9,9,0,0,0,1]
```

**提示：**

- 每个链表中的节点数在范围 `[1, 100]` 内
- `0 <= Node.val <= 9`
- 题目数据保证列表表示的数字不含前导零

### 思路 

**:key:  key：**

- 逐位进行相加并处理进位。步骤如下：

    1. 初始化一个虚拟头节点 `dummy` 和一个指针 `cur`，用于构建相加后的链表。同时，初始化一个变量 `carry` 用于存储进位。

    2. 循环直到两条链表都遍历完毕：

        - 计算两个节点值之和以及进位值(如果某条链表已经遍历完，可以认为其值为 0)，更新进位值 `carry`。

        - 创建一个新的节点，其值 = 节点值之和 % 10，将新节点加入相加后的链表，并更新指针 `cur`。 

        - 更新两个链表的当前节点为其next结点。


    3. 当两个链表都遍历完后，检查进位值 `carry` 是否大于 0，如果大于 0，说明还有一个进位需要处理，创建一个值为 `carry` 的节点并加入相加后的链表。
    
    4. 返回虚拟头节点的下一个节点，即为相加后的链表头节点。

**模拟：**

![image-20240416083716213](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202404160837331.png)

### 代码

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        // 往右遍历链表，数字是从低位往高位，和正常的相反，那么进位也是进给右边
        ListNode* dummyHead = new ListNode();
        ListNode* cur = dummyHead;
        int value = 0;
        int carry = 0;
        int sum = 0;
        while (l1 || l2) {
            if (!l1 || !l2) {
                sum = carry + (!l1 ? l2->val : l1->val);
            } else {
                sum = l1->val + l2->val + carry;
            }
            carry = sum / 10;
            cur->next = new ListNode(sum % 10);
            cur = cur->next;
            if (l1) l1 = l1->next;
            if (l2) l2 = l2->next;
        }
        if (carry > 0) {
            cur->next = new ListNode(carry);
        }
        ListNode* ans = dummyHead->next;
        delete dummyHead;
        dummyHead = nullptr;
        return ans;
    }
};
```

### 复杂度分析

- 时间复杂度：O(max(n, m))  

- 空间复杂度：O(1)。返回值不计入空间复杂度。

## :fire:[234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/)

### 题意

给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false` 。

**示例 1：**

![img](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202403091934808.jpeg)

```
输入：head = [1,2,2,1]
输出：true
```

**示例 2：**

![img](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202403091934648.jpeg)

```
输入：head = [1,2]
输出：false
```

**提示：**

- 链表中节点数目在范围`[1, 105]` 内
- `0 <= Node.val <= 9`

**进阶：**你能否用 `O(n)` 时间复杂度和 `O(1)` 空间复杂度解决此题？

### 参考题解

1. [官解](https://leetcode.cn/problems/palindrome-linked-list/solutions/457059/hui-wen-lian-biao-by-leetcode-solution)

### 思路

==:star: **核心思路：反转链表 + 快慢指针  **:star:==

**:key:  key：**

- ![SmartSelect_20240310_100226_Samsung Notes](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202403101003735.jpg)

**:question:   problems:** 

1. 为什么【1.找到前半部分链表的尾节点】中循环条件是`while (fast->next && fast->next->next)`而不是`while (fast && fast->next)`? 可以是`while (fast && fast->next)`吗？

:heavy_check_mark:  **answer:** 

1. 不可以（会很麻烦）。因为要反抓后半部分链表，不仅要找到开始反转的结点，还要找到起始反转结点的前一个结点（即前半部分链表的尾节点）。

    - 如果用while (fast && fast->next) ，那么当节点数为偶数，退出循环时!fast，slow刚好指向开始反转的结点。也就是说此时会获取不到起始反转结点的前一个结点

        ```cpp
         1 2 3 4 5    需要 s 指向 3
        sf   f   f
           s s
        
         1 2 3 4     需要 s 指向 2
        sf   f   f
           s s
        ```

    - 因此要将条件改成`while (fast->next && fast->next->next)`，这样不管节点数为奇数还是为偶数，退出循环时slow都指向起始反转结点的前一个结点。
    
        ```cpp
         1 2 3 4 5 	 需要 s 指向 3
        sf   f   f
           s s
        
         1 2 3 4     需要 s 指向 2
        sf   f   
           s 
        ```
    
        

**:small_red_triangle_down:  steps: **

1. 找到前半部分链表的尾节点:  用快慢双指针(步数是两倍关系)，快指针走到末尾时，慢指针就指向了中间
2. 反转链表后半部分
3. 同向双指针判断是否回文
4. 还原链表（不是必须的，但最好将链表恢复原样，因为使用该函数的人通常不希望链表结构被更改）

### 代码

最后不还原链表的代码

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverse(ListNode* cur) {
        ListNode* pre = nullptr;
        while (cur) {
            ListNode* tmp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = tmp;
        }
        return pre;
    }
    bool isPalindrome(ListNode* head) {
        // 快慢双指针, fast的速度是slow的两倍, 当fast遍历到链表末尾时, slow指向链表中间
        ListNode *slow = head; 
        ListNode *fast = head; 
        // 1. 先找到中间
        while (fast->next && fast->next->next) {
            // 循环条件是细节！！！
            slow = slow->next;
            fast = fast->next->next;
        }
        // 2. 开始反转后半部分链表
        slow->next = reverse(slow->next);
        // 2. 开始判断回文
        fast = slow->next;
        slow = head;
        while (fast) {
            if (slow->val != fast->val) {
                return false;
            }
            slow = slow->next;
            fast = fast->next;
        }
        return true;
    }
};
```

最后还原链表的代码

```c++
class Solution {
public:
    ListNode* reverseList(ListNode* cur) {
        ListNode* pre = nullptr;
        while (cur) {
            ListNode* tmp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = tmp;
        }
        return pre;
    }
    bool isPalindrome(ListNode* head) {
        if (head == nullptr) return true;
        // 1.找到前半部分链表的尾节点
        ListNode* slow = head;
        ListNode* fast = head;
        while (fast->next && fast->next->next) {
            // 循环条件是细节！！！
            slow = slow->next;
            fast = fast->next->next;
        }
        // 两种情况退出循环时slow都指向开始反转的结点的前一个结点
        ListNode* pre = slow;       //开始反转的结点的前一个结点
        ListNode* cur = slow->next; //开始反转的结点
        // 2.反转链表后半部分，并接在链表前半部分的末尾
        pre->next = reverseList(cur);
        // 3.同向双指针判断是否回文
        slow = head;
        fast = pre->next;
        while (fast) {
            if (slow->val != fast->val) {
                return false;
            }
            slow = slow->next;
            fast = fast->next;
        } 
        // 4.还原链表
        pre->next = reverseList(pre->next);
        return true;
    }
};
```

**复杂度分析**

- 时间复杂度：O(n)  

- 空间复杂度：O(1)

### 迭代

```c++

```

**复杂度分析**

- 时间复杂度：O()  

- 空间复杂度：O()

## [lc24 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/) 

```c++
ListNode* swapPairs(ListNode* head) {
    ListNode *dummyhead = new ListNode(0,head), *tmp = nullptr, *pre = dummyhead;
    while (head && head->next) { //交换head和head->next
        // 交换操作
        tmp = head->next;//tmp->2
        head->next = head->next->next;//1->3
        tmp->next = head;//2->  1->3
        pre->next = tmp;//dummyhead->  2->1->3
        // 更新指针
        pre = head;
        head = head->next;
    } 
    return dummyhead->next;
}
```



## [82. 删除排序链表中的重复元素 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/)

### **题意**

给定一个已排序的链表的头 `head` ,  *删除原始链表中所有重复数字的节点, 只留下不同的数字* 。返回 *已排序的链表* 。

**示例 1：**

![img](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202401221037613.jpeg)

```
输入：head = [1,2,3,3,4,4,5]
输出：[1,2,5]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/01/04/linkedlist2.jpg)

```
输入：head = [1,1,1,2,3]
输出：[2,3]
```

**提示：**

- 链表中节点数目在范围 `[0, 300]` 内
- `-100 <= Node.val <= 100`
- 题目数据保证链表已经按升序 **排列**

### 思路

==:star: **核心思路： 双指针  **:star:==

![image-20240115160934861](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202401151609014.png)

### 代码

##### 无注释的版本

```c++
ListNode* deleteDuplicates(ListNode* head) {
    if (!head || !head->next) return head;
    ListNode *dummyhead = new ListNode(0,head);
    ListNode *pre = dummyhead, *p = head; 
    while (p) { 
        while (p->next && p->val == p->next->val) p = p->next; 
        if (pre->next == p) pre = p;
        else pre->next = p->next;
        p = p->next;
    }
    return dummyhead->next;
}
```

##### 带注释的版本

```c++
ListNode* deleteDuplicates(ListNode* head) {
    if (!head || !head->next) return head;
    ListNode *dummyhead = new ListNode(0,head);
    ListNode *pre = dummyhead, *p = head;
    //要删掉p以及所有与之值相同的节点,因此要用pre指向这些值相同的结点的前一个结点（也即新链表的末尾结点）
    while (p) {
        // p负责往后遍历找值相同的结点。如果p没有值相同的结点, 则p的指向不会变, 否则, p会指向值相同结点中的最后一个结点
        while (p->next && p->val == p->next->val) p = p->next;
        // 退出循环时p值!=p->next值

        // 更新新链表的末尾 pre
        if (pre->next == p) pre = p;//p没有值相同的结点
        else pre->next = p->next;//p存在值相同的结点, 全删掉
        p = p->next;
    }
    return dummyhead->next;
}
```

### 复杂度分析

- 时间复杂度：O(n)  

- 空间复杂度：O(1)

