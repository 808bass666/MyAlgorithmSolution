# 目录

[TOC]



## :fire:[102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

### **题意**

给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历**

**提示：**

- 树中节点数目在范围 `[0, 2000]` 内
- `-1000 <= Node.val <= 1000`

[图源自负雪明烛大佬](https://leetcode.cn/problems/binary-tree-level-order-traversal/solutions/244292/tao-mo-ban-bfs-he-dfs-du-ke-yi-jie-jue-by-fuxuemin)

![image-20240224134554808](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202402241345861.png)

### 迭代 BFS

**:question:   problems:** 

1. 不知道怎么给 BFS 遍历的**结果**分层

:heavy_check_mark:  **answer:** 

2. 在每一层出队前，先记录队列中的结点数量 n，并创建一个vector用来存放这一层节点，然后一口气处理完这一层的 n 个结点，处理完之后这一层节点存在的vector push到res。

```c++
vector<vector<int>> levelOrder(TreeNode* root) {
    vector<vector<int>> res;
    if (root == nullptr) return res;
    queue<TreeNode*> que;
    // 迭代
    que.push(root);
    // 先序遍历节点, 一层一层进入弹出，弹出时如果该节点有子结点则将其子结点入队
    while (!que.empty()) {
        int size = que.size();
        vector<int> floor; //存放一层的节点
        while (size--) {
            TreeNode* p = que.front();
            que.pop();
            floor.push_back(p->val);
            if (p->left) que.push(p->left);
            if (p->right) que.push(p->right);
        }
        res.push_back(floor);          
    }
    return res;
}
```

**复杂度分析**

- 时间复杂度：O(n)  

- 空间复杂度：O(n)

### 递归 DFS 

**:small_red_triangle_down:  steps: **

1.  递归参数和返回值：

    - 参数：为了让递归的过程中同一层的节点放到同一个数组中，在递归时要记录每个节点的深度 depth
    - 返回值：void

2.  递归出口：深搜直到为空就返回

3.  单层递归要做什么事？

    1.  如果是第一次来这一层，则需要开辟一个存放该层结点的数组；

        > 第一次来这一层的标志是什么?
        >
        > - 第一次来第0层，res.size()=0，之后要为这一层开辟一个数组，因此res.size()变为1
        > - 第一次来第1层，res.size()=1，之后要为这一层开辟一个数组，因此res.size()变为2
        > - ········ 
        >
        > 由此可知，标志是: `res.size() == depth`    

    2. 将当前深搜的结点值存到对应层的数组中；

    2. 往下(左右子结点)继续深搜

**代码**

```c++
void dfs(TreeNode* p, vector<vector<int>>& res, int depth) {
        // 1.递归参数和返回值：void
        // 2.递归出口：深搜直到为空就返回
        if (p == nullptr) return;
        // 3.单层递归要做什么事？

        // (1)如果是第一次来这一层，则需要开辟一个存放该层结点的数组；
        if (res.size() <= depth) res.push_back(vector<int>());

        // (2) 将当前深搜的结点值存到对应层的数组中；
        res[depth].push_back(p->val);

        // (3) 往下(左右子结点)继续深搜
        dfs(p->left, res, depth + 1);
        dfs(p->right, res, depth + 1);
    }
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        if (root == nullptr) return res;
        dfs(root, res, 0);
        return res;
    }
```

**复杂度分析**

- 时间复杂度：O(n)  

- 空间复杂度：O(n)

## （102变形）[103. 二叉树的锯齿形层序遍历](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/)

### **题意**

给你二叉树的根节点 `root` ，返回其节点值的 **锯齿形层序遍历** 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。

**示例 1：**

![img](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202402241415178.jpeg)

```
输入：root = [3,9,20,null,null,15,7]
输出：[[3],[20,9],[15,7]]
```

**示例 2：**

```
输入：root = [1]
输出：[[1]]
```

**示例 3：**

```
输入：root = []
输出：[]
```

**提示：**

- 树中节点数目在范围 `[0, 2000]` 内
- `-100 <= Node.val <= 100`

### BFS 有三种方法

####  法一

仍旧使用queue. 

当需要从右往左存结果时, reverse存放该层结点的数组再存

```c++
vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
    vector<vector<int>> res;
    if (root == nullptr) return res;

    queue<TreeNode*> que;
    que.push(root);
    bool isOrderLeft = true;  

    while (!que.empty()) {
        int size = que.size();
        vector<int> floor; //存放一层的节点
        while (size--) {
            TreeNode* p = que.front();
            que.pop();
            floor.push_back(p->val);
            if (p->left) que.push(p->left);
            if (p->right) que.push(p->right);
        }
        
        if (!isOrderLeft) reverse(floor.begin(), floor.end());

        res.push_back(floor);
        isOrderLeft = !isOrderLeft;
    }
    return res;
}
```

#### 法二

使用deque. 依旧按照从左到右的顺序将下一层结点进栈. 

存结果时若是从左往右, 则头插结果, 反之则尾插结果

```c++
vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
    vector<vector<int>> res;
    if (root == nullptr) return res;

    queue<TreeNode*> que;
    que.push(root);
    bool isOrderLeft = true;  

    while (!que.empty()) {
        int size = que.size();
        deque<int> floor; //存放一层的节点
        while (size--) {
            TreeNode* p = que.front();
            que.pop();

            // 存放弹出结点时需要根据情况变换顺序
            // 若弹出结点属于[从左往右层], 则将其尾插到floor
            if (isOrderLeft) floor.push_back(p->val);
            // 若弹出结点属于[从右往左层], 则将其头插到floor
            else floor.push_front(p->val);

            // 依旧按照从左到右的顺序将下一层结点进栈
            if (p->left) que.push(p->left);
            if (p->right) que.push(p->right);
        }
        res.push_back(vector<int>{floor.begin(), floor.end()});          
        isOrderLeft = !isOrderLeft;
    }
    return res;
}
```

#### 法三

[参考题解](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/solutions/1455763/jiu-zhi-yong-yi-ge-queue-dui-lie-by-wy-l-8u7s)

不需要使用双端队列.

已知存放每一层结点的数组 floor 的大小, 那么pop存结果时就可以通过 **数组下标 **实现正序存结果和逆序存结果.

将`while (size--)` 改成`for (int i = 0; i < size; i++) `, 当需要从左往右存结果时就直接是`floor[i] = 结点值;`,  当需要从右往左存结果时就是`floor[size - 1 - i] = 结点值;`

```c++
vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
    vector<vector<int>> res;
    if (root == nullptr) return res;

    queue<TreeNode*> que;
    que.push(root);
    bool isOrderLeft = true;  

    while (!que.empty()) {
        int size = que.size();
        vector<int> floor(size); //要初始化容器大小!! 因为后面是用[]来存结点值而不再是用的push_back
        for (int i = 0; i < size; i++) {
            TreeNode* p = que.front();
            que.pop();
            
            floor[isOrderLeft ? i : size - 1 - i] = p->val;
            
            if (p->left) que.push(p->left);
            if (p->right) que.push(p->right);
        } 
        res.push_back(floor);
        isOrderLeft = !isOrderLeft;
    }
    return res;
}
```

### **复杂度分析**

- 时间复杂度：O(n)  

- 空间复杂度：O(n)

## :fire:[104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

### **题意**

给定一个二叉树 `root` ，返回其最大深度。

二叉树的 **最大深度** 是指从根节点到最远叶子节点的最长路径上的节点数。

**示例 1：**

![img](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202402241305220.jpeg)

```
输入：root = [3,9,20,null,null,15,7]
输出：3
```

**示例 2：**

```
输入：root = [1,null,2]
输出：2
```

**提示：**

- 树中节点的数量在 `[0, 104]` 区间内。
- `-100 <= Node.val <= 100`

### 参考题解

1. [看到递归就晕？带你理解递归的本质！](https://www.bilibili.com/video/BV1UD4y1Y769/?share_source=copy_web&vd_source=8086e0fb4ccc0ee9410370076867092c)

### 递归 DFS

![image-20240224130800663](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202402241308698.png)

```c++
int maxDepth(TreeNode* root) {
    // 1.递归参数和返回值：int
    // 2.递归出口：  
    if (root == nullptr) return 0;
    // 3.单层递归要做什么事？ ——求以root为根节点的树的深度。那就得知道其左右子树的深度
    int Ldepth = maxDepth(root->left);
    int Rdepth = maxDepth(root->right);
    return max(Ldepth, Rdepth) + 1;
}
```

**复杂度分析**

- 时间复杂度：O(n)  

- 空间复杂度：O(n)

###  迭代 BFS

层序遍历+队列

**代码**

```c++
int maxDepth(TreeNode* root) {
    if (root == nullptr) return 0;
    int res = 0;
    queue<TreeNode*> que;
    que.push(root);
    while (!que.empty()) {
        res++; //只要que不为空就说明还有至少一层
        int size = que.size();
        while (size--) {
            TreeNode* p = que.front(); que.pop();
            if (p->left) que.push(p->left);
            if (p->right) que.push(p->right);
        }
    }
    return res;
}
```

**复杂度分析**

- 时间复杂度：O(n)  

- 空间复杂度：O(n)

## :fire:[46. 全排列](https://leetcode.cn/problems/permutations/)

### **题意**

给定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。

**示例 1：**

```
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

**示例 2：**

```
输入：nums = [0,1]
输出：[[0,1],[1,0]]
```

**示例 3：**

```
输入：nums = [1]
输出：[[1]]
```

**提示：**

- `1 <= nums.length <= 6`
- `-10 <= nums[i] <= 10`
- `nums` 中的所有整数 **互不相同**

### 参考题解

1. 卡哥

### dfs 回溯 

关键在于 for 和 used数组 的理解上. 都是为了去重, 但是一个是水平方向上的去重, 一个是竖直方向上的去重

![image-20240226145222631](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202402261452754.png)

```c++
class Solution {
private:
    vector<vector<int>> res;
    vector<int> arrange;
public:
    void dfs(vector<int>& nums, vector<int>& used) {
        // 1.递归参数以及返回值: 需要一个used数组标记nums中哪些元素在同一dfs树枝上遍历过
        // 而不再用start控制每次取数只能往后取，
        // 因为对于排列问题有的时候需要再从头去取，因此我们每一次都从头往后取，跳过used数组标记的已取过的数即可
        // 2.递归结束条件
        if (arrange.size() == nums.size()) { //收集结果并return 
            res.push_back(arrange);
            return;
        }
        // 3.单层递归要做什么事? 往下dfs找全排列
        for (int i = 0; i < nums.size(); i++) {
            if (used[i]) continue;//下标为i的元素用过则跳过
            arrange.push_back(nums[i]);
            used[i] = true;      //标记为用过的
            dfs(nums, used);
            arrange.pop_back();  //回溯
            used[i] = false;
        }
    }
    vector<vector<int>> permute(vector<int>& nums) {
        vector<int> used(nums.size(), false);
        dfs(nums, used);
        return res;
    }
};
```

**复杂度分析   **证明可看这->[中间部分](https://leetcode.cn/problems/permutations/solutions/9914/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw)

- 时间复杂度：O(N×N!) 

- 空间复杂度：O(N×N!)


## :fire:[39. 组合总和](https://leetcode.cn/problems/combination-sum/)

### 题意

给你一个 **无重复元素** 的整数数组 `candidates` 和一个目标整数 `target` ，找出 `candidates` 中可以使数字和为目标数 `target` 的 所有 **不同组合** ，并以列表形式返回。你可以按 **任意顺序** 返回这些组合。

`candidates` 中的 **同一个** 数字可以 **无限制重复被选取** 。如果至少一个数字的被选数量不同，则两种组合是不同的。 

对于给定的输入，保证和为 `target` 的不同组合数少于 `150` 个。

**示例 1：**

```
输入：candidates = [2,3,6,7], target = 7
输出：[[2,2,3],[7]]
解释：
2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。
7 也是一个候选， 7 = 7 。
仅有这两种组合。
```

**示例 2：**

```
输入: candidates = [2,3,5], target = 8
输出: [[2,2,2,2],[2,3,3],[3,5]]
```

**示例 3：**

```
输入: candidates = [2], target = 1
输出: []
```

**提示：**

- `1 <= candidates.length <= 30`
- `2 <= candidates[i] <= 40`
- `candidates` 的所有元素 **互不相同**
- `1 <= target <= 40`

### 思路

==:star: **核心思路：回溯 + 剪枝 **:star:==

 ![SmartSelect_20240308_141421_Samsung Notes](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202403081415421.jpg)

### 代码

```c++
class Solution {
public:
    vector<vector<int>> ans;
    vector<int> path;
    void backTracking(vector<int>& candidates, int start, int rest) {
        if (rest == 0) {
            ans.push_back(path);
            return;
        }
        for (int i = start; i < candidates.size(); ++i) {
            if (candidates[i] > rest) return; //剪枝
            path.push_back(candidates[i]);
            backTracking(candidates, i, rest - candidates[i]); 
            path.pop_back(); //回溯
        }
    }
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        sort(candidates.begin(), candidates.end());
        backTracking(candidates, 0, target);
        return ans;
    }
};
```

**复杂度分析**

- 时间复杂度：O(*S*)，其中 S 为所有可行解的长度之和

- 空间复杂度：O(target)

## [:fire:236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

### **题意**

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

**示例 1：**

![img](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202402262226834.png)

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
```

**示例 2：**

![img](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202402262226834.png)

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出：5
解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
```

**示例 3：**

```
输入：root = [1,2], p = 1, q = 2
输出：1
```

**提示：**

- 树中节点数目在范围 `[2, 105]` 内。
- `-109 <= Node.val <= 109`
- 所有 `Node.val` `互不相同` 。
- `p != q`
- `p` 和 `q` 均存在于给定的二叉树中。

### DFS 

经典递归

```c++
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    // 1.二叉树遍历顺序: 后序遍历
    // 2.递归参数以及返回值: 返回值TreeNode*
    // 3.递归结束条件: 遍历到nullptr || p || q
    if (root == nullptr || root == p || root == q) return root;
    // 4.单层递归做什么事? :看p和q是否存在与自己部门,如果存在则将其上报
    TreeNode* lson = lowestCommonAncestor(root->left, p, q);
    TreeNode* rson = lowestCommonAncestor(root->right, p, q);
    // 如果lson和rson都不为空,则root就是最近公共祖先
    if (lson != nullptr && rson != nullptr) return root;
    else if (lson != nullptr) return lson;
    else if (rson != nullptr) return rson;
    else return nullptr;
}
```

#### 复杂度分析

- 时间复杂度：O(n)  

- 空间复杂度：O(n)

## [:fire:124. 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)

### **题意**

二叉树中的 **路径** 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 **至多出现一次** 。该路径 **至少包含一个** 节点，且不一定经过根节点。

**路径和** 是路径中各节点值的总和。

给你一个二叉树的根节点 `root` ，返回其 **最大路径和** 。

**示例 1：**

![img](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202402281114828.jpeg)

```
输入：root = [1,2,3]
输出：6
解释：最优路径是 2 -> 1 -> 3 ，路径和为 2 + 1 + 3 = 6
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg)

```
输入：root = [-10,9,20,null,null,15,7]
输出：42
解释：最优路径是 15 -> 20 -> 7 ，路径和为 15 + 20 + 7 = 42
```

**提示：**

- 树中节点数目范围是 `[1, 3 * 104]`
- `-1000 <= Node.val <= 1000`

### 参考题解

1. [我爱讨论区！！！](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/solution/shou-hui-tu-jie-hen-you-ya-de-yi-dao-dfsti-by-hyj8/)

### DFS 

![image-20240228131310738](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202402281313805.png)

**:x: careless | ignore :**

- 只要看到题目提示中说结点值可能为负就要特别注意返回值的选取！！返回0或INT_MIN都会比较麻烦。

    > 这题和:fire:[543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/) 主要的区别其中之一就是这。

#### 代码

##### 详细注释版

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int NoAddUpSum = INT_MIN; //【不可递归累加】的最大路径和
    // 不能初始化为0, 原因同不能return 0一样
    
    int dfs(TreeNode* root) {
        // 以root为根节点的子树的最大路径和要分两种情况讨论:
        // 1."可向上累加"的最大路径和 = max(max(根, 根左, 根右), 之前的"可向上累加"的最大路径和)
        // 2."不可向上累加"的最大路径和 = max(根左右, 左, 右)

        // 1.遍历顺序：后序遍历, 要根据左右子的最大路径和才能知道root的··
        // 2.结束条件
        if (root == nullptr) return -2000;
        // 因为结点可能值为负, 因此不能return 0 !!!

        // 3.单层递归做啥事? 
        // 求以root为根节点的子树的最大" 可+不可 向上累加"的路径和,
        // 并返回以root为根节点的子树的最大"可向上累加"的路径和

        int LeftAddUpSum = dfs(root->left);  //左
        int RightAddUpSum = dfs(root->right);//右
        // 中
        // 中.【可递归累加】的最大路径和
        int AddUpSum =  root->val + max(0, max(LeftAddUpSum, RightAddUpSum));
        // 中.【不可递归累加】的最大路径和
        int sum = max(root->val + LeftAddUpSum + RightAddUpSum, max(LeftAddUpSum, RightAddUpSum));
        NoAddUpSum = max(sum, NoAddUpSum);

        return AddUpSum;
    }
    int maxPathSum(TreeNode* root) { 
        // 为什么不能把所有逻辑都写在maxPathSum函数而要再开一个? --因为root的最大路径和不一定就是AddUpSum
        return max(NoAddUpSum, dfs(root));
    }
};
```

##### 精简注释版

```cpp
class Solution {
public:
    int NoAddUpSum = INT_MIN; 
    
    int dfs(TreeNode* root) {
        if (root == nullptr) return -2000;

        int LeftAddUpSum = dfs(root->left);  //左
        int RightAddUpSum = dfs(root->right);//右
        // 中
        int AddUpSum =  root->val + max(0, max(LeftAddUpSum, RightAddUpSum));
        int sum = max(root->val + LeftAddUpSum + RightAddUpSum, max(LeftAddUpSum, RightAddUpSum));
        NoAddUpSum = max(sum, NoAddUpSum);

        return AddUpSum;
    }
    int maxPathSum(TreeNode* root) { 
        return max(NoAddUpSum, dfs(root));
    }
};
```

而如果递归结束的条件是：`if (root == nullptr) return 0;`，则需要额外增加一些判断逻辑:

```c++
class Solution {
public:
    int NoAddUpSum = INT_MIN; 
    int dfs(TreeNode* root) {
        if (root == nullptr) return 0; 

        int left_addUp_max = dfs(root->left);
        int right_addUp_max = dfs(root->right);

        int AddUpSum = max({left_addUp_max, right_addUp_max, 0}) + root->val;
        int sum = root->val + max({left_addUp_max, 0}) + max({right_addUp_max, 0});
        NoAddUpSum = max(sum, NoAddUpSum);

        return AddUpSum;
    }
    int maxPathSum(TreeNode* root) {
        return max(NoAddUpSum, dfs(root));
    } 
};
```

##### 复杂度分析

- 时间复杂度：O(n)  。因为每个结点只会遍历一次（从下往上归）。  
- 空间复杂度：O(n)

## :fire:[543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)

### **题意**

给你一棵二叉树的根节点，返回该树的 **直径** 。

二叉树的 **直径** 是指树中任意两个节点之间最长路径的 **长度** 。这条路径可能经过也可能不经过根节点 `root` 。

两节点之间路径的 **长度** 由它们之间边数表示。

**示例 1：**

![img](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202402281626466.jpeg)

```
输入：root = [1,2,3,4,5]
输出：3
解释：3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度。
```

**示例 2：**

```
输入：root = [1,2]
输出：1
```

**提示：**

- 树中节点数目在范围 `[1, 104]` 内
- `-100 <= Node.val <= 100`

### 参考题解

1. 和上一题 [:fire:124. 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/) 几乎没差，只不过这个是求边的个数而不是结点个数。

### DFS 

**第一种写法：按结点个数来求，最后将结果-1 即为边数。**

```c++
class Solution {
public:
    int maxLen = 0;
    int dfs(TreeNode* root) {
        // 1.遍历顺序：后序遍历, 要根据左右子的最长路径知root的··
        // 2.递归结束的条件
        if (root == nullptr) return 0;
        // 3.单层递归做啥事？求以root为根节点的树的直径
        int leftMaxLen = dfs(root->left);
        int rightMaxLen = dfs(root->right);
        // 【不往上递归累加】的最长路径 = 根左右
        maxLen = max(maxLen, 1 + leftMaxLen + rightMaxLen); 
        // 【 往上递归累加】的最长路径 = 根 + max(左,右)
        return 1 + max(leftMaxLen, rightMaxLen);
    }
    int diameterOfBinaryTree(TreeNode* root) {
        int ans = max(maxLen, dfs(root));
        return ans > 0 ? ans - 1 : 0;
    }
};
```

**第二种写法：就按边的个数来求。**

```c++
class Solution {
public:
    int maxLen = 0;
    int dfs(TreeNode* root) {
        // 1.遍历顺序：后序遍历, 要根据左右子的最长路径知root的··
        // 2.递归结束的条件
        if (root == nullptr) return -1;
        // 当root为叶子节点时，其两个最长路径的值都应该是0，
        // 也就是说2+leftMaxLen+rightMaxLen和1+max(leftMaxLen,rightMaxLen)都要==0,
        // 因此leftMaxLen和rightMaxLen都要=-1, 因此递归结束return -1;

        // 3.单层递归做啥事？求以root为根节点的树的直径
        int leftMaxLen = dfs(root->left);
        int rightMaxLen = dfs(root->right);
        // 【不往上递归累加】的最长路径 = 根左右
        maxLen = max(maxLen, 2 + leftMaxLen + rightMaxLen);
        // 【 往上递归累加】的最长路径 = 根 + max(左,右)
        return 1 + max(leftMaxLen, rightMaxLen);
    }
    int diameterOfBinaryTree(TreeNode* root) {
        return max(maxLen, dfs(root));
    }
};
```

#### 复杂度分析

- 时间复杂度：O(n)。因为每个结点只会遍历一次（从下往上归）。  

- 空间复杂度：O(n)

## :fire:[94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/) 

### 题意

给定一个二叉树的根节点 `root` ，返回 *它的 **中序** 遍历* 。

**示例 1：**

![img](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202402291030016.jpeg)

```
输入：root = [1,null,2,3]
输出：[1,3,2]
```

**示例 2：**

```
输入：root = []
输出：[]
```

**示例 3：**

```
输入：root = [1]
输出：[1]
```

**提示：**

- 树中节点数目在范围 `[0, 100]` 内
- `-100 <= Node.val <= 100`

**进阶:** 递归算法很简单，你可以通过迭代算法完成吗？

### 参考题解

1. 迭代的颜色标记法：[henry](https://leetcode.cn/problems/binary-tree-inorder-traversal/solutions/25220/yan-se-biao-ji-fa-yi-chong-tong-yong-qie-jian-ming)

### 递归

```c++
class Solution {
public:  
    vector<int> res;
    void dfs(TreeNode* root) {
        if (root == nullptr) return;
        dfs(root->left);
        res.push_back(root->val);
        dfs(root->right);
    }
    vector<int> inorderTraversal(TreeNode* root) {
        dfs(root);
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：O(n)  

- 空间复杂度：O(n)

### 迭代

==:star: **核心思路：颜色标记法  **:star:==  如要实现前序、后序遍历，只需要调整左右子节点的入栈顺序即可

**:key:  key：**

- ![image-20240229130423581](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202402291304638.png)

- 即第一次走到根的时候，先不将其放入结果，先存到栈中等着（同时将其左右子都push进栈）；
    等到其左子树的所有节点都出栈之后，根在紧跟着出来。![image-20240309183245679](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202403091832743.png)

#### 代码

```c++
vector<int> inorderTraversal(TreeNode* root) {
    const int WHITE = 0; //【隐忍不发】走过该节点，但那时它只是暂存在栈中
    const int GREY  = 1; //【出头之日】如果访问到某节点时它是灰色，那它就要存入结果了

    vector<int> res;
    stack<pair<int, TreeNode*>> st;
    st.push({WHITE, root});
    
    while (!st.empty()) { 
        auto [color, node] = st.top();  st.pop();

        if (node == nullptr) continue;
        
        // 该节点【隐忍不发】，将其以及左右孩入栈
        if (color == WHITE) { 
            st.push({WHITE, node->right}); 
            st.push({GREY, node});
            st.push({WHITE, node->left});
        } else {  
        // 该节点【出头之日】，存入结果
            res.push_back(node->val);
        }
    }
    return res;
}
```

#### 复杂度分析

- 时间复杂度：O(2n)，即O(n)  

- 空间复杂度：O(n)

## :fire:[22. 括号生成](https://leetcode.cn/problems/generate-parentheses/)

### **题意**

数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合. 

**示例 1：**

```
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
```

**示例 2：**

```
输入：n = 1
输出：["()"]
```

**提示：**

- `1 <= n <= 8`

### 递归 

**:key:  key：**

- 画出树形图，想清楚剪枝条件就没什么难度了。

#### 代码

```c++
class Solution {
public:
    vector<string> res;
    string path = "(";
    void backTracing(int n, int leftCnt, int rightCnt) {
        // 2.递归结束的条件
        if (leftCnt == n && rightCnt == n) {
            res.push_back(path);
            return;
        }
        // 3.单层递归做啥事？生成可能的括号
        // 两个剪枝：(1)右括号数>左括号数时 (2)左括号数>n时
        if (leftCnt + 1 <= n) {
            path += '(';
            backTracing(n, leftCnt + 1, rightCnt);
            path.pop_back();
        }
        if (rightCnt + 1 <= n && rightCnt + 1 <= leftCnt) {
            path += ')';
            backTracing(n, leftCnt, rightCnt + 1);
            path.pop_back();
        }
    }
    vector<string> generateParenthesis(int n) {
        backTracing(n, 1, 0);
        return res;
    }
};
```



将回溯的逻辑写在函数调用中 的版本：

> 注意！如果backTracing第一个参数`const string& path`不加`const`会报错：
>
> ```c++
> error: non-const lvalue reference to type 'basic_string<...>' cannot bind to a temporary of type 'basic_string<...>' .
> 
> backTracing(path + '(', n, leftCnt + 1, rightCnt);              
> 			  ^~~~~~ 
> ```
>
> > 原因：
> >
> > 这个报错意味着你在尝试将一个临时的string对象（temporary object）绑定到一个非const的引用上。
> >
> > **==在C++中，非const的引用不能绑定到临时对象上==，因为临时对象可能会在表达式结束时被销毁，这样引用就会指向一个不存在的对象。**
>
> > 解决：
> >
> > 为了解决这个问题，你可以将引用声明为const，或者将临时对象存储在一个变量中，再将变量的引用传递给函数或表达式。这样可以确保引用指向的对象在引用的生命周期内是有效的。

```c++
class Solution {
public:
    vector<string> res; 
    void backTracing(const string& path, int n, int leftCnt, int rightCnt) {
        // 2.递归结束的条件
        if (leftCnt == n && rightCnt == n) {
            res.push_back(path);
            return;
        }
        // 3.单层递归做啥事？生成可能的括号
        // 两个剪枝：(1)右括号数>左括号数时 (2)左括号数>n时
        if (leftCnt + 1 <= n) {
            backTracing(path + '(', n, leftCnt + 1, rightCnt);
        }
        if (rightCnt + 1 <= n && rightCnt + 1 <= leftCnt) {
            backTracing(path + ')', n, leftCnt, rightCnt + 1);
        }
    }
    vector<string> generateParenthesis(int n) {
        backTracing("(", n, 1, 0);
        return res;
    }
};
```

#### 复杂度分析 

> 来源：[力扣官方题解](https://leetcode.cn/problems/generate-parentheses/solutions/192912/gua-hao-sheng-cheng-by-leetcode-solution/)

- 时间复杂度： $ O(\dfrac{4^n}{\sqrt{n}}) $
- 空间复杂度：O(n)。除了答案数组之外，我们所需要的空间取决于递归栈的深度，最多递归 2n 层，因此空间复杂度为 O(n)

## :fire:[105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

### 题意

给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的**先序遍历**， `inorder` 是同一棵树的**中序遍历**，请构造二叉树并返回其根节点。

**示例 1:**

![img](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202403032226914.jpeg)

```
输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
输出: [3,9,20,null,null,15,7]
```

**示例 2:**

```
输入: preorder = [-1], inorder = [-1]
输出: [-1]
```

**提示:**

- `1 <= preorder.length <= 3000`
- `inorder.length == preorder.length`
- `-3000 <= preorder[i], inorder[i] <= 3000`
- `preorder` 和 `inorder` 均 **无重复** 元素
- `inorder` 均出现在 `preorder`
- `preorder` **保证** 为二叉树的前序遍历序列
- `inorder` **保证** 为二叉树的中序遍历序列

### 第一种、未优化的版本

==:star: **核心思路：递归分治   **:star:==

**:key:  key：**

分治法的思想：**把原问题拆解成若干个与原问题结构相同但规模更小的子问题，待子问题解决以后，原问题就得以解决。**

原问题：构建一个二叉树需要构建三部分：root、左子树、右子树
子问题：左子树、右子树的构建，又包括：root、左子树、右子树

解题关键在于定位出根节点，划分出左右子树，然后 递归构建左右子树（解决子问题），（原问题就得以解决），返回该根节点的构建结果（向上归）。

**:small_red_triangle_down:  steps: **

1.  切割中序序列和先序序列，得到根节点的左右子树的中序序列和先序序列。
    - 怎么切割才能得到···？
        1. 先要找到根，怎么找？先序序列的首元素就是根的值。由于序列中无重复元素，因此直接拿着 root->val 去找其在中序序列中的位置。
        2. 该位置将中序序列分成三部分（左根右）。至此，中序序列切割成功，还差先序序列。
        3. 用切割得到的中序序列左区间的大小，去切割先序序列。至此，先序序列也切割成功。
1.  递归构建左右子树
1.  向上级返回自己的构建结果

#### 代码

带step注释版：

```c++
TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
    if (preorder.size() == 0) return nullptr;
    //1、用先序找到根节点的值
    int rootValue = preorder[0];
    TreeNode* root = new TreeNode(rootValue); 
    if (preorder.size() == 1) return root;
    //2、利用先序得到的根的值在中序中找到根的位置
    int i = 0;
    while (inorder[i] != rootValue) i++;
    //3、利用根的位置i切割中序: [0,i) i [i+1,end)
    vector<int> leftInorder(inorder.begin(), inorder.begin() + i);
    vector<int> rightInorder(inorder.begin() + i + 1, inorder.end());
    //4、利用中序的左区间大小[0,i)=i切割先序: [1,i+1) [i+1,end)
    vector<int> leftPreorder(preorder.begin() + 1, preorder.begin() + i + 1);
    vector<int> rightPreorder(preorder.begin() + i + 1, preorder.end()); 
    //5、递归构建左右子树
    root->left = buildTree(leftPreorder, leftInorder); 
    root->right = buildTree(rightPreorder, rightInorder); 
    //6、向上级返回自己的构建结果
    return root;
}
```

带递归三部曲注释版：

```c++
TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
    // 1、递归参数以及返回值：参数(先序和中序序列)、返回值(结点)
    // 2、递归结束的条件
    if (preorder.size() == 0) return nullptr;
    int rootValue = preorder[0];
    TreeNode* root = new TreeNode(rootValue); 
    if (preorder.size() == 1) return root;
    // 3、单层递归逻辑：该根节点(preorder[0])需要构建其树，并将其成果交给上头 
    // (1) 切割
    int i = 0;
    while (inorder[i] != rootValue) i++; 
    vector<int> leftInorder(inorder.begin(), inorder.begin() + i);			 //左中序
    vector<int> rightInorder(inorder.begin() + i + 1, inorder.end()); 		 //右中序
    vector<int> leftPreorder(preorder.begin() + 1, preorder.begin() + i + 1);//左先序
    vector<int> rightPreorder(preorder.begin() + i + 1, preorder.end()); 	 //右先序 
    // (2) 递归构建左右子树（解决子问题）
    root->left = buildTree(leftPreorder, leftInorder); 
    root->right = buildTree(rightPreorder, rightInorder);
    // (3) 向上归
    return root;
}
```

#### 复杂度分析

- 时间复杂度：O(n^2^)  每次递归就会创建一个新节点，需要创建n个结点，因此递归n次，每一次递归的时间复杂度是O(n)。因此总时间复杂度是O(n^2^)。

- 空间复杂度：O(n)。

### 第二种、优化后的版本

>  优化一、
>
>  问题：每次都要扫描中序遍历找根节点，时间复杂度较高。
>
>  办法：可以使用哈希表O(1)快速定位根节点。选择使用哈希map进行哈希映射，key为值，value为其在中序遍历中的出现位置，在构造二叉树之前遍历一遍中序遍历，就可以构造出哈希映射，往后构造的过程中就只需要O(1)的时间就能快速在中序中定位根节点
>
>  优化二、
>
>  问题：每次递归都需要拷贝中序数组和前序数组的左右区间，时间复杂度高。
>
>  办法：可以在函数中传下标表示区间范围，这样就不需要多次拷贝容器了 

代码思路还是跟654题一模一样，可以说，构造二叉树的题递归代码都差不多！

这道题的思路用一下图片即可说明：

<img src="https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202404172053634.webp" alt="图片" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202404172053205.webp" alt="图片" style="zoom:50%;" />

> [详细思路可以看这里](https://mp.weixin.qq.com/s/OlpaDhPDTJlQ5MJ8tsARlA)

#### 代码

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:
    unordered_map<int, int> mp;
public: 
    TreeNode* recursion(vector<int>& preorder, int preL, int preR, int inL) {
        // [preL, preR) 左闭右开区间

        // 2、递归结束的条件
        if (preR == preL) return nullptr;
        int rootValue = preorder[preL];
        TreeNode* root = new TreeNode(rootValue); 
        if (preR - preL == 1) return root;
        // 3、单层递归逻辑：该根节点(preorder[0])需要构建其树，并将其成果交给上头 
        // (1) 切割：用rootVal找到其在中序中的位置，用index得到其在中序左区间的size，以分割先序
        int index = mp[rootValue];
        int inLeftSize = index - inL; //中序左区间大小
        // (2) 递归构建左右子树（解决子问题）
        root->left  = recursion(preorder, preL + 1, preL + 1 + inLeftSize, inL); 
        root->right = recursion(preorder, preL + inLeftSize + 1, preR, index + 1);
        // (3) 向上归
        return root;
    }
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        for (int i = 0; i < inorder.size(); ++i) {
            mp[inorder[i]] = i;
        }
        return recursion(preorder, 0, preorder.size(), 0);
    }
};
```

#### 复杂度分析

- 时间复杂度：O(n)  

- 空间复杂度：O(n)

## :fire:[78. 子集](https://leetcode.cn/problems/subsets/)

### 题意

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。

**示例 1：**

```
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```

**示例 2：**

```
输入：nums = [0]
输出：[[],[0]]
```

**提示：**

- `1 <= nums.length <= 10`
- `-10 <= nums[i] <= 10`
- `nums` 中的所有元素 **互不相同**

### 参考题解

1. [卡哥](https://leetcode.cn/problems/subsets/solutions/850474/dai-ma-sui-xiang-lu-78-zi-ji-hui-su-sou-6yfk6)

### 思路

==:star: **核心思路：回溯  **:star:==

### ![SmartSelect_20240305_101644_Samsung Notes](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202403051015438.jpg)

```c++
void recursion(vector<int>& nums, vector<vector<int>> &ans, vector<int>& subset, int start) {
    // 1. 递归参数以及返回值:参数(start用于去重)
    // 2. 递归结束的条件
    if (start == nums.size()) {
        return;
    }
    for (int i = start; i < nums.size(); ++i) {
        subset.push_back(nums[i]);
        // 树中一个结点就是一个子集
        ans.push_back(subset);
        // 注意传的最后一个参不是start + 1 !!!
        recursion(nums, ans, subset, i + 1);
        subset.pop_back(); //回溯
    }
}
vector<vector<int>> subsets(vector<int>& nums) {
    vector<vector<int>> ans;
    vector<int> subset;
    // 空子集也是子集
    ans.push_back(subset);
    recursion(nums, ans, subset, 0);
    return ans;
}
```

**复杂度分析**

- 时间复杂度：O(n×2^n^)。一共 2^n^ 个状态，每种状态需要 O(n)的时间来构造子集。 
- 空间复杂度：O(n)

## :fire:[101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)

### 题意

给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

**示例 1：**

![img](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202403080842063.png)

```
输入：root = [1,2,2,3,4,4,3]
输出：true
```

**示例 2：**

![img](https://pic.leetcode.cn/1698027008-nPFLbM-image.png)

```
输入：root = [1,2,2,null,3,null,3]
输出：false
```

 

**提示：**

- 树中节点数目在范围 `[1, 1000]` 内
- `-100 <= Node.val <= 100`

**进阶：**你可以运用递归和迭代两种方法解决这个问题吗？

### 递归

首先想清楚判断对称二叉树要比较的是什么，不是左孩子和右孩子是否相等，而是左右子的外侧是否相等，内侧是否相等。

![SmartSelect_20240308_103113_Samsung Notes](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202403081033138.jpg)

#### 代码

```c++
bool compare(TreeNode* leftNode, TreeNode* rightNode){
    /* 1.递归参数及返回值：
        由于判断二叉树是否对称比较的是左右子的外侧是否相等，内侧是否相等，
        因此需要传左右子结点进来比较，而不能只传一个root */
    // 2.终止条件: 含空节点 || 数值不相同
    if (!leftNode && !rightNode) {
        return true;
    } else if (!leftNode || !rightNode) {
        return false;
    } else if (leftNode->val != rightNode->val) {
        return false;
    }
    // 3.单层递归做啥事？
    // 让下级判断leftNode的外侧与rightNode的外侧是否相等，内侧与内侧是否相等
    // 自己再汇总结果并上交
    bool outside = compare(leftNode->left, rightNode->right);
    bool inside = compare(leftNode->right, rightNode->left);
    return outside && inside;
}
bool isSymmetric(TreeNode* root) {
    if (root == nullptr) return true;
    return compare(root->left, root->right);
}
```

#### 复杂度分析

- 时间复杂度：O(n)  

- 空间复杂度：O(n)

### 迭代

 ![image-20240308103319676](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202403081033725.png)

注意不要push(root)进去！！！

#### 代码

```c++
bool isSymmetric(TreeNode* root) {
    if (root == nullptr) return true;
    queue<TreeNode*> que;
    que.push(root->left); 
    que.push(root->right); 
    while (!que.empty()) {
        TreeNode* leftNode  = que.front();  que.pop();
        TreeNode* rightNode = que.front();  que.pop();

        if (!leftNode && !rightNode) continue;
        if (!leftNode || !rightNode) return false;
        if (leftNode->val != rightNode->val) return false;
        
        que.push(leftNode->left);
        que.push(rightNode->right); 
        que.push(leftNode->right); 
        que.push(rightNode->left);
    }
    return true;
}
```

#### 复杂度分析

- 时间复杂度：O(n)  

- 空间复杂度：O(n)

## :fire:[98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)

### 题意

给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。

**有效** 二叉搜索树定义如下：

- 节点的左子树只包含小于当前节点的数。
- 节点的右子树只包含 **大于** 当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

 **示例 1：**

![img](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202403090853916.jpeg)

```
输入：root = [2,1,3]
输出：true
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg)

```
输入：root = [5,1,4,null,null,3,6]
输出：false
解释：根节点的值是 5 ，但是右子节点的值是 4 。
```

**提示：**

- 树中节点数目范围在`[1, 104]` 内
- `-231 <= Node.val <= 231 - 1`

### 法一

==:star: **核心思路：用BST性质先序遍历**:star:==

该题必须用long表示正无穷和负无穷。

**:x: careless | ignore :**

- 不能单纯的比较 左结点小于根&&右结点大于根 就完事了。这样最多只能判断当前三个结点是符合BST性质的，但是整个子树不一定符合。相当于是只向上交了自己做的事，但是没有把下级做的事上交。

    ————我们要比较的是 左子树**所有节点**小于根，右子树**所有节点**大于根。

```c++
class Solution {
public:
    bool preTraversal(TreeNode* root, long root_lowerBound, long root_upperBound) { 
        // BST满足 左 < 根 < 右
        if (root == nullptr) return true; 
        // 1.自己干的活
        bool base = root_lowerBound < root->val && root->val < root_upperBound;
        if (!base) return false;
        // 2.下属干的活
        bool is_leftVaild  = preTraversal(root->left, root_lowerBound, root->val);
        bool is_rightVaild = preTraversal(root->right, root->val, root_upperBound);
        // 3.将结果交给上级
        return is_leftVaild && is_rightVaild;
    } 
    bool isValidBST(TreeNode* root) { 
        return preTraversal(root, LONG_MIN, LONG_MAX);
    }
};
 
```

优化（用&&将三个条件连接起来的话，若第一个条件不满足则后面两个条件就不会再去判断，也就不会再进行后面的递归），但是可读性就没那么好

```c++
bool preTraversal(TreeNode* root, long left, long right) {  
    if (root == nullptr) return true;
    long mid = root->val;
    return root_lowerBound < mid && mid < root_upperBound
     && preTraversal(root->left, root_lowerBound, mid)
     && preTraversal(root->right, mid, root_upperBound);
}  
```

**复杂度分析**

- 时间复杂度：O(n)  

- 空间复杂度：O(n)

### 法二（看这个就行）

==:star: **核心思路： BST中序序列性质：升序  **:star:==

**:key:  key：**

- 二叉搜索树「中序遍历」得到的值构成的序列一定是升序的，这启示我们在中序遍历的时候实时检查当前节点的值是否大于前一个中序遍历到的节点的值（记为lastIsMax）即可。如果不大于说明当前结点的左子树中出现了比自己还大的，直接return false.

#### 递归代码

##### 正确写法1

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    long lastIsMax = LONG_MIN; //记录目前为止的升序序列的最后一个值
    bool isValidBST(TreeNode* root) {
        // 利用BST左中右单调递增的性质,一旦递增被破坏,就return false;
        // 中序遍历时不断更新lastIsMax，一旦发现lastIsMax >= root->val，就返回false
        if (!root) return true;
        // 左
        if (!isValidBST(root->left)) return false;
        if (root->val <= lastIsMax) return false;
        // 中，更新lastIsMax为当前root值
        lastIsMax = root->val;
        // 右
        if (!isValidBST(root->right)) return false;
        // 下面这句可写可不写，但是一定不能写成if (root->val >= lastIsMax) return false;
        if (root->val > lastIsMax) return false;
        return true;
    }
};
```

> 关于这一句`if (root->val > lastIsMax) return false;`
>
> 1. 为什么说这句可写可不写？
>     - 因为实际在上一步isValidBST(root->right)就已经做了这一步判断
> 2. 为什么不能写成大于等于？
>     - 因为前面已经将lastIsMax更新为root->val了，因此这一步判断如果有等于的话，就会进入if逻辑return false

##### 递归优化

如果测试用例中有比LONG_MIN还小的值怎么办呢？因此建议避免 初始化最小值，而是取到最左节点的数值来比较

```c++
class Solution {
public:
    TreeNode* lastIsMax = nullptr;
    bool isValidBST(TreeNode* root) {
        if (root == nullptr) return true;
        // 中序遍历时不断更新lastIsMax，一旦发现lastIsMax >= root->val，就返回false
        bool is_leftVaild = isValidBST(root->left); 
        // 会一路递归到最左节点，到底之后lastIsMax会更新为最左节点，然后往根走
        if (lastIsMax && root->val <= lastIsMax->val)  return false;
        // 更新lastIsMax为当前结点 
        lastIsMax = root;
        bool is_rightVaild = isValidBST(root->right); 
        return is_leftVaild && is_rightVaild;
    }
};
```

#### 迭代代码

用栈来模拟中序遍历的过程。

一、颜色标记法 写中序：

```c++
bool isValidBST(TreeNode* root) {
    const int WHITE = 0; //【隐忍不发】走过该节点，但那时它只是暂存在栈中
    const int GREY  = 1; //【出头之日】如果访问到某节点时它是灰色，那它就要存入结果了

    long lastIsMax = LONG_MIN; //当前中序序列的最后一个节点的值
    stack<pair<int, TreeNode*>> st;
    st.push({WHITE, root});
    
    while (!st.empty()) { 
        auto [color, node] = st.top();  st.pop();

        if (node == nullptr) continue;
        
        // 该节点【隐忍不发】，将其以及左右孩入栈
        if (color == WHITE) { 
            st.push({WHITE, node->right}); 
            st.push({GREY, node});
            st.push({WHITE, node->left});
        } else {  
        // 该节点【出头之日】，存入结果
            if (node->val <= lastIsMax) {
                return false;
            }
            // 实时更新中序序列的最后一个结点 lastIsMax
            lastIsMax = node->val;
        }
    }
    return true;
}
```

 二、传统中序写法：

```c++
bool isValidBST(TreeNode* root) { 
    long lastIsMax = LONG_MIN; //当前中序序列的最后一个节点的值
    stack<TreeNode*> st;
    TreeNode* cur = root;
    while(!st.empty() || cur) {
        // 一路向左压栈直到最左
        while (cur) {
            st.push(cur);
            cur = cur->left;//左
        }
        cur = st.top(); st.pop();//中
        if (cur->val <= lastIsMax) {
            return false;
        }
        lastIsMax = cur->val;
        cur = cur->right;//右
    }
    return true;
}
```

同递归一样可以优化：

```c++
class Solution {
public: 
    TreeNode* pre = nullptr;//当前中序序列的最后一个节点
	bool isValidBST(TreeNode* root) {
        stack<TreeNode*> st;
        TreeNode* cur = root;
        while(!st.empty() || cur) {
            while (cur) {
                st.push(cur);
                cur = cur->left;//左
            }
            cur = st.top(); st.pop();//中
            if (pre && pre->val >= cur->val) {
                return false;
            }
            pre = cur;
            cur = cur->right;//右
        }
        return true;
    }
}
```

**复杂度分析**

- 时间复杂度：O(n)  

- 空间复杂度：O(n)

## :fire:[226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)

### 题意

给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg)

```
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
```

**示例 2：**

![img](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202403111254708.jpeg)

```
输入：root = [2,1,3]
输出：[2,3,1]
```

**示例 3：**

```
输入：root = []
输出：[]
```

**提示：**

- 树中节点数目范围在 `[0, 100]` 内
- `-100 <= Node.val <= 100`

### 参考题解

1. [王尼玛](https://leetcode.cn/problems/invert-binary-tree/solutions/73159/dong-hua-yan-shi-liang-chong-shi-xian-226-fan-zhua)  动画很直观

### 递归

**:question:   problems:** 

1. 为什么不能写成这样?

    ```c++
    TreeNode* invertTree(TreeNode* root) {
        // 2.结束条件 
        if (!root) return nullptr; 
        // 3.单层逻辑：将自己的左右子翻转，合并上左右子树的翻转结果，交给上级
        root->left = invertTree(root->right);
        root->right = invertTree(root->left); 
        return root;
    }
    ```

:heavy_check_mark:  **answer:** 

1. 因为`root->left = invertTree(root->right);` 这一步已经把root->left 改了 ！！其下一行用的root->left就不是自己以为的原来的左子，自己带入三个结点就能发现问题。

    如果在翻转左子树之前暂存左子就可以：

    ```c++
    TreeNode* invertTree(TreeNode* root) {
        // 2.结束条件 
        if (!root) return nullptr; 
        // 3.单层逻辑：将自己的左右子翻转，合并上左右子树的翻转结果，交给上级
        TreeNode *origin = root->left;
        
        root->left = invertTree(root->right);
        root->right = invertTree(origin); 
        return root;
    }
    ```

#### 代码

```c++
TreeNode* invertTree(TreeNode* root) {
    // 2.结束条件 
    if (!root) return nullptr; 
    // 3.单层逻辑：将自己的左右子翻转，合并上左右子树的翻转结果，交给上级
    swap(root->left, root->right); 
    invertTree(root->left);
    invertTree(root->right);
    return root;
}
```

#### 复杂度分析

- 时间复杂度：O(n)  

- 空间复杂度：O(n)

### 迭代

**层序遍历**

```c++
TreeNode* invertTree(TreeNode* root) {
    if (!root) return nullptr;
    queue<TreeNode*> que;
    que.push(root);
    while (!que.empty()) {
        TreeNode* cur = que.front(); que.pop();
        if (cur->left) que.push(cur->left);
        if (cur->right) que.push(cur->right);
        //swap放在两个push的前面或者后面都行
        swap(cur->left, cur->right); 
    }
    return root;
}
```

复杂度分析

- 时间复杂度：O(n)  

- 空间复杂度：O(n)

## :fire:[297. 二叉树的序列化与反序列化](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/)

### 题意

序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。

请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。

**提示:** 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 [LeetCode 序列化二叉树的格式](https://support.leetcode.cn/hc/kb/article/1567641/)。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。

**示例 1：**

![img](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202403152057345.jpeg)

```
输入：root = [1,2,3,null,null,4,5]
输出：[1,2,3,null,null,4,5]
```

**示例 2：**

```
输入：root = []
输出：[]
```

**示例 3：**

```
输入：root = [1]
输出：[1]
```

**示例 4：**

```
输入：root = [1,2]
输出：[1,2]
```

**提示：**

- 树中结点数在范围 `[0, 104]` 内
- `-1000 <= Node.val <= 1000`

### 参考题解

1. [笨猪爆破组](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/solutions/290289/shou-hui-tu-jie-gei-chu-dfshe-bfsliang-chong-jie-f)
2. [评论区](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/solutions/290289/shou-hui-tu-jie-gei-chu-dfshe-bfsliang-chong-jie-f/comments/1696066)

### DFS

![image-20240318145400330](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202403181454636.png)

 :balloon:  **收获: **

- 巧妙利用 `istringstream`

    1. 用一个字符串初始化istringstream对象 is
    2. 用一个字符串s, 接收被空格分割出来的前一部分字符串（通过使用">>"读取 is 到 s 中） 

    ```cpp
    string data = "1 2 # # 3 4 5";
    //用字符串data来初始化输入字符串流 is, 这意味着 is 对象可以像流一样从中读取数据，就像从标准输入流 std::cin 中读取数据一样
    istringstream is(data);
    string s;
    is >> s; //">>"使用空格作为分隔符来读取输入流中的数据
    // 这步操作之后is变成"2 # # 3 4 5", s = "1" 
    ```

#### 代码

```c++
class Codec {
public:
    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        // 得到二叉树的先序序列
        if (root == nullptr) return "#";   
        string left_str = serialize(root->left);
        string right_str = serialize(root->right);
        return to_string(root->val) + " " + left_str + " " + right_str;
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) { 
        istringstream is(data); //用一个字符串data来初始化输入字符串流is
        return buildTree(is);
    }
    TreeNode* buildTree(istringstream& is) {
        // 由于-1000 <= Node.val可能为负，因此s不能是char类型
        string s;
        // ">>"使用空格作为分隔符来读取输入流中的数据
        is >> s;
        if (s == "#") return nullptr;
        TreeNode* root = new TreeNode(stoi(s));
        root->left = buildTree(is);
        root->right = buildTree(is);
        return root;
    }
};
```

#### 复杂度分析

- 时间复杂度：O(n)  

- 空间复杂度：O(n)

### BFS

#### 代码

```c++
class Codec {
public:
    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        if (!root) return "#";
        string ans;
        queue<TreeNode*> que;
        que.push(root);
        // 层序遍历，得到的字符串中同一棵树上的三个结点根左右是紧挨的
        while (!que.empty()) { 
            TreeNode* node = que.front();  que.pop();  
            if (node) {
                // 空格放在值前面还是值后面都行
                ans += to_string(node->val) + " ";
                que.push(node->left);  
                que.push(node->right); 
            } else {
                ans += "# ";
            }
        }
        return ans;
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        istringstream is(data); 
        string s;
        is >> s;
        if (s == "#") return nullptr;
        TreeNode* root = new TreeNode(stoi(s));
        queue<TreeNode*> que;
        que.push(root);
        string leftStr, rightStr;
        while (is >> leftStr >> rightStr) {
            TreeNode* node = que.front();  que.pop();
            if (leftStr != "#") {
                node->left = new TreeNode(stoi(leftStr));
                que.push(node->left);
            }
            if (rightStr != "#") {
                node->right = new TreeNode(stoi(rightStr));
                que.push(node->right);
            }
        }
        return root;
    }
};
```

#### 复杂度分析

- 时间复杂度：O(n)  

- 空间复杂度：O(n)

## :fire:[79. 单词搜索](https://leetcode.cn/problems/word-search/)

### 题意

给定一个 `m x n` 二维字符网格 `board` 和一个字符串单词 `word` 。如果 `word` 存在于网格中，返回 `true` ；否则，返回 `false` 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

**示例 1：**

![img](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202403201708483.jpeg)

```
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg)

```
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "SEE"
输出：true
```

**示例 3：**

![img](https://assets.leetcode.com/uploads/2020/10/15/word3.jpg)

```
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCB"
输出：false
```

**提示：**

- `m == board.length`
- `n = board[i].length`
- `1 <= m, n <= 6`
- `1 <= word.length <= 15`
- `board` 和 `word` 仅由大小写英文字母组成

**进阶：**你可以使用搜索剪枝的技术来优化解决方案，使其在 `board` 更大的情况下可以更快解决问题？

### 参考题解

1. 

### 思路

==:star: **核心思路： +   +   **:star:==

**:key:  key：**

- 

**:question:   problems:** 

1. 为什么?

:heavy_check_mark:  **answer:** 

2. 

**:small_red_triangle_down:  steps: **

1.  

 :balloon:  **收获: **

- 

**:x: careless | ignore :**

- 

### 代码

```c++
class Solution {
public:
    vector<pair<int, int>> dir = {{-1,0}, {1,0}, {0,-1}, {0,1}};
    int rows;
    int cols;
    vector<vector<int>> visited;

    bool inArea(int i, int j) {
        return i < rows && j < cols && i >= 0 && j >= 0;
    }
    bool backTraking(int i, int j, int matchIndex, const vector<vector<char>>& board, const string& word) {
        // 1.递归参数以及返回值：(i,j)表示当前搜索位置，matchIndex表示需要匹配的word下标
        // 2.递归结束条件:
        if (board[i][j] != word[matchIndex]) {
            return false;
        }
        if (matchIndex == word.size() - 1) {
            return true;
        }
        // 3.单层递归做啥事？判断(i,j)往哪走能匹配
        visited[i][j] = 1; //标记已访问
        for (auto& [x, y] : dir) {
            int nextX = i + x;
            int nextY = j + y;
            if (inArea(nextX, nextY) && !visited[nextX][nextY]) {
                if (backTraking(nextX, nextY, matchIndex + 1, board, word)) {
                    return true;
                }
            }
        }
        // 能走到这就说明如果走(i,j)，则接下来走哪条路都不通，因此不能走(i,j)
        visited[i][j] = 0; //回溯
        return false;
    }
    bool exist(vector<vector<char>>& board, string word) {
        rows = board.size();
        if (rows == 0) {
            return false;
        }
        cols = board[0].size();
        // 因为已经搜过的位置不能重复搜，因此需要一个visited数组
        visited = vector<vector<int>>(rows, vector<int>(cols));
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; ++j) {
                if(backTraking(i, j, 0, board, word)) {
                    return true;
                }
            }
        }
        return false;
    }
};
```

## :fire:[114. 二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)

### 题意

给你二叉树的根结点 `root` ，请你将它展开为一个单链表：

- 展开后的单链表应该同样使用 `TreeNode` ，其中 `right` 子指针指向链表中下一个结点，而左子指针始终为 `null` 。
- 展开后的单链表应该与二叉树 [**先序遍历**](https://baike.baidu.com/item/先序遍历/6442839?fr=aladdin) 顺序相同。

**示例 1：**

![img](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202403230940531.jpeg)

```
输入：root = [1,2,5,3,4,null,6]
输出：[1,null,2,null,3,null,4,null,5,null,6]
```

**示例 2：**

```
输入：root = []
输出：[]
```

**示例 3：**

```
输入：root = [0]
输出：[0]
```

**提示：**

- 树中结点数在范围 `[0, 2000]` 内
- `-100 <= Node.val <= 100`

**进阶：**你可以使用原地算法（`O(1)` 额外空间）展开这棵树吗？

### 参考题解

1. [官解](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/solutions/356853/er-cha-shu-zhan-kai-wei-lian-biao-by-leetcode-solu) 法三，图把过程模拟的很清晰

### 代码

```c++
void flatten(TreeNode* root) {
    while (root) {
        // 如果root的左子为空，则其无需进行任何展开操作
        if (root->left) {
            auto leftTail = root->left;
            // 找到左子树的最右结点leftTail
            while (leftTail->right) {
                leftTail = leftTail->right;
            }
            // 将root的右子树接到leftTail的右子树上
            leftTail->right = root->right;
            // 然后将接好的左右子树(都在root->left)接在root右子树
            root->right = root->left;
            root->left = nullptr;
        }
        // 当前root任务完成, 继续往下展开
        root = root->right; 
    }
}
```

### 复杂度分析

- 时间复杂度：O(n)  

- 空间复杂度：O(1)

## :fire:[208. 实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/)

### 题意

**[Trie](https://baike.baidu.com/item/字典树/9825209?fr=aladdin)**（发音类似 "try"）或者说 **前缀树** 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。

请你实现 Trie 类：

- `Trie()` 初始化前缀树对象。
- `void insert(String word)` 向前缀树中插入字符串 `word` 。
- `boolean search(String word)` 如果字符串 `word` 在前缀树中，返回 `true`（即，在检索之前已经插入）；否则，返回 `false` 。
- `boolean startsWith(String prefix)` 如果之前已经插入的字符串 `word` 的前缀之一为 `prefix` ，返回 `true` ；否则，返回 `false` 。

**示例：**

```
输入
["Trie", "insert", "search", "search", "startsWith", "insert", "search"]
[[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]
输出
[null, null, true, false, true, null, true]

解释
Trie trie = new Trie();
trie.insert("apple");
trie.search("apple");   // 返回 True
trie.search("app");     // 返回 False
trie.startsWith("app"); // 返回 True
trie.insert("app");
trie.search("app");     // 返回 True
```

**提示：**

- `1 <= word.length, prefix.length <= 2000`
- `word` 和 `prefix` 仅由小写英文字母组成
- `insert`、`search` 和 `startsWith` 调用次数 **总计** 不超过 `3 * 104` 次

### 参考题解

1. [samarua](https://blog.csdn.net/m0_46202073/article/details/107253959)

### 思路

**:question:   problems:** 

1. 为什么search()最后不是return true;?

:heavy_check_mark:  **answer:** 

1. 如果最后return true;的话那search()不是和startWith()一样了吗？

    因此要弄清楚！seach(word)是找前缀树中是否存在完整的word

    退出循环时cur指向word最后一个字符,说明word不在前缀树中

    如果走到word末尾了，但cur->isWord=false，说明word仅仅是一个前缀，并不完整

### 代码

```c++
class TrieNode {
public:
    bool isWord; //截至该结点是否是一个完整单词
    vector<TrieNode*> next; //下一个字母映射表
    TrieNode() : isWord(false), next(26) {}
};

class Trie {
private:
    TrieNode* root; 
public:
    // 【1.初始化前缀树对象】
    Trie() {
        root = new TrieNode();
    }
    // 【2.向前缀树中插入word】
    void insert(string word) {
        TrieNode* cur = root;
        // 逐个字符逐层找，只要在某一层没找到就插入结点
        for (char& ch : word) {
            int index = ch - 'a';
            // 找ch是否存在前缀树的第i层
            if (cur->next[index] == nullptr) {
                cur->next[index] = new TrieNode();
            }
            cur = cur->next[index];
        }
        cur->isWord = true;
    }
    // 【3.判断word是否在前缀树中（不能以前缀的形式存在！要以完整单词的形式存在！）】
    bool search(string word) {
        TrieNode* cur = root;
        // 逐个字符逐层找，只要在某一层没找到就return false;
        for (char& ch : word) {
            int index = ch - 'a';
            if (cur->next[index] == nullptr) return false;
            cur = cur->next[index];
        }
        return cur->isWord; //注意返回值！！！
    }
    // 【4.判断前缀树中是否有以prefix为前缀的单词】
    bool startsWith(string prefix) {
        TrieNode* cur = root;
        // 逐个字符逐层找，只要在某一层没找到就return false;
        for (char& ch : prefix) {
            int index = ch - 'a';
            if (cur->next[index] == nullptr) return false;
            cur = cur->next[index];
        }
        return true;
    }
};

/**
 * Your Trie object will be instantiated and called as such:
 * Trie* obj = new Trie();
 * obj->insert(word);
 * bool param_2 = obj->search(word);
 * bool param_3 = obj->startsWith(prefix);
 */
```

## :fire:[96. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/)

### 题意

给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。

**示例 1：**

![img](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202403261044676.jpeg)

```
输入：n = 3
输出：5
```

**示例 2：**

```
输入：n = 1
输出：1
```

**提示：**

- `1 <= n <= 19`

### 参考题解

1. [笨猪爆破组](https://leetcode.cn/problems/unique-binary-search-trees/solutions/330990/shou-hua-tu-jie-san-chong-xie-fa-dp-di-gui-ji-yi-h)

### 思路

==:star: **核心思路：dp  **:star:==

```c++
int numTrees(int n) {
    // 1.dp[i]表示由i个结点组成的二叉搜索树有多少种
    vector<int> dp(n + 1); 
    // 2.递推公式: dp[i] += dp[j] * dp[i - 1 - j];
    // 3.dp初始化
    dp[0] = 1; //空树也是二叉搜索树!!!
    // 4.遍历
    for (int i = 1; i <= n; i++) {
        // 根占一个结点，剩下左右子共i-1个结点
        for (int j = 0; j < i; ++j) {
            dp[i] += dp[j] * dp[i - 1 - j];
        }
    }
    return dp[n];
}
```

### 复杂度分析

- 时间复杂度：O(n^2^)  

- 空间复杂度：O(n)

## :fire:[337. 打家劫舍 III](https://leetcode.cn/problems/house-robber-iii/)

### 题意

小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 `root` 。

除了 `root` 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 **两个直接相连的房子在同一天晚上被打劫** ，房屋将自动报警。

给定二叉树的 `root` 。返回 ***在不触动警报的情况下** ，小偷能够盗取的最高金额* 。

 **示例 1:**

![img](https://assets.leetcode.com/uploads/2021/03/10/rob1-tree.jpg)

```
输入: root = [3,2,3,null,3,null,1]
输出: 7 
解释: 小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7
```

**示例 2:**

![img](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202403301120582.jpeg)

```
输入: root = [3,4,5,1,3,null,1]
输出: 9
解释: 小偷一晚能够盗取的最高金额 4 + 5 = 9
```

**提示：**

- 树的节点数在 `[1, 104]` 范围内
- `0 <= Node.val <= 104`

### 参考题解

1. 

### 法一

==:star: **核心思路：『树形』『DP』   **:star:==

**:key:  key：**

- 『树形』『DP』：每一个节点能偷到的最大价值由偷与不偷左右子树的情况转移而来

- 后序遍历，dp[i] = max(不偷当前结点，偷当前结点);
    - 不偷当前结点，那就可以偷其左右子，但是到底偷不偷左右子还要取决于左右子树的最大收益，比如可能左子树的最大收益是不偷左子得到的。
    - 偷当前结点，那就不能偷左右节点

#### 代码

```c++
pair<int, int> postTraversal(TreeNode* root) {
    // 1. 递归函数返回值：pair.first表示不偷当前节点能得到的最大价值，pair.second表示偷··· 
    // 2. 递归结束条件：到空结点时
    if(!root) return {0, 0};
    // 3. 单层递归做啥事：求root的dp值 => 通过偷与不偷子节点能获取的收益来决定自己要不要偷
    auto [notSteal_left, Steal_left] = postTraversal(root->left);   // 左
    auto [notSteal_right, Steal_right] = postTraversal(root->right);// 右
    // 不偷当前节点，此时最大价值考虑的是左/右整个两个子树的最大收益，而不单单是左右子这两个结点的，
    // 因此不能写成 notsteal = Steal_left + Steal_right
    int notsteal = max(notSteal_left, Steal_left) + max(notSteal_right, Steal_right);
    // 偷当前节点，则其左右孩子都不能偷
    int steal = root->val + notSteal_left + notSteal_right;
    return {notsteal, steal};
}
int rob(TreeNode* root) {
    auto [notSteal, Steal] = postTraversal(root);
    return max(notSteal, Steal);
}
```

#### 复杂度分析

- 时间复杂度：O(n)  

- 空间复杂度：O(n)

## :fire:[538. 把二叉搜索树转换为累加树](https://leetcode.cn/problems/convert-bst-to-greater-tree/)

### 题意

给出二叉 **搜索** 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 `node` 的新值等于原树中大于或等于 `node.val` 的值之和。

提醒一下，二叉搜索树满足下列约束条件：

- 节点的左子树仅包含键 **小于** 节点键的节点。
- 节点的右子树仅包含键 **大于** 节点键的节点。
- 左右子树也必须是二叉搜索树。

**注意：**本题和 1038: https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/ 相同

**示例 1：**

**![img](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202404031648901.png)**

```
输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]
```

**示例 2：**

```
输入：root = [0,null,1]
输出：[1,null,1]
```

**示例 3：**

```
输入：root = [1,0,2]
输出：[3,3,2]
```

**示例 4：**

```
输入：root = [3,2,4,1]
输出：[7,9,4,10] 
```

**提示：**

- 树中的节点数介于 `0` 和 `104` 之间。
- 每个节点的值介于 `-104` 和 `104` 之间。
- 树中的所有值 **互不相同** 。
- 给定的树为二叉搜索树。

### 参考题解

1. [笨猪爆破组](https://leetcode.cn/problems/convert-bst-to-greater-tree/solutions/421686/shou-hua-tu-jie-zhong-xu-bian-li-fan-xiang-de-by-x)

### 递归

```c++
class Solution {
public:
    int sum = 0;
    
    TreeNode* convertBST(TreeNode* root) {
        // 计算(处理)顺序为：右中左
        if (!root) return nullptr;
        convertBST(root->right); //右
        // 处理完右子树之后，sum已经等于右子树的所有结点之和了
        root->val += sum;    //中
        sum = root->val;     //更新sum
        convertBST(root->left);  //左
        return root;
    }
};
```

#### 复杂度分析

- 时间复杂度：O(n)  

- 空间复杂度：O(n)

### 迭代

==:star: **核心思路：颜色标记法 **:star:==

颜色标记法 可以参考:fire:[94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/) 

```c++
class Solution {
public:
    const int WHITE = 0;
    const int GRAY = 1;
    int sum = 0;
    
    TreeNode* convertBST(TreeNode* root) {
        // 计算(处理)顺序为：右中左, 
        // 由于栈是先进后出，而处理(计算)结点的时候是在出栈的时候，
        // 因此，右要先出栈, 那右就要后进，因此进栈顺序是左中右
        if (!root) return nullptr;
        stack<pair<TreeNode*, int>> st;
        st.push({root, 0});
        while (!st.empty()) {
            auto [node, color] = st.top(); st.pop();
            if (node == nullptr) continue;
            if (color == 0) {
                st.push({node->left, 0});
                st.push({node, 1});
                st.push({node->right, 0});
            } else {
                node->val += sum;
                sum = node->val;
            }
        }
        return root;
    }
};
```

#### 复杂度分析

- 时间复杂度：O(n)  

- 空间复杂度：O(n)



## [LCR 153. 二叉树中和为目标值的路径](https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/)