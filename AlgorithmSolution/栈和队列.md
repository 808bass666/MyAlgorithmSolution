## :fire:[20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/)

### **题意**

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。
3. 每个右括号都有一个对应的相同类型的左括号。

**示例 1：**

```
输入：s = "()"
输出：true
```

**示例 2：**

```
输入：s = "()[]{}"
输出：true
```

**示例 3：**

```
输入：s = "(]"
输出：false
```

 **提示：**

- `1 <= s.length <= 104`
- `s` 仅由括号 `'()[]{}'` 组成

### 代码

```c++
bool match(char top, char c) {
    if(top == '(') return c == ')'; 
    if(top == '{') return c == '}'; 
    else if(top == '[') return c == ']'; 
    else return false; //注意细节! top除了"({["之外,还可能是"]})"
}
bool isValid(string s) {
    stack<int> st;
    st.push(s[0]);
    for (int i = 1; i < s.size(); ++i) {
        // 注意细节! st非空才能调用top()
        if (!st.empty() && match(st.top(), s[i])) st.pop();
        else st.push(s[i]);
    }
    return st.empty();
}
```

### 复杂度分析

- 时间复杂度：O(n)  

- 空间复杂度：O(n)

## :fire:[239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

### 题意

给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。

返回 *滑动窗口中的最大值* 。

### 参考题解

1. [单调队列正式登场！| LeetCode：239. 滑动窗口最大值](https://www.bilibili.com/video/BV1XS4y1p7qj/?spm_id_from=333.337.search-card.all.click&vd_source=ff6d470acf2c91a9a48f2ac99a87fa5a) 卡哥就是坠钓的！！！

### 法一

==:star: **核心思路：优先级队列**:star:==

![SmartSelect_20240303_162119_Samsung Notes](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202403031555322.jpg)

![SmartSelect_20240303_161925_Samsung Notes](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202403031555146.jpg)

#### 代码

```c++
vector<int> maxSlidingWindow(vector<int>& nums, int k) {
    // 窗口右端点从k-1 ~ nums.size()-1, res总共(nums.size()-1)-(k-1)+1 = nums.size()-k+1个元素
    vector<int> res(nums.size() - k + 1);
    priority_queue<pair<int, int>> max_que;//默认是less<>大根堆
    // 初始将数组nums的前k个元素放入优先队列中
    for (int i = 0; i < k; i++) {
        max_que.push({nums[i], i});
    }       
    res[0] = max_que.top().first;          
    for (int i = k; i < nums.size(); i++) { //窗口右端点从下标k处开始移动
        // 前任窗口的范围是[i-k, i-1]
        // 现任窗口的范围是[i-k+1, i]
        int start = i - k + 1;
        max_que.push({nums[i], i});
        while (max_que.top().second < start) {
            max_que.pop();
        }
        // 窗口左端点从 0~nums.size()-k, 刚好和 res数组下标 对应
        res[start] = max_que.top().first;
    } 
    return res;
}
```

#### 复杂度分析

- 时间复杂度：O(nlogn)  。遍历元素是O(n)，堆操作是O(logn)

- 空间复杂度：O(n)。堆要使用的空间

### 法二

==:star: **核心思路：单调队列  **:star:==

![SmartSelect_20240303_162143_Samsung Notes](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202403031555468.jpg)

#### 代码

```c++
class MyQueue {
private:
    deque<int> que; // 维护一个单调(递减)队列
public:
    void push(int val) {
        // 如果队尾有比val小的元素，则持续pop_back()直到队尾不小于val
        while (!que.empty() && que.back() < val) {
            que.pop_back();
        }
        que.emplace_back(val);
    }
    void pop(int val) {
        // 如果要移出的左边界，在之前就已经被移出，那么什么都不做
        // 否则，还在单调队列中，那么必定在队头，直接pop_front()
        if (que.front() == val) {
            que.pop_front();
        }
    }
    int getMaxValue() {
        // 单调(递减)队列的最大值始终在队头
        return que.front();
    }
};
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        // 窗口右端点从k-1 ~ nums.size()-1, res总共(nums.size()-1)-(k-1)+1 = nums.size()-k+1个元素
        vector<int> res(nums.size() - k + 1);        
        MyQueue que;
        // 用前k个元素初始化单调队列
        for (int i = 0;  i < k; ++i) {
            que.push(nums[i]);
        }
        res[0] = que.getMaxValue();
        // 滑动窗口开始右移, 循环一次窗口右移一位，因此每次循环都要存结果
        for (int right = k; right < nums.size(); ++right) {
            // 1.移出前一个窗口的左边界
            // 当前窗口  :[right - k + 1, right] 
            // 前一个窗口:[right - k, right - 1]
            que.pop(nums[right - k]);
            // 2.将nums[right]移入窗口
            que.push(nums[right]);
            // 3.存结果
            res[right - k + 1] = que.getMaxValue();
            // right - k + 1 即窗口左端点，每次循环+1
        }
        return res;
    }
};
```

#### 复杂度分析

- 时间复杂度：O(n)。每个元素刚好一进一出被操作两次，也就是O(2n)，= O(n)  

- 空间复杂度：O(k)。单调队列最多只会存放k+1个元素

## :fire:[155. 最小栈](https://leetcode.cn/problems/min-stack/)

### 题意

设计一个支持 `push` ，`pop` ，`top` 操作，并能在常数时间内检索到最小元素的栈。

实现 `MinStack` 类:

- `MinStack()` 初始化堆栈对象。
- `void push(int val)` 将元素val推入堆栈。
- `void pop()` 删除堆栈顶部的元素。
- `int top()` 获取堆栈顶部的元素。
- `int getMin()` 获取堆栈中的最小元素。

**示例 1:**

```
输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

输出：
[null,null,null,null,-3,null,0,-2]

解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
```

**提示：**

- `-231 <= val <= 231 - 1`
- `pop`、`top` 和 `getMin` 操作总是在 **非空栈** 上调用
- `push`, `pop`, `top`, and `getMin`最多被调用 `3 * 104` 次

### 参考题解

1. [官解](https://leetcode.cn/problems/min-stack/solutions/242190/zui-xiao-zhan-by-leetcode-solution)
2. [wei神](https://leetcode.cn/problems/min-stack/solutions/13496/shi-yong-fu-zhu-zhan-tong-bu-he-bu-tong-bu-python-)

### 思路

==:star: **核心思路：辅助栈 **:star:==

### 代码

`pop`、`top` 和 `getMin` 操作总是在 **非空栈** 上调用，所以不用特判

```c++
class MinStack {
public:
    stack<int> main_st;
    stack<int> help_st; //help_st中从栈底到某位置的每个值，一一对应main_st中从栈底到某位置中元素的最小值

    MinStack() {
        
    }
    
    void push(int val) {
        // 一一对应进栈：
        // main_st直接将val进栈
        // 由于help_st存的是对应main_st的最小值，因此要先判断val是否小于栈顶top，是的话进栈val，否则进栈top
        main_st.push(val);
        if (help_st.empty()) {
            help_st.push(val);
        } else {
            help_st.push(min(val, help_st.top()));
        }   
    }
    
    void pop() {
        // 一一对应出栈
        main_st.pop();
        help_st.pop();
    }
    
    int top() {
        return main_st.top();
    }
    
    int getMin() {
        return help_st.top();
    }
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj->push(val);
 * obj->pop();
 * int param_3 = obj->top();
 * int param_4 = obj->getMin();
 */
```

### 复杂度分析

- 时间复杂度：O(1)  

- 空间复杂度：O(n)

## :fire:[739. 每日温度](https://leetcode.cn/problems/daily-temperatures/)

### 题意

给定一个整数数组 `temperatures` ，表示每天的温度，返回一个数组 `answer` ，其中 `answer[i]` 是指对于第 `i` 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。

**示例 1:**

```
输入: temperatures = [73,74,75,71,69,72,76,73]
输出: [1,1,4,2,1,1,0,0]
```

**示例 2:**

```
输入: temperatures = [30,40,50,60]
输出: [1,1,1,0]
```

**示例 3:**

```
输入: temperatures = [30,60,90]
输出: [1,1,0]
```

**提示：**

- `1 <= temperatures.length <= 105`
- `30 <= temperatures[i] <= 100`

### 参考题解

1. [程序员吴师兄](https://leetcode.cn/problems/daily-temperatures/solutions/71433/leetcode-tu-jie-739mei-ri-wen-du-by-misterbooo)  其实想到用单调栈的思路后自己动手画画就能模拟出来，不用看题解。

### 思路

==:star: **核心思路：单调栈  **:star:==

**:key:  key：**

- 维护一个单调递减的栈，在要push元素进栈前，先看看该元素会不会打破栈的单调性，如果会，则一直pop元素直到栈顶元素 > 要push进来的元素。

**:question:   problems:** 

1. 什么时候计算ans[ ] ?

:heavy_check_mark:  **answer:** 

1. 当元素被pop出来时。说明它遇到在它之后、比它大的第一个元素，此时就可以计算了。`ans[st.top()] = i - st.top();`

**模拟：**

![SmartSelect_20240318_203622_Samsung Notes](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202403182037655.jpg)

### 代码

```c++
vector<int> dailyTemperatures(vector<int>& temperatures) {
    int n = temperatures.size();
    vector<int> ans(n);
    stack<int> st; // 存放下标
    for (int i = 0; i < n; ++i) {
        while (!st.empty() && temperatures[i] > temperatures[st.top()]) {
            int j = st.top(); st.pop();
            ans[j] = i - j;
        }
        st.push(i);
    }
    return ans;
}
```

### 复杂度分析

- 时间复杂度：O(n)  

- 空间复杂度：O(n)

----

## :car:[225. 用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/)

### 题意

请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（`push`、`top`、`pop` 和 `empty`）。

实现 `MyStack` 类：

- `void push(int x)` 将元素 x 压入栈顶。
- `int pop()` 移除并返回栈顶元素。
- `int top()` 返回栈顶元素。
- `boolean empty()` 如果栈是空的，返回 `true` ；否则，返回 `false` 。

**注意：**

- 你只能使用队列的标准操作 —— 也就是 `push to back`、`peek/pop from front`、`size` 和 `is empty` 这些操作。
- 你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。

**示例：**

```
输入：
["MyStack", "push", "push", "top", "pop", "empty"]
[[], [1], [2], [], [], []]
输出：
[null, null, null, 2, 2, false]

解释：
MyStack myStack = new MyStack();
myStack.push(1);
myStack.push(2);
myStack.top(); // 返回 2
myStack.pop(); // 返回 2
myStack.empty(); // 返回 False
```

**提示：**

- `1 <= x <= 9`
- 最多调用`100` 次 `push`、`pop`、`top` 和 `empty`
- 每次调用 `pop` 和 `top` 都保证栈不为空

**进阶：**你能否仅用一个队列来实现栈。

### 两个队列实现栈

 自己动手画一画就知道了。

![image-20240411200428228](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202404112004304.png)

```c++
class MyStack {
public:
    queue<int> main_que; 	
    queue<int> backUp_que;

    MyStack() {

    }
    
    void push(int x) {
        main_que.push(x);
    }
    
    int pop() {
        int size = main_que.size();
        // 将除栈顶元素之外的其余元素先存到backUp_que以便之后备份
        size--;
        while (size--) {
            backUp_que.push(main_que.front());
            main_que.pop();
        }
        // 退出循环时main_que中只剩栈顶元素一个了,将其赋给结果并弹出
        int topVal = main_que.front(); main_que.pop();
        // 将备份队列中的元素都还原到main_que（直接赋值而不用一个个pop push）
        main_que = backUp_que;
        // 清空backUp_que
        while (!backUp_que.empty()) {
            backUp_que.pop();
        }
        return topVal;
    }
    
    int top() {
        return main_que.back();
    }
    
    bool empty() {
        return main_que.empty();
    }
};

/**
 * Your MyStack object will be instantiated and called as such:
 * MyStack* obj = new MyStack();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->top();
 * bool param_4 = obj->empty();
 */
```

### 一个队列实现栈

只需要：弹出结点push到backUp_que中，改为push到main_que中。（即将弹出结点直接追加到自己后面）

```c++
class MyStack {
public:
    queue<int> main_que;

    MyStack() {

    }
    
    void push(int x) {
        main_que.push(x);
    }
    
    int pop() {
        int size = main_que.size();
        // 将除栈顶元素之外的其余元素先存到backUp_que以便之后备份
        for (int i = 0; i < size - 1; ++i) {
            int x = main_que.front();  main_que.pop();
            main_que.push(x);
        }
        int topVal = main_que.front(); main_que.pop();
        return topVal;
    }
    
    int top() {
        return main_que.back();
    }
    
    bool empty() {
        return main_que.empty();
    }
};

/**
 * Your MyStack object will be instantiated and called as such:
 * MyStack* obj = new MyStack();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->top();
 * bool param_4 = obj->empty();
 */
```

 