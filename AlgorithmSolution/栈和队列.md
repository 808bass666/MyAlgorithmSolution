## 目录

[TOC]



## :fire:[20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/)

### **题意**

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。
3. 每个右括号都有一个对应的相同类型的左括号。

**示例 1：**

```
输入：s = "()"
输出：true
```

**示例 2：**

```
输入：s = "()[]{}"
输出：true
```

**示例 3：**

```
输入：s = "(]"
输出：false
```

 **提示：**

- `1 <= s.length <= 104`
- `s` 仅由括号 `'()[]{}'` 组成

### 代码

注意!!! st非空才能调用top() !!!

```c++
class Solution {
public:
    
    bool match(char top, char c) {
        switch (top) {
            case '(':
                return c == ')'; 
                break;
            case '{':
                return c == '}'; 
                break;
            case '[':
                return c == ']'; 
                break;
            default:
                return false; //注意细节! top除了"({["之外,还可能是"]})"
        }
    }
    bool isValid(string s) {
        // 用一个栈, 先将第一个括号进栈, 
        // 如果!!栈非空且!!后面要进来的括号和栈顶括号匹配上了,那就弹出栈顶
        // 否则, 将其进栈
        // 最后如果栈空,说明全匹配上了,返回true; 否则返回false
        stack<int> st;
        st.push(s[0]);
        for (int i = 1; i < s.size(); ++i) {
            // 注意细节! st非空才能调用top()
            if (!st.empty() && match(st.top(), s[i])) {
                st.pop();
            } else{ 
                st.push(s[i]);
            }
        }
        return st.empty();
    }
};
```

### 复杂度分析

- 时间复杂度：O(n)  

- 空间复杂度：O(n)

## :fire:[239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

### 题意

给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。

返回 *滑动窗口中的最大值* 。

**示例 1：**

```
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

**示例 2：**

```
输入：nums = [1], k = 1
输出：[1]
```

 **提示：**

- `1 <= nums.length <= 105`
- `-104 <= nums[i] <= 104`
- `1 <= k <= nums.length`

### 参考题解

1. [单调队列正式登场！| LeetCode：239. 滑动窗口最大值](https://www.bilibili.com/video/BV1XS4y1p7qj/?spm_id_from=333.337.search-card.all.click&vd_source=ff6d470acf2c91a9a48f2ac99a87fa5a) 卡哥就是坠钓的！！！

### 法一

==:star: **核心思路：优先级队列**:star:==

![SmartSelect_20240303_162119_Samsung Notes](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202403031555322.jpg)

![SmartSelect_20240303_161925_Samsung Notes](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202403031555146.jpg)

#### 代码

```c++
vector<int> maxSlidingWindow(vector<int>& nums, int k) {
    // 窗口右端点从k-1 ~ nums.size()-1, res总共(nums.size()-1)-(k-1)+1 = nums.size()-k+1个元素
    vector<int> res(nums.size() - k + 1);
    priority_queue<pair<int, int>> max_que;//默认是less<>大根堆
    // 初始化优先队列
    for (int i = 0; i < k; i++) {
        max_que.push({nums[i], i});
    }       
    res[0] = max_que.top().first;          
    for (int i = k; i < nums.size(); i++) { //窗口右端点从下标k处开始移动
        // 前任窗口的范围是[i-k, i-1]
        // 现任窗口的范围是[i-k+1, i]
        int start = i - k + 1;
        max_que.push({nums[i], i});
        while (max_que.top().second < start) {
            max_que.pop();
        }
        // 窗口左端点从 0~nums.size()-k, 刚好和 res数组下标 对应
        res[start] = max_que.top().first;
    } 
    return res;
}
```

#### 复杂度分析

- 时间复杂度：O(nlogn)  。遍历元素是O(n)，堆操作是O(logn)

- 空间复杂度：O(n)。堆要使用的空间

### 法二

==:star: **核心思路：单调队列  **:star:==

窗口只需要实时维护可能成为最大值的值就行了。用一个队列来维护窗口中可能成为最大值的那些值。

- 移入元素时，如果队尾元素比要进来的元素小，则将这些队尾元素全部pop。也就是说，我们实时维护一个单调队列，队列从队头到队尾递减

    > 如果这个过程中把窗口左端点nums[left]也pop了怎么办？没关系，反正这个左端点也不会成为新窗口的最大值，我们并不需要维护它，这里在push(nums[right])的时候把它pop了，之后pop(nums[left])要移出左端点的时候就不做处理即可（因为前面push的时候已经把它移出了）。

- 移出元素时，要移出的元素是窗口左端点，
    - 如果该元素是当前窗口的最大值，也就是说它是队首元素，那么直接pop_front即可
    - 如果不是，那么由移入元素的逻辑可知，该元素在之前就已经被pop_back卷出去了，不用再pop元素了

因为队列的两头都需要pop，因此使用的是deque双端队列

![SmartSelect_20240303_162143_Samsung Notes](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202403031555468.jpg)

#### 代码

```c++
class MyQueue {
private:
    deque<int> que; //单调队列，队列从队头到队尾递减
public:
    void push(int val) { // 需要维护队列单调
        while (!que.empty() && val > que.back()) {
            // 为什么不能是>=？
            // 如果加上=那就会对队列中的元素去重
            // 比如[-7,-8,7,5,7,1,6,0],k=4这个例子，当窗口从[-7,-8,7,5]变为[-8,7,5,7]，
            // push(7)时，会把前面的那个7在队列中pop掉，此时队列中只有一个7,即队列为{7}。
            // 这样会导致什么后果呢？
            // 当窗口继续右移直到[7,5,7,1]要右移移出左边界7时，需要que.pop(7)，而此时que中刚好只剩一个元素7, pop完que就为空了，这显然与我们的预期不同，正常来说，这时que中应该还有一个7
            que.pop_back();
        }
        que.emplace_back(val);
    }
    void pop(int val) {
        if (val == que.front()) {
            que.pop_front();
        }
    }
    int getMaxValue() {
        return que.front();
    }
};
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        MyQueue que;
        int left = 0;
        int right = 0;  
        // 初始化窗口为[0,k)
        while (right < k) {
            que.push(nums[right++]);
        }
        // 退出循环时left=0, right=k
        vector<int> ans;
        ans.emplace_back(que.getMaxValue());
        // 滑动窗口开始右移, 循环一次窗口右移一位，即移出left，移入right，移完存结果
        while (right < nums.size()) {
            que.pop(nums[left++]);
            que.push(nums[right++]);
            ans.emplace_back(que.getMaxValue());
        }
        return ans;
    }
};
```

当时排查push()中while条件为什么不能是=时用来打印日志的代码如下：

```cpp
class MyQueue {
private:
    deque<int> que; 
public:
    void push(int val) {   
        while (!que.empty() && val >= que.back()) { 
            que.pop_back();
        }
        que.emplace_back(val); 
    }
    void pop(int val) {
        if (val == que.front()) {
            que.pop_front();
        }
    }
    int getMaxValue() {
        return que.front();
    }
    void printQueue() {
        int size = que.size();
        while (size--) {
            int top = que.front();
            cout << top << " ";
            que.pop_front(); 
            que.push_back(top); 
        }
    }
};
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) { 
        MyQueue que;
        int left = 0;
        int right = 0;  
        while (right < k) {
            que.push(nums[right++]);
        }
        vector<int> ans;
        ans.emplace_back(que.getMaxValue());
        while (right < nums.size()) {
            cout << "==========================" << endl;
            cout << "右移前窗口的左右端点值: " << nums[left] << "," << nums[right-1] << endl; 
            
            que.pop(nums[left++]); 
            cout << "队列pop后：";
            que.printQueue();
            cout << endl;

            que.push(nums[right++]); 
            cout << "队列push后：";
            que.printQueue();
            cout << endl;

            ans.emplace_back(que.getMaxValue());
        }
        return ans;
    }
};
```



![image-20240531212409970](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202405312124080.png)

#### 复杂度分析

- 时间复杂度：O(n)。每个元素刚好一进一出被操作两次，也就是O(2n)，= O(n)  

- 空间复杂度：O(k)。单调队列最多只会存放k+1个元素

## :fire:[155. 最小栈](https://leetcode.cn/problems/min-stack/)

### 题意

设计一个支持 `push` ，`pop` ，`top` 操作，并能在常数时间内检索到最小元素的栈。

实现 `MinStack` 类:

- `MinStack()` 初始化堆栈对象。
- `void push(int val)` 将元素val推入堆栈。
- `void pop()` 删除堆栈顶部的元素。
- `int top()` 获取堆栈顶部的元素。
- `int getMin()` 获取堆栈中的最小元素。

**示例 1:**

```
输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

输出：
[null,null,null,null,-3,null,0,-2]

解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
```

**提示：**

- `-231 <= val <= 231 - 1`
- `pop`、`top` 和 `getMin` 操作总是在 **非空栈** 上调用
- `push`, `pop`, `top`, and `getMin`最多被调用 `3 * 104` 次

### 参考题解

1. [官解](https://leetcode.cn/problems/min-stack/solutions/242190/zui-xiao-zhan-by-leetcode-solution)
2. [wei神](https://leetcode.cn/problems/min-stack/solutions/13496/shi-yong-fu-zhu-zhan-tong-bu-he-bu-tong-bu-python-)

### 思路

==:star: **核心思路：辅助栈 **:star:==

### 代码

`pop`、`top` 和 `getMin` 操作总是在 **非空栈** 上调用，所以不用特判

```c++
class MinStack {
public:
    stack<int> main_st;
    stack<int> help_st; //help_st中从栈底到某位置的每个值，一一对应main_st中从栈底到某位置中元素的最小值

    MinStack() {
        
    }
    
    void push(int val) {
        // 一一对应进栈：
        // main_st直接将val进栈
        // 由于help_st存的是对应main_st的最小值，因此要先判断val是否小于栈顶top，是的话进栈val，否则进栈top
        main_st.push(val);
        if (help_st.empty()) {
            help_st.push(val);
        } else {
            help_st.push(min(val, help_st.top()));
        }   
    }
    
    void pop() {
        // 一一对应出栈
        main_st.pop();
        help_st.pop();
    }
    
    int top() {
        return main_st.top();
    }
    
    int getMin() {
        return help_st.top();
    }
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj->push(val);
 * obj->pop();
 * int param_3 = obj->top();
 * int param_4 = obj->getMin();
 */
```

### 复杂度分析

- 时间复杂度：O(1)  

- 空间复杂度：O(n)

## :fire:[739. 每日温度](https://leetcode.cn/problems/daily-temperatures/)

### 题意

给定一个整数数组 `temperatures` ，表示每天的温度，返回一个数组 `answer` ，其中 `answer[i]` 是指对于第 `i` 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。

**示例 1:**

```
输入: temperatures = [73,74,75,71,69,72,76,73]
输出: [1,1,4,2,1,1,0,0]
```

**示例 2:**

```
输入: temperatures = [30,40,50,60]
输出: [1,1,1,0]
```

**示例 3:**

```
输入: temperatures = [30,60,90]
输出: [1,1,0]
```

**提示：**

- `1 <= temperatures.length <= 105`
- `30 <= temperatures[i] <= 100`

### 参考题解

1. [程序员吴师兄](https://leetcode.cn/problems/daily-temperatures/solutions/71433/leetcode-tu-jie-739mei-ri-wen-du-by-misterbooo)  其实想到用单调栈的思路后自己动手画画就能模拟出来，不用看题解。

### 思路

==:star: **核心思路：单调栈  **:star:==

**:key:  key：**

- 维护一个单调递减的栈，在要push元素进栈前，先看看该元素会不会打破栈的单调性，如果会，则一直pop元素直到栈顶元素 > 要push进来的元素。

**:question:   problems:** 

1. 什么时候计算ans[ ] ?

:heavy_check_mark:  **answer:** 

1. 当元素被pop出来时。说明它遇到在它之后、比它大的第一个元素，此时就可以计算了。`ans[st.top()] = i - st.top();`

**模拟：**

![SmartSelect_20240318_203622_Samsung Notes](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202403182037655.jpg)

### 代码

```c++
vector<int> dailyTemperatures(vector<int>& temperatures) {
    int n = temperatures.size();
    vector<int> ans(n);
    stack<int> st; // 存放下标
    for (int i = 0; i < n; ++i) {
        while (!st.empty() && temperatures[i] > temperatures[st.top()]) {
            int j = st.top(); st.pop();
            ans[j] = i - j;
        }
        st.push(i);
    }
    return ans;
}
```

### 复杂度分析

- 时间复杂度：O(n)  

- 空间复杂度：O(n)

----

## :fire:[225. 用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/)

### 题意

请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（`push`、`top`、`pop` 和 `empty`）。

实现 `MyStack` 类：

- `void push(int x)` 将元素 x 压入栈顶。
- `int pop()` 移除并返回栈顶元素。
- `int top()` 返回栈顶元素。
- `boolean empty()` 如果栈是空的，返回 `true` ；否则，返回 `false` 。

**注意：**

- 你只能使用队列的标准操作 —— 也就是 `push to back`、`peek/pop from front`、`size` 和 `is empty` 这些操作。
- 你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。

**示例：**

```
输入：
["MyStack", "push", "push", "top", "pop", "empty"]
[[], [1], [2], [], [], []]
输出：
[null, null, null, 2, 2, false]

解释：
MyStack myStack = new MyStack();
myStack.push(1);
myStack.push(2);
myStack.top(); // 返回 2
myStack.pop(); // 返回 2
myStack.empty(); // 返回 False
```

**提示：**

- `1 <= x <= 9`
- 最多调用`100` 次 `push`、`pop`、`top` 和 `empty`
- 每次调用 `pop` 和 `top` 都保证栈不为空

**进阶：**你能否仅用一个队列来实现栈。

### 两个队列实现栈

 自己动手画一画就知道了。

![image-20240411200428228](https://cdn.jsdelivr.net/gh/808bass666/picBed@main/202404112004304.png)

```c++
class MyStack {
public:
    queue<int> main_que; 	
    queue<int> backUp_que;

    MyStack() {

    }
    
    void push(int x) {
        main_que.push(x);
    }
    
    int pop() {
        int size = main_que.size();
        // 将除栈顶元素之外的其余元素先存到backUp_que以便之后备份
        size--;
        while (size--) {
            backUp_que.push(main_que.front());
            main_que.pop();
        }
        // 退出循环时main_que中只剩栈顶元素一个了,将其赋给结果并弹出
        int topVal = main_que.front(); main_que.pop();
        // 将备份队列中的元素都还原到main_que（直接赋值而不用一个个pop push）
        main_que = backUp_que;
        // 清空backUp_que
        while (!backUp_que.empty()) {
            backUp_que.pop();
        }
        return topVal;
    }
    
    int top() {
        return main_que.back();
    }
    
    bool empty() {
        return main_que.empty();
    }
};
```

### 一个队列实现栈

只需要：弹出结点push到backUp_que中，改为push到main_que中。（即将弹出结点直接追加到自己后面）

```c++
class MyStack {
public:
    queue<int> main_que;

    MyStack() {

    }
    
    void push(int x) {
        main_que.push(x);
    }
    
    int pop() {
        int size = main_que.size();
        // 将除栈顶元素之外的其余元素先存到backUp_que以便之后备份
        for (int i = 0; i < size - 1; ++i) {
            int x = main_que.front();  main_que.pop();
            main_que.push(x);
        }
        int topVal = main_que.front(); main_que.pop();
        return topVal;
    }
    
    int top() {
        return main_que.back();
    }
    
    bool empty() {
        return main_que.empty();
    }
};
```

##  :fire:[232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)

### 题意

请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（`push`、`pop`、`peek`、`empty`）：

实现 `MyQueue` 类：

- `void push(int x)` 将元素 x 推到队列的末尾
- `int pop()` 从队列的开头移除并返回元素
- `int peek()` 返回队列开头的元素
- `boolean empty()` 如果队列为空，返回 `true` ；否则，返回 `false`

**说明：**

- 你 **只能** 使用标准的栈操作 —— 也就是只有 `push to top`, `peek/pop from top`, `size`, 和 `is empty` 操作是合法的。
- 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。

**示例 1：**

```
输入：
["MyQueue", "push", "push", "peek", "pop", "empty"]
[[], [1], [2], [], [], []]
输出：
[null, null, null, 1, 1, false]

解释：
MyQueue myQueue = new MyQueue();
myQueue.push(1); // queue is: [1]
myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)
myQueue.peek(); // return 1
myQueue.pop(); // return 1, queue is [2]
myQueue.empty(); // return false
```

**提示：**

- `1 <= x <= 9`
- 最多调用 `100` 次 `push`、`pop`、`peek` 和 `empty`
- 假设所有操作都是有效的 （例如，一个空的队列不会调用 `pop` 或者 `peek` 操作）

**进阶：**

- 你能否实现每个操作均摊时间复杂度为 `O(1)` 的队列？换句话说，执行 `n` 个操作的总时间复杂度为 `O(n)` ，即使其中一个操作可能花费较长时间。

### 参考题解

1. [宫水三叶](https://leetcode.cn/problems/implement-queue-using-stacks/solutions/635888/sha-shi-jun-tan-fu-za-du-ya-wo-de-suan-f-gb6d) 关于均摊O(1)

### 代码

#### O(n)解法 （不用看了）

```cpp
class MyQueue {
public:
    /*
    用两个栈实现队列的先进先出，main栈的顶部就当作是队头，pop和peek操作的就是栈顶
    main栈的底部就是队尾，因此实现push接口就需要将main栈中所有元素先弹出存到辅助栈，
    然后把x进栈，再把辅助栈的元素存进来
    */
    stack<int> main_st;
    stack<int> help_st;

    MyQueue() {
        
    }
    
    void push(int x) {
        while (!main_st.empty()) {
            int val = main_st.top(); main_st.pop();
            help_st.push(val);
        }
        main_st.push(x);
        while (!help_st.empty()) {
            int val = help_st.top(); help_st.pop();
            main_st.push(val);
        }
    }
    
    int pop() {
        int val = main_st.top(); main_st.pop();
        return val;
    }
    
    int peek() {
        return main_st.top();
    }
    
    bool empty() {
        return main_st.empty();
    }
};
```

#### 均摊O(1)

第一种解法需要在每次push的时候操作所有元素（在两个栈之间导入导出），时间复杂度为O(n)；

均摊O(1)的解法就是，只在输出栈为空时，**才发生一次性的「倒腾」**：将输入栈的所有元素全部导入到输出栈。之后每次pop只要pop输出栈的元素即可。

```c++
class MyQueue {
public:
    stack<int> stIn;
    stack<int> stOut;

    MyQueue() {
        
    }
    
    void push(int x) {
        stIn.push(x); //输入栈的栈顶是队列的队尾
    }
    
    int pop() {
        // 输出栈为空则将输入栈的全部数据依次弹出并压入输出栈
        // 这样输出栈的栈顶就是队列的队首，pop队列时直接pop输出栈即可
        if (stOut.empty()) {
            while (!stIn.empty()) {
                stOut.push(stIn.top());
                stIn.pop();
            }
        } 
        int val = stOut.top(); stOut.pop();
        return val;
    }
    
    int peek() {
        // return stOut.top();
        // 不能直接这样写，因为可能此时输出栈为空，输入栈的元素未导入进去
        int x = this->pop();
        stOut.push(x);
        return x;
    }
    
    bool empty() {
        return stIn.empty() && stOut.empty();
    }
};
```

